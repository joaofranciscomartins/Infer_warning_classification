Found 1760 issues

java/org/apache/catalina/startup/AddPortOffsetRule.java:34: error: NULL_DEREFERENCE
  object `conn` last assigned on line 30 could be null and is dereferenced at line 34.
  32.   
  33.           int portOffset = server.getPortOffset();
  34. >         conn.setPortOffset(portOffset);
  35.       }

java/org/apache/catalina/startup/AddPortOffsetRule.java:33: error: NULL_DEREFERENCE
  object `server` last assigned on line 31 could be null and is dereferenced at line 33.
  31.           Server server = (Server) digester.peek(2);
  32.   
  33. >         int portOffset = server.getPortOffset();
  34.           conn.setPortOffset(portOffset);
  35.       }

java/org/apache/tomcat/buildutil/translate/BackportEnglish.java:32: error: NULL_DEREFERENCE
  object `backport.sourceEnglish` last assigned on line 31 could be null and is dereferenced by call to `execute()` at line 32.
  30.       public static void main(String... args) throws IOException {
  31.           BackportEnglish backport = new BackportEnglish(args);
  32. >         backport.execute();
  33.       }
  34.   

java/org/apache/tomcat/buildutil/translate/Import.java:33: error: NULL_DEREFERENCE
  object returned by `root.listFiles()` could be null and is dereferenced at line 33.
  31.           File root = new File(Constants.STORAGE_DIR);
  32.   
  33. >         for (File f : root.listFiles()) {
  34.               // Not robust but good enough
  35.               if (f.isFile() && f.getName().startsWith(Constants.L10N_PREFIX)) {

java/org/apache/catalina/core/ApplicationMapping.java:58: error: NULL_DEREFERENCE
  object `path` last assigned on line 57 could be null and is dereferenced at line 58.
  56.                       case EXTENSION:
  57.                           String path = mappingData.wrapperPath.toString();
  58. >                         int extIndex = path.lastIndexOf('.');
  59.                           mapping = new MappingImpl(path.substring(1, extIndex),
  60.                                   "*" + path.substring(extIndex), mappingData.matchType, servletName);

java/org/apache/catalina/core/ApplicationMapping.java:53: error: NULL_DEREFERENCE
  object returned by `ApplicationMapping.mappingData.wrapperPath.toString()` could be null and is dereferenced at line 53.
  51.                           break;
  52.                       case EXACT:
  53. >                         mapping = new MappingImpl(mappingData.wrapperPath.toString().substring(1),
  54.                                   mappingData.wrapperPath.toString(), mappingData.matchType, servletName);
  55.                           break;

java/org/apache/tomcat/jni/Library.java:66: error: NULL_DEREFERENCE
  object `path` last assigned on line 65 could be null and is dereferenced at line 66.
  64.           if (!loaded) {
  65.               String path = System.getProperty("java.library.path");
  66. >             String [] paths = path.split(File.pathSeparator);
  67.               for (int i = 0; i < NAMES.length; i++) {
  68.                   try {

java/org/apache/tomcat/websocket/DigestAuthenticator.java:60: error: NULL_DEREFERENCE
  object `messageQop` last assigned on line 53 could be null and is dereferenced at line 60.
  58.           StringBuilder challenge = new StringBuilder();
  59.   
  60. >         if (!messageQop.isEmpty()) {
  61.               if (cnonceGenerator == null) {
  62.                   cnonceGenerator = new SecureRandom();

java/org/apache/catalina/ssi/SSIEcho.java:63: error: NULL_DEREFERENCE
  object `originalValue` last assigned on line 44 could be null and is dereferenced by call to `getVariableValue(...)` at line 63.
  61.               }
  62.           }
  63. >         String variableValue = ssiMediator.getVariableValue(originalValue, encoding);
  64.           if (variableValue == null) {
  65.               variableValue = MISSING_VARIABLE_VALUE;

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSourceFactory.java:93: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource` acquired to `pupds` by call to `PerUserPoolDataSource()` at line 42 is not released after line 93.
**Note**: potential exception at line 67
  91.               pupds.setPerUserDefaultReadOnly((Map<String, Boolean>) deserialize(serialized));
  92.           }
  93. >         return pupds;
  94.       }
  95.   }

java/org/apache/tomcat/util/compat/JrePlatform.java:54: error: NULL_DEREFERENCE
  object `osName` last assigned on line 42 could be null and is dereferenced at line 54.
  52.           }
  53.   
  54. >         IS_MAC_OS = osName.toLowerCase(Locale.ENGLISH).startsWith("mac os x");
  55.   
  56.           IS_WINDOWS = osName.startsWith("Windows");

java/org/apache/tomcat/util/file/ConfigurationSource.java:57: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 57 is not released after line 57.
  55.               try {
  56.                   URL url = uri.toURL();
  57. >                 return new Resource(url.openConnection().getInputStream(), uri);
  58.               } catch (MalformedURLException e) {
  59.                   throw new FileNotFoundException(name);

java/org/apache/tomcat/util/file/ConfigurationSource.java:57: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 57 is not released after line 57.
  55.               try {
  56.                   URL url = uri.toURL();
  57. >                 return new Resource(url.openConnection().getInputStream(), uri);
  58.               } catch (MalformedURLException e) {
  59.                   throw new FileNotFoundException(name);

java/org/apache/tomcat/util/scan/UrlJar.java:47: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `getInputStream()` at line 47 is not released after line 47.
**Note**: potential exception at line 47
  45.           URLConnection resourceConn = resourceURL.openConnection();
  46.           resourceConn.setUseCaches(false);
  47. >         return new NonClosingJarInputStream(resourceConn.getInputStream());
  48.       }
  49.   }

java/org/apache/tomcat/util/scan/UrlJar.java:47: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 45 is not released after line 47.
  45.           URLConnection resourceConn = resourceURL.openConnection();
  46.           resourceConn.setUseCaches(false);
  47. >         return new NonClosingJarInputStream(resourceConn.getInputStream());
  48.       }
  49.   }

java/org/apache/tomcat/util/scan/UrlJar.java:47: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 45 is not released after line 47.
  45.           URLConnection resourceConn = resourceURL.openConnection();
  46.           resourceConn.setUseCaches(false);
  47. >         return new NonClosingJarInputStream(resourceConn.getInputStream());
  48.       }
  49.   }

java/org/apache/catalina/webresources/FileResource.java:50: error: NULL_DEREFERENCE
  object `encoding` last assigned on line 49 could be null and is dereferenced at line 50.
  48.           try {
  49.               String encoding = System.getProperty("file.encoding");
  50. >             if (encoding.contains("EBCDIC")) {
  51.                   isEBCDIC = true;
  52.               }

java/org/apache/tomcat/dbcp/dbcp2/DataSourceConnectionFactory.java:44: error: NULL_DEREFERENCE
  object `null` is dereferenced by call to `DataSourceConnectionFactory(...)` at line 44.
  42.        */
  43.       public DataSourceConnectionFactory(final DataSource dataSource) {
  44. >         this(dataSource, null, (char[]) null);
  45.       }
  46.   

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:49: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 49.
  47.           digester.setNamespaceAware(false);
  48.           digester.setValidating(false);
  49. >         URL url = Registry.getRegistry(null, null).getClass().getResource
  50.               ("/org/apache/tomcat/util/modeler/mbeans-descriptors.dtd");
  51.           digester.register

java/org/apache/tomcat/util/http/parser/Host.java:45: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.util.http.parser.Host$MessageBytesReader` acquired by call to `new()` at line 45 is not released after line 45.
**Note**: potential exception at line 45
  43.        */
  44.       public static int parse(MessageBytes mb) {
  45. >         return parse(new MessageBytesReader(mb));
  46.       }
  47.   

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:52: error: NULL_DEREFERENCE
  object `taglibXml` last assigned on line 51 could be null and is dereferenced at line 52.
  50.               public void begin(String namespace, String name, Attributes attributes) {
  51.                   TaglibXml taglibXml = (TaglibXml) digester.peek();
  52. >                 taglibXml.setJspVersion(attributes.getValue("version"));
  53.               }
  54.           });

java/org/apache/tomcat/util/descriptor/tld/ImplicitTldRuleSet.java:53: error: NULL_DEREFERENCE
  object `taglibXml` last assigned on line 52 could be null and is dereferenced at line 53.
  51.               public void begin(String namespace, String name, Attributes attributes) {
  52.                   TaglibXml taglibXml = (TaglibXml) digester.peek();
  53. >                 taglibXml.setJspVersion(attributes.getValue("version"));
  54.               }
  55.           });

java/org/apache/catalina/util/LifecycleMBeanBase.java:57: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 57.
  55.           // preRegister().
  56.           if (oname == null) {
  57. >             mserver = Registry.getRegistry(null, null).getMBeanServer();
  58.   
  59.               oname = register(this, getObjectNameKeyProperties());

java/javax/servlet/jsp/el/ScopedAttributeELResolver.java:64: error: NULL_DEREFERENCE
  object `page` last assigned on line 63 could be null and is dereferenced at line 64.
  62.                   String key = property.toString();
  63.                   PageContext page = (PageContext) context.getContext(JspContext.class);
  64. >                 result = page.findAttribute(key);
  65.   
  66.                   if (result == null) {

java/javax/el/ELManager.java:56: error: NULL_DEREFERENCE
  object returned by `getELContext().getFunctionMapper()` could be null and is dereferenced at line 56.
  54.   
  55.       public void mapFunction(String prefix, String function, Method method) {
  56. >         getELContext().getFunctionMapper().mapFunction(
  57.                   prefix, function, method);
  58.       }

java/org/apache/catalina/ha/backend/CollectedInfo.java:59: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 59.
  57.           int iport = 0;
  58.           String shost = null;
  59. >         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
  60.           String onStr = "*:type=ThreadPool,*";
  61.           ObjectName objectName = new ObjectName(onStr);

java/org/apache/catalina/startup/ConnectorCreateRule.java:62: error: NULL_DEREFERENCE
  object `svc` last assigned on line 59 could be null and is dereferenced at line 62.
  60.           Executor ex = null;
  61.           if ( attributes.getValue("executor")!=null ) {
  62. >             ex = svc.getExecutor(attributes.getValue("executor"));
  63.           }
  64.           Connector con = new Connector(attributes.getValue("protocol"));

java/javax/el/ELManager.java:61: error: NULL_DEREFERENCE
  object returned by `getELContext().getVariableMapper()` could be null and is dereferenced at line 61.
  59.   
  60.       public void setVariable(String variable, ValueExpression expression) {
  61. >         getELContext().getVariableMapper().setVariable(variable, expression);
  62.       }
  63.   

java/org/apache/catalina/startup/CopyParentClassLoaderRule.java:72: error: NULL_DEREFERENCE
  object `child` last assigned on line 66 could be null and is dereferenced at line 72.
  70.           ClassLoader classLoader =
  71.               (ClassLoader) method.invoke(parent, new Object[0]);
  72. >         child.setParentClassLoader(classLoader);
  73.   
  74.       }

java/org/apache/catalina/startup/CopyParentClassLoaderRule.java:69: error: NULL_DEREFERENCE
  object `parent` last assigned on line 67 could be null and is dereferenced at line 69.
  67.           Object parent = digester.peek(1);
  68.           Method method =
  69. >             parent.getClass().getMethod("getParentClassLoader", new Class[0]);
  70.           ClassLoader classLoader =
  71.               (ClassLoader) method.invoke(parent, new Object[0]);

java/org/apache/catalina/manager/JMXProxyServlet.java:70: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 70.
  68.           // Retrieve the MBean server
  69.           registry = Registry.getRegistry(null, null);
  70. >         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
  71.       }
  72.   

java/org/apache/catalina/tribes/group/interceptors/SimpleCoordinator.java:89: error: NULL_DEREFERENCE
  object `members` last assigned on line 88 could be null and is dereferenced at line 89.
  87.   
  88.           final Member[] members = getMembers();
  89. >         final Member[] view = new Member[members.length+1];
  90.           System.arraycopy(members, 0, view, 0, members.length);
  91.           view[members.length] = getLocalMember(false);

java/org/apache/catalina/startup/ExpandWar.java:92: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 83 is not released after line 92.
  90.           try (InputStream is = jfuc.getInputStream()) {
  91.               // Get the last modified time for the WAR
  92. >             warLastModified = jfuc.getLastModified();
  93.           }
  94.   

java/org/apache/catalina/startup/ExpandWar.java:92: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 83 is not released after line 92.
  90.           try (InputStream is = jfuc.getInputStream()) {
  91.               // Get the last modified time for the WAR
  92. >             warLastModified = jfuc.getLastModified();
  93.           }
  94.   

java/org/apache/tomcat/websocket/pojo/PojoMethodMapping.java:182: error: NULL_DEREFERENCE
  object `clazzPojoMethods` last assigned on line 83 could be null and is dereferenced by call to `isOverridenWithoutAnnotation(...)` at line 182.
  180.           for (MessageHandlerInfo messageHandler : onMessage) {
  181.               if (messageHandler.m.getDeclaringClass() != clazzPojo
  182. >                     && isOverridenWithoutAnnotation(clazzPojoMethods, messageHandler.m, OnMessage.class)) {
  183.                   overriddenOnMessage.add(messageHandler);
  184.               }

java/org/apache/catalina/ant/ValidatorTask.java:107: error: RESOURCE_LEAK
  resource of type `java.io.PrintStream` acquired by call to `handleErrorOutput(...)` at line 103 is not released after line 107.
**Note**: potential exception at line 94
  105.           } finally {
  106.               Thread.currentThread().setContextClassLoader(oldCL);
  107. >             closeRedirector();
  108.           }
  109.   

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java:83: error: NULL_DEREFERENCE
  object `MbeansDescriptorsIntrospectionSource.registry` last assigned on line 76 could be null and is dereferenced at line 83.
  81.               managed.setName( type );
  82.   
  83. >             registry.addManagedBean(managed);
  84.   
  85.           } catch( Exception ex ) {

java/javax/el/ELManager.java:81: error: NULL_DEREFERENCE
  object `localBeans` last assigned on line 78 could be null and is dereferenced at line 81.
  79.   
  80.           if (bean == null) {
  81. >             return localBeans.remove(name);
  82.           } else {
  83.               return localBeans.put(name, bean);

java/javax/el/ELManager.java:83: error: NULL_DEREFERENCE
  object `localBeans` last assigned on line 78 could be null and is dereferenced at line 83.
  81.               return localBeans.remove(name);
  82.           } else {
  83. >             return localBeans.put(name, bean);
  84.           }
  85.       }

java/org/apache/juli/AsyncFileHandler.java:78: error: NULL_DEREFERENCE
  object `null` is dereferenced by call to `AsyncFileHandler(...)` at line 78.
  76.   
  77.       public AsyncFileHandler(String directory, String prefix, String suffix) {
  78. >         this(directory, prefix, suffix, null);
  79.       }
  80.   

java/org/apache/tomcat/util/log/SystemLogHandler.java:94: error: RESOURCE_LEAK
  resource of type `java.io.PrintStream` acquired by call to `CaptureLog()` at line 87 is not released after line 94.
  92.               logs.set(stack);
  93.           }
  94. >         stack.push(log);
  95.       }
  96.   

java/org/apache/catalina/startup/CatalinaBaseConfigurationSource.java:116: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 116 is not released after line 116.
  114.           try {
  115.               URL url = uri.toURL();
  116. >             return new Resource(url.openConnection().getInputStream(), uri);
  117.           } catch (MalformedURLException e) {
  118.               throw new IOException(sm.getString("catalinaConfigurationSource.cannotObtainURL", name), e);

java/org/apache/catalina/startup/CatalinaBaseConfigurationSource.java:116: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 116 is not released after line 116.
  114.           try {
  115.               URL url = uri.toURL();
  116. >             return new Resource(url.openConnection().getInputStream(), uri);
  117.           } catch (MalformedURLException e) {
  118.               throw new IOException(sm.getString("catalinaConfigurationSource.cannotObtainURL", name), e);

java/org/apache/tomcat/util/http/fileupload/impl/FileItemStreamImpl.java:102: error: NULL_DEREFERENCE
  object returned by `FileItemStreamImpl.fileItemIteratorImpl.getMultiPartStream()` could be null and is dereferenced at line 102.
  100.           }
  101.           // OK to construct stream now
  102. >         final ItemInputStream itemStream = fileItemIteratorImpl.getMultiPartStream().newInputStream();
  103.           InputStream istream = itemStream;
  104.           if (fileSizeMax != -1) {

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:100: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 100.
  98.                       return ScopeManager.get(page).getHeaderValues();
  99.                   case INITPARAM:
  100. >                     return ScopeManager.get(page).getInitParam();
  101.                   case PAGECONTEXT:
  102.                       return ScopeManager.get(page).getPageContext();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:102: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 102.
  100.                       return ScopeManager.get(page).getInitParam();
  101.                   case PAGECONTEXT:
  102. >                     return ScopeManager.get(page).getPageContext();
  103.                   case PAGESCOPE:
  104.                       return ScopeManager.get(page).getPageScope();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:104: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 104.
  102.                       return ScopeManager.get(page).getPageContext();
  103.                   case PAGESCOPE:
  104. >                     return ScopeManager.get(page).getPageScope();
  105.                   case PARAM:
  106.                       return ScopeManager.get(page).getParam();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:106: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 106.
  104.                       return ScopeManager.get(page).getPageScope();
  105.                   case PARAM:
  106. >                     return ScopeManager.get(page).getParam();
  107.                   case PARAM_VALUES:
  108.                       return ScopeManager.get(page).getParamValues();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:108: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 108.
  106.                       return ScopeManager.get(page).getParam();
  107.                   case PARAM_VALUES:
  108. >                     return ScopeManager.get(page).getParamValues();
  109.                   case REQUEST_SCOPE:
  110.                       return ScopeManager.get(page).getRequestScope();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:110: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 110.
  108.                       return ScopeManager.get(page).getParamValues();
  109.                   case REQUEST_SCOPE:
  110. >                     return ScopeManager.get(page).getRequestScope();
  111.                   case SESSION_SCOPE:
  112.                       return ScopeManager.get(page).getSessionScope();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:112: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 112.
  110.                       return ScopeManager.get(page).getRequestScope();
  111.                   case SESSION_SCOPE:
  112. >                     return ScopeManager.get(page).getSessionScope();
  113.                   }
  114.               }

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:92: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 92.
  90.                   switch (idx) {
  91.                   case APPLICATIONSCOPE:
  92. >                     return ScopeManager.get(page).getApplicationScope();
  93.                   case COOKIE:
  94.                       return ScopeManager.get(page).getCookie();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:94: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 94.
  92.                       return ScopeManager.get(page).getApplicationScope();
  93.                   case COOKIE:
  94. >                     return ScopeManager.get(page).getCookie();
  95.                   case HEADER:
  96.                       return ScopeManager.get(page).getHeader();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:96: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 96.
  94.                       return ScopeManager.get(page).getCookie();
  95.                   case HEADER:
  96. >                     return ScopeManager.get(page).getHeader();
  97.                   case HEADERVALUES:
  98.                       return ScopeManager.get(page).getHeaderValues();

java/javax/servlet/jsp/el/ImplicitObjectELResolver.java:98: error: NULL_DEREFERENCE
  object `page` last assigned on line 88 could be null and is dereferenced by call to `get(...)` at line 98.
  96.                       return ScopeManager.get(page).getHeader();
  97.                   case HEADERVALUES:
  98. >                     return ScopeManager.get(page).getHeaderValues();
  99.                   case INITPARAM:
  100.                       return ScopeManager.get(page).getInitParam();

java/org/apache/tomcat/util/net/jsse/PEMFile.java:85: error: RESOURCE_LEAK
  resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 86 is not released after line 85.
**Note**: potential exception at line 90
  83.   
  84.           List<Part> parts = new ArrayList<>();
  85. >         try (InputStream inputStream = ConfigFileLoader.getSource().getResource(filename).getInputStream()) {
  86.               BufferedReader reader =
  87.                       new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.US_ASCII));

java/org/apache/catalina/webresources/CachedResource.java:138: error: NULL_DEREFERENCE
  object `webResourceInternal` last assigned on line 124 could be null and is dereferenced at line 138.
  136.   
  137.               // Has a resource been inserted / removed in a different resource set
  138. >             if (webResource.getLastModified() != webResourceInternal.getLastModified() ||
  139.                       webResource.getContentLength() != webResourceInternal.getContentLength()) {
  140.                   return false;

java/org/apache/catalina/storeconfig/StoreFactoryRule.java:99: error: NULL_DEREFERENCE
  object `desc` last assigned on line 96 could be null and is dereferenced at line 99.
  97.           StoreRegistry registry = (StoreRegistry) digester.peek(1);
  98.           factory.setRegistry(registry);
  99. >         desc.setStoreFactory(factory);
  100.   
  101.       }

java/org/apache/jasper/servlet/JspServlet.java:152: error: NULL_DEREFERENCE
  object returned by `JspServlet.options.getScratchDir()` could be null and is dereferenced at line 152.
  150.           if (log.isDebugEnabled()) {
  151.               log.debug(Localizer.getMessage("jsp.message.scratch.dir.is",
  152. >                     options.getScratchDir().toString()));
  153.               log.debug(Localizer.getMessage("jsp.message.dont.modify.servlets"));
  154.           }

java/org/apache/catalina/ssi/SSIFilter.java:108: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.ssi.ByteArrayServletOutputStream` acquired by call to `ByteArrayServletOutputStream()` at line 94 is not released after line 108.
  106.   
  107.           // is this an allowed type for SSI processing?
  108. >         if (contentType != null && contentTypeRegEx.matcher(contentType).matches()) {
  109.               String encoding = res.getCharacterEncoding();
  110.   

java/org/apache/catalina/tribes/membership/StaticMembershipService.java:90: error: NULL_DEREFERENCE
  object returned by `getRegistry(MembershipServiceBase.channel)` could be null and is dereferenced at line 90.
  88.               if (provider != null && provider.stop(level)) {
  89.                   if (oname != null) {
  90. >                     JmxRegistry.getRegistry(channel).unregisterJmx(oname);
  91.                       oname = null;
  92.                   }

java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java:91: error: NULL_DEREFERENCE
  object returned by `getRegistry(ReplicationTransmitter.channel)` could be null and is dereferenced at line 91.
  89.           getTransport().disconnect();
  90.           if (oname != null) {
  91. >             JmxRegistry.getRegistry(channel).unregisterJmx(oname);
  92.               oname = null;
  93.           }

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:96: error: NULL_DEREFERENCE
  object `sender` last assigned on line 95 could be null and is dereferenced at line 96.
  94.               try {
  95.                   BioSender sender = bioSenders.get(mbr);
  96. >                 sender.disconnect();
  97.               }catch ( Exception e ) {
  98.                   if ( x == null ) x = new ChannelException(e);

java/org/apache/catalina/startup/LifecycleListenerRule.java:130: error: NULL_DEREFERENCE
  object `c` last assigned on line 95 could be null and is dereferenced at line 130.
  128.   
  129.           // Add this LifecycleListener to our associated component
  130. >         c.addLifecycleListener(listener);
  131.       }
  132.   

java/org/apache/tomcat/util/file/ConfigurationSource.java:94: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 94 is not released after line 94.
  92.           public long getLastModified()
  93.                   throws MalformedURLException, IOException {
  94. >             return uri.toURL().openConnection().getLastModified();
  95.           }
  96.           @Override

java/org/apache/tomcat/util/file/ConfigurationSource.java:94: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 94 is not released after line 94.
  92.           public long getLastModified()
  93.                   throws MalformedURLException, IOException {
  94. >             return uri.toURL().openConnection().getLastModified();
  95.           }
  96.           @Override

java/org/apache/catalina/ha/session/DeltaSession.java:96: error: NULL_DEREFERENCE
  object `null` is dereferenced by call to `DeltaSession(...)` at line 96.
  94.   
  95.       public DeltaSession() {
  96. >         this(null);
  97.       }
  98.   

java/org/apache/catalina/realm/MessageDigestCredentialHandler.java:116: error: NULL_DEREFERENCE
  object `userDigest` last assigned on line 114 could be null and is dereferenced at line 116.
  114.                   String userDigest = Base64.encodeBase64String(ConcurrentMessageDigest.digest(
  115.                           getAlgorithm(), inputCredentials.getBytes(StandardCharsets.ISO_8859_1)));
  116. >                 return userDigest.equals(serverDigest);
  117.   
  118.               } else if (storedCredentials.startsWith("{SSHA}")) {

java/javax/el/ExpressionFactory.java:170: error: NULL_DEREFERENCE
  object returned by `clazz.getConstructor(__new_array(java.lang.Class*[_*_]))` could be null and is dereferenced at line 170.
  168.               }
  169.               if (constructor == null) {
  170. >                 result = (ExpressionFactory) clazz.getConstructor().newInstance();
  171.               } else {
  172.                   result =

java/org/apache/catalina/manager/StatusManagerServlet.java:104: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 104.
  102.   
  103.           // Retrieve the MBean server
  104. >         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
  105.   
  106.           try {

java/org/apache/jasper/compiler/JspReader.java:119: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired to `caw` by call to `new()` at line 113 is not released after line 119.
**Note**: potential exception at line 115
  117.               caw.close();
  118.               current = new Mark(this, caw.toCharArray(), fname);
  119. >         } catch (Throwable ex) {
  120.               ExceptionUtils.handleThrowable(ex);
  121.               log.error(Localizer.getMessage("jsp.error.file.cannot.read", fname), ex);

java/org/apache/catalina/mbeans/MBeanFactory.java:120: error: NULL_DEREFERENCE
  object `host` last assigned on line 118 could be null and is dereferenced at line 120.
  118.               Container host = engine.findChild(hostName);
  119.               String pathStr = getPathStr(path);
  120. >             Container context = host.findChild(pathStr);
  121.               return context;
  122.           } else if (type != null) {

java/org/apache/catalina/realm/MemoryRuleSet.java:119: error: NULL_DEREFERENCE
  object `realm` last assigned on line 118 could be null and is dereferenced at line 119.
  117.           MemoryRealm realm =
  118.               (MemoryRealm) digester.peek(digester.getCount() - 1);
  119. >         realm.addUser(username, password, roles);
  120.   
  121.       }

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:122: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.dbcp.dbcp2.PoolableConnection` acquired by call to `makeObject()` at line 115 is not released after line 122.
  120.           } finally {
  121.               if (p != null) {
  122. >                 connectionFactory.destroyObject(p);
  123.               }
  124.           }

java/org/apache/catalina/tribes/transport/bio/BioReceiver.java:149: error: RESOURCE_LEAK
  resource of type `java.io.InputStream` acquired by call to `accept()` at line 128 is not released after line 149.
  147.               ObjectReader reader = new ObjectReader(socket);
  148.               task.serviceSocket(socket,reader);
  149. >             getExecutor().execute(task);
  150.           }//while
  151.       }

java/org/apache/catalina/tribes/group/interceptors/SimpleCoordinator.java:114: error: NULL_DEREFERENCE
  object returned by `getLocalMember(0)` could be null and is dereferenced at line 114.
  112.   
  113.       public boolean isCoordinator() {
  114. >         return view == null ? false : getLocalMember(false).equals(
  115.                   getCoordinator());
  116.       }

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:119: error: NULL_DEREFERENCE
  object `others` last assigned on line 118 could be null and is dereferenced at line 119.
  117.               synchronized (members) {
  118.                   Member[] others = super.getMembers();
  119. >                 Member[] result = new Member[members.size() + others.length];
  120.                   for (int i = 0; i < others.length; i++) result[i] = others[i];
  121.                   for (int i = 0; i < members.size(); i++) result[i + others.length] = members.get(i);

java/org/apache/tomcat/util/digester/CallParamRule.java:146: error: NULL_DEREFERENCE
  object `parameters` last assigned on line 145 could be null and is dereferenced at line 146.
  144.           if(param != null) {
  145.               Object parameters[] = (Object[]) digester.peekParams();
  146. >             parameters[paramIndex] = param;
  147.           }
  148.       }

java/org/apache/coyote/http2/HpackEncoder.java:133: error: NULL_DEREFERENCE
  object returned by `headers.getName(it).toString()` could be null and is dereferenced at line 133.
  131.           while (it < currentHeaders.size()) {
  132.               // FIXME: Review lowercase policy
  133. >             String headerName = headers.getName(it).toString().toLowerCase(Locale.US);
  134.               boolean skip = false;
  135.               if (firstPass) {

java/org/apache/coyote/http2/HpackEncoder.java:133: error: NULL_DEREFERENCE
  object returned by `headers.getName(it)` could be null and is dereferenced at line 133.
  131.           while (it < currentHeaders.size()) {
  132.               // FIXME: Review lowercase policy
  133. >             String headerName = headers.getName(it).toString().toLowerCase(Locale.US);
  134.               boolean skip = false;
  135.               if (firstPass) {

java/org/apache/jasper/compiler/TldCache.java:134: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 132 is not released after line 134.
  132.                   URLConnection conn = url.openConnection();
  133.                   result[0] = conn.getLastModified();
  134. >                 if ("file".equals(url.getProtocol())) {
  135.                       // Reading the last modified time opens an input stream so we
  136.                       // need to make sure it is closed again otherwise the TLD file

java/org/apache/jasper/compiler/TldCache.java:134: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 132 is not released after line 134.
  132.                   URLConnection conn = url.openConnection();
  133.                   result[0] = conn.getLastModified();
  134. >                 if ("file".equals(url.getProtocol())) {
  135.                       // Reading the last modified time opens an input stream so we
  136.                       // need to make sure it is closed again otherwise the TLD file

java/org/apache/coyote/http2/StreamProcessor.java:133: error: NULL_DEREFERENCE
  object returned by `StreamProcessor.stream.getCoyoteRequest().getAttribute("org.apache.tomcat.sendfile.end")` could be null and is dereferenced at line 133.
  131.                       org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();
  132.               sendfileData.end = ((Long) stream.getCoyoteRequest().getAttribute(
  133. >                     org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();
  134.               sendfileData.left = sendfileData.end - sendfileData.pos;
  135.               sendfileData.stream = stream;

java/org/apache/coyote/http2/StreamProcessor.java:131: error: NULL_DEREFERENCE
  object returned by `StreamProcessor.stream.getCoyoteRequest().getAttribute("org.apache.tomcat.sendfile.start")` could be null and is dereferenced at line 131.
  129.               sendfileData.path = new File(fileName).toPath();
  130.               sendfileData.pos = ((Long) stream.getCoyoteRequest().getAttribute(
  131. >                     org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();
  132.               sendfileData.end = ((Long) stream.getCoyoteRequest().getAttribute(
  133.                       org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();

java/javax/servlet/jsp/el/ScopedAttributeELResolver.java:133: error: NULL_DEREFERENCE
  object `page` last assigned on line 132 could be null and is dereferenced at line 133.
  131.                   String key = property.toString();
  132.                   PageContext page = (PageContext) context.getContext(JspContext.class);
  133. >                 int scope = page.getAttributesScope(key);
  134.                   if (scope != 0) {
  135.                       page.setAttribute(key, value, scope);

java/org/apache/catalina/tribes/membership/cloud/CloudMembershipService.java:127: error: NULL_DEREFERENCE
  object returned by `getRegistry(MembershipServiceBase.channel)` could be null and is dereferenced at line 127.
  125.               if (membershipProvider != null && membershipProvider.stop(level)) {
  126.                   if (oname != null) {
  127. >                     JmxRegistry.getRegistry(channel).unregisterJmx(oname);
  128.                       oname = null;
  129.                   }

java/org/apache/tomcat/util/digester/FactoryCreateRule.java:151: error: NULL_DEREFERENCE
  object `top` last assigned on line 148 could be null and is dereferenced at line 151.
  149.           if (digester.log.isDebugEnabled()) {
  150.               digester.log.debug("[FactoryCreateRule]{" + digester.match +
  151. >                     "} Pop " + top.getClass().getName());
  152.           }
  153.   

java/org/apache/catalina/authenticator/FormAuthenticator.java:196: error: NULL_DEREFERENCE
  object `requestURI` last assigned on line 193 could be null and is dereferenced at line 196.
  194.   
  195.           // Is this the action request from the login page?
  196. >         boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION);
  197.   
  198.           LoginConfig config = context.getLoginConfig();

java/org/apache/tomcat/buildutil/Txt2Html.java:142: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 142 is not released after line 142.
  140.           try (BufferedReader in = new BufferedReader(new InputStreamReader(
  141.                   new FileInputStream(from), SOURCE_ENCODING))) {
  142. >             try (PrintWriter out = new PrintWriter(new OutputStreamWriter(
  143.                       new FileOutputStream(to), "UTF-8"))) {
  144.   

java/javax/el/BeanELResolver.java:153: error: NULL_DEREFERENCE
  object `matchingMethod` last assigned on line 150 could be null and is dereferenced at line 153.
  151.   
  152.           Object[] parameters = Util.buildParameters(
  153. >                 matchingMethod.getParameterTypes(), matchingMethod.isVarArgs(),
  154.                   params);
  155.   

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:176: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 176.
  174.   
  175.           // Retrieve the MBean server
  176. >         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
  177.   
  178.           started = true;

java/org/apache/tomcat/util/digester/ObjectCreateRule.java:143: error: NULL_DEREFERENCE
  object `top` last assigned on line 140 could be null and is dereferenced at line 143.
  141.           if (digester.log.isDebugEnabled()) {
  142.               digester.log.debug("[ObjectCreateRule]{" + digester.match +
  143. >                     "} Pop " + top.getClass().getName());
  144.           }
  145.   

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:143: error: NULL_DEREFERENCE
  object `taglibXml` last assigned on line 142 could be null and is dereferenced at line 143.
  141.           public void begin(String namespace, String name, Attributes attributes) throws Exception {
  142.               TaglibXml taglibXml = (TaglibXml) digester.peek(digester.getCount() - 1);
  143. >             digester.push(new Attribute("1.2".equals(taglibXml.getJspVersion())));
  144.           }
  145.   

java/org/apache/catalina/util/LifecycleMBeanBase.java:158: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 158.
  156.           try {
  157.               on = new ObjectName(name.toString());
  158. >             Registry.getRegistry(null, null).registerComponent(obj, on, null);
  159.           } catch (MalformedObjectNameException e) {
  160.               log.warn(sm.getString("lifecycleMBeanBase.registerFail", obj, name),

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:150: error: NULL_DEREFERENCE
  object `attribute` last assigned on line 148 could be null and is dereferenced at line 150.
  148.               Attribute attribute = (Attribute) digester.pop();
  149.               TagXml tag = (TagXml) digester.peek();
  150. >             tag.getAttributes().add(attribute.toTagAttributeInfo());
  151.           }
  152.       }

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:150: error: NULL_DEREFERENCE
  object `tag` last assigned on line 149 could be null and is dereferenced at line 150.
  148.               Attribute attribute = (Attribute) digester.pop();
  149.               TagXml tag = (TagXml) digester.peek();
  150. >             tag.getAttributes().add(attribute.toTagAttributeInfo());
  151.           }
  152.       }

java/org/apache/catalina/util/URLEncoder.java:185: error: RESOURCE_LEAK
  resource of type `java.io.OutputStreamWriter` acquired by call to `new()` at line 155 is not released after line 185.
  183.               }
  184.           }
  185. >         return rewrittenPath.toString();
  186.       }
  187.   

java/javax/servlet/jsp/el/ScopedAttributeELResolver.java:163: error: NULL_DEREFERENCE
  object `ctxt` last assigned on line 157 could be null and is dereferenced at line 163.
  161.           String name;
  162.   
  163. >         e = ctxt.getAttributeNamesInScope(PageContext.PAGE_SCOPE);
  164.           while (e.hasMoreElements()) {
  165.               name = e.nextElement();

java/org/apache/tomcat/util/modeler/BaseModelMBean.java:172: error: NULL_DEREFERENCE
  object `m` last assigned on line 169 could be null and is dereferenced at line 172.
  170.           Object result = null;
  171.           try {
  172. >             Class<?> declaring = m.getDeclaringClass();
  173.               // workaround for catalina weird mbeans - the declaring class is BaseModelMBean.
  174.               // but this is the catalina class.

java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java:169: error: RESOURCE_LEAK
  resource of type `java.util.zip.GZIPInputStream` acquired by call to `GZIPInputStream(...)` at line 162 is not released after line 169.
  167.               length = gin.read(tmp);
  168.           }
  169. >         return bout.toByteArray();
  170.       }
  171.   

java/org/apache/catalina/tribes/group/interceptors/GzipInterceptor.java:169: error: RESOURCE_LEAK
  resource of type `java.util.zip.GZIPInputStream` acquired to `gin` by call to `GZIPInputStream(...)` at line 162 is not released after line 169.
**Note**: potential exception at line 164
  167.               length = gin.read(tmp);
  168.           }
  169. >         return bout.toByteArray();
  170.       }
  171.   

java/org/apache/tomcat/util/http/MimeHeaders.java:173: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 161 is not released after line 173.
  171.               }
  172.           }
  173. >         return sw.toString();
  174.       }
  175.   

java/org/apache/juli/FileHandler.java:162: error: NULL_DEREFERENCE
  object `null` is dereferenced by call to `FileHandler(...)` at line 162.
  160.   
  161.       public FileHandler(String directory, String prefix, String suffix) {
  162. >         this(directory, prefix, suffix, null);
  163.       }
  164.   

java/org/apache/catalina/manager/HTMLManagerServlet.java:217: error: NULL_DEREFERENCE
  object `cn` last assigned on line 184 could be null and is dereferenced by call to `reload(...)` at line 217.
  215.                       smClient);
  216.           } else if (command.equals("/reload")) {
  217. >             message = reload(cn, smClient);
  218.           } else if (command.equals("/undeploy")) {
  219.               message = undeploy(cn, smClient);

java/org/apache/catalina/mbeans/NamingResourcesMBean.java:192: error: NULL_DEREFERENCE
  object `resource.resources` last assigned on line 185 could be null and is dereferenced by call to `createObjectName(...)` at line 192.
  190.           // Return the corresponding MBean name
  191.           ManagedBean managed = registry.findManagedBean("ContextResource");
  192. >         ObjectName oname = MBeanUtils.createObjectName(managed.getDomain(), resource);
  193.           return oname.toString();
  194.       }

java/org/apache/catalina/ssi/SSIServlet.java:207: error: RESOURCE_LEAK
  resource of type `java.io.FileInputStream` acquired by call to `getInputStream()` at line 198 is not released after line 207.
  205.               isr = new InputStreamReader(resourceInputStream);
  206.           } else {
  207. >             isr = new InputStreamReader(resourceInputStream, encoding);
  208.           }
  209.           BufferedReader bufferedReader = new BufferedReader(isr);

java/org/apache/tomcat/util/digester/CallParamRule.java:185: error: NULL_DEREFERENCE
  object `parameters` last assigned on line 184 could be null and is dereferenced at line 185.
  183.               // what we do now is push one parameter onto the top set of parameters
  184.               Object parameters[] = (Object[]) digester.peekParams();
  185. >             parameters[paramIndex] = bodyTextStack.pop();
  186.           }
  187.       }

java/org/apache/catalina/util/LifecycleMBeanBase.java:187: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 187.
  185.           name.append(':');
  186.           name.append(objectNameKeyProperties);
  187. >         Registry.getRegistry(null, null).unregisterComponent(name.toString());
  188.       }
  189.   

java/org/apache/catalina/tribes/group/ChannelInterceptorBase.java:187: error: NULL_DEREFERENCE
  object returned by `getRegistry(ChannelInterceptorBase.channel)` could be null and is dereferenced at line 187.
  185.           if (getNext() != null) getNext().stop(svc);
  186.           if (oname != null) {
  187. >             JmxRegistry.getRegistry(channel).unregisterJmx(oname);
  188.               oname = null;
  189.           }

java/org/apache/tomcat/websocket/Util.java:232: error: NULL_DEREFERENCE
  object `result` last assigned on line 229 could be null and is dereferenced at line 232.
  230.                       superClassType.getActualTypeArguments()[
  231.                               superClassTypeResult.getIndex()]);
  232. >             result.incrementDimension(superClassTypeResult.getDimension());
  233.               if (result.getClazz() != null && result.getDimension() > 0) {
  234.                   superClassTypeResult = result;

java/org/apache/catalina/storeconfig/StoreFileMover.java:191: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 190 is not released after line 191.
  189.       public PrintWriter getWriter() throws IOException {
  190.           return new PrintWriter(new OutputStreamWriter(
  191. >                 new FileOutputStream(configNew), getEncoding()));
  192.       }
  193.   

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:222: error: NULL_DEREFERENCE
  object `local` last assigned on line 196 could be null and is dereferenced at line 222.
  220.               int prio = AbsoluteOrder.comp.compare(local,others[0]);
  221.               Member leader = ( prio < 0 )?local:others[0];//am I the leader in my view?
  222. >             if ( local.equals(leader) || force ) {
  223.                   CoordinationMessage msg = createElectionMsg(local, others, leader);
  224.                   suggestedviewId = msg.getId();

java/org/apache/catalina/util/LifecycleMBeanBase.java:201: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 201.
  199.        */
  200.       protected final void unregister(ObjectName on) {
  201. >         Registry.getRegistry(null, null).unregisterComponent(on);
  202.       }
  203.   

java/org/apache/catalina/realm/UserDatabaseRealm.java:206: error: NULL_DEREFERENCE
  object returned by `getServer()` could be null and is dereferenced at line 206.
  204.   
  205.           try {
  206. >             Context context = getServer().getGlobalNamingContext();
  207.               database = (UserDatabase) context.lookup(resourceName);
  208.           } catch (Throwable e) {

java/org/apache/catalina/ha/session/ClusterManagerBase.java:206: error: NULL_DEREFERENCE
  object returned by `getContext()` could be null and is dereferenced at line 206.
  204.           super.startInternal();
  205.           if (getCluster() == null) {
  206. >             Cluster cluster = getContext().getCluster();
  207.               if (cluster instanceof CatalinaCluster) {
  208.                   setCluster((CatalinaCluster)cluster);

java/org/apache/catalina/mbeans/NamingResourcesMBean.java:225: error: NULL_DEREFERENCE
  object `oname` last assigned on line 224 could be null and is dereferenced at line 225.
  223.           ManagedBean managed = registry.findManagedBean("ContextResourceLink");
  224.           ObjectName oname = MBeanUtils.createObjectName(managed.getDomain(), resourceLink);
  225. >         return oname.toString();
  226.       }
  227.   

java/org/apache/catalina/mbeans/NamingResourcesMBean.java:224: error: NULL_DEREFERENCE
  object `resourceLink.resources` last assigned on line 217 could be null and is dereferenced by call to `createObjectName(...)` at line 224.
  222.           // Return the corresponding MBean name
  223.           ManagedBean managed = registry.findManagedBean("ContextResourceLink");
  224. >         ObjectName oname = MBeanUtils.createObjectName(managed.getDomain(), resourceLink);
  225.           return oname.toString();
  226.       }

java/org/apache/tomcat/util/http/fileupload/impl/FileItemIteratorImpl.java:219: error: NULL_DEREFERENCE
  object `multi` last assigned on line 213 could be null and is dereferenced at line 219.
  217.                   nextPart = multi.skipPreamble();
  218.               } else {
  219. >                 nextPart = multi.readBoundary();
  220.               }
  221.               if (!nextPart) {

java/org/apache/catalina/session/FileStore.java:232: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.util.CustomObjectInputStream` acquired by call to `getObjectInputStream(...)` at line 226 is not released after line 232.
  230.               session.setManager(manager);
  231.               return session;
  232. >         } catch (FileNotFoundException e) {
  233.               if (contextLog.isDebugEnabled()) {
  234.                   contextLog.debug("No persisted data file found");

java/org/apache/coyote/http11/Http11Processor.java:222: error: NULL_DEREFERENCE
  object returned by `*inputFilters[i].getEncodingName().toString()` could be null and is dereferenced at line 222.
  220.           } else {
  221.               for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {
  222. >                 if (inputFilters[i].getEncodingName().toString().equals(encodingName)) {
  223.                       inputBuffer.addActiveFilter(inputFilters[i]);
  224.                       return;

java/org/apache/catalina/session/StoreBase.java:227: error: RESOURCE_LEAK
  resource of type `java.io.BufferedInputStream` acquired by call to `new()` at line 218 is not released after line 227.
**Note**: potential exception at line 227
  225.               ois = new CustomObjectInputStream(bis, classLoader, manager.getContext().getLogger(),
  226.                       managerBase.getSessionAttributeValueClassNamePattern(),
  227. >                     managerBase.getWarnOnSessionAttributeFilterFailure());
  228.           } else {
  229.               ois = new CustomObjectInputStream(bis, classLoader);

java/org/apache/jasper/compiler/JavacErrorDetail.java:229: error: RESOURCE_LEAK
  resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 221 is not released after line 229.
**Note**: potential exception at line 225
  227.           }
  228.   
  229. >         return lines.toArray( new String[lines.size()] );
  230.       }
  231.   }

java/org/apache/catalina/manager/host/HTMLHostManagerServlet.java:242: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 240 is not released after line 242.
  240.           PrintWriter printWriter = new PrintWriter(stringWriter);
  241.   
  242. >         super.persist(printWriter, smClient);
  243.   
  244.           return stringWriter.toString();

java/javax/servlet/http/HttpServlet.java:246: error: RESOURCE_LEAK
  resource of type `javax.servlet.http.NoBodyOutputStream` acquired by call to `NoBodyResponse(...)` at line 244 is not released after line 246.
  244.               NoBodyResponse response = new NoBodyResponse(resp);
  245.               doGet(req, response);
  246. >             response.setContentLength();
  247.           }
  248.       }

java/org/apache/catalina/mbeans/MBeanFactory.java:243: error: NULL_DEREFERENCE
  object `container` last assigned on line 241 could be null and is dereferenced at line 243.
  241.           Container container = getParentContainerFromParent(pname);
  242.           // Add the new instance to its parent component
  243. >         container.setRealm(realm);
  244.           // Return the corresponding MBean name
  245.           ObjectName oname = null;

java/org/apache/catalina/startup/Bootstrap.java:261: error: NULL_DEREFERENCE
  object `Bootstrap.catalinaLoader` last assigned on line 252 could be null and is dereferenced at line 261.
  259.           if (log.isDebugEnabled())
  260.               log.debug("Loading startup class");
  261. >         Class<?> startupClass = catalinaLoader.loadClass("org.apache.catalina.startup.Catalina");
  262.           Object startupInstance = startupClass.getConstructor().newInstance();
  263.   

java/org/apache/catalina/manager/ManagerServlet.java:275: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 275.
  273.   
  274.           // Retrieve the MBean server
  275. >         mBeanServer = Registry.getRegistry(null, null).getMBeanServer();
  276.   
  277.       }

java/org/apache/tomcat/util/buf/MessageBytes.java:268: error: NULL_DEREFERENCE
  object `MessageBytes.strValue` last assigned on line 266 could be null and is dereferenced at line 268.
  266.           toString();
  267.           type = T_CHARS;
  268. >         char cc[] = strValue.toCharArray();
  269.           charC.setChars(cc, 0, cc.length);
  270.       }

java/org/apache/catalina/startup/Tomcat.java:294: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 292 is not released after line 294.
  292.           URLConnection uConn = source.openConnection();
  293.   
  294. >         try (InputStream is = uConn.getInputStream();
  295.                   OutputStream os = new FileOutputStream(targetWar)) {
  296.               IOTools.flow(is, os);

java/org/apache/catalina/startup/Tomcat.java:294: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 292 is not released after line 294.
  292.           URLConnection uConn = source.openConnection();
  293.   
  294. >         try (InputStream is = uConn.getInputStream();
  295.                   OutputStream os = new FileOutputStream(targetWar)) {
  296.               IOTools.flow(is, os);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:268: error: NULL_DEREFERENCE
  object returned by `msg.getMembers()` could be null and is dereferenced by call to `nextIndex(...)` at line 268.
  266.   
  267.       protected void sendElectionMsgToNextInline(Member local, CoordinationMessage msg) throws ChannelException {
  268. >         int next = Arrays.nextIndex(local,msg.getMembers());
  269.           int current = next;
  270.           msg.leader = msg.getMembers()[0];

java/org/apache/tomcat/util/http/fileupload/disk/DiskFileItem.java:274: error: NULL_DEREFERENCE
  object returned by `DiskFileItem.dfos.getData()` could be null and is dereferenced at line 274.
  272.               return cachedContent.length;
  273.           } else if (dfos.isInMemory()) {
  274. >             return dfos.getData().length;
  275.           } else {
  276.               return dfos.getFile().length();

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:286: error: NULL_DEREFERENCE
  object returned by `getManager(request)` could be null and is dereferenced at line 286.
  284.               Session catalinaSession = null;
  285.               try {
  286. >                 catalinaSession = getManager(request).findSession(sessionId);
  287.               } catch (IOException e) {
  288.                   // Hups!

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:299: error: NULL_DEREFERENCE
  object returned by `getManager(request)` could be null and is dereferenced at line 299.
  297.               } else {
  298.                   try {
  299. >                     catalinaSession = getManager(request).findSession(newSessionID);
  300.                   } catch (IOException e) {
  301.                       // Hups!

java/org/apache/tomcat/util/net/SecureNioChannel.java:298: error: NULL_DEREFERENCE
  object returned by `extractor.getResult()` could be null and is dereferenced at line 298.
  296.           List<Cipher> clientRequestedCiphers = null;
  297.           List<String> clientRequestedApplicationProtocols = null;
  298. >         switch (extractor.getResult()) {
  299.           case COMPLETE:
  300.               hostName = extractor.getSNIValue();

java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java:288: error: NULL_DEREFERENCE
  object `item` last assigned on line 286 could be null and is dereferenced at line 288.
  286.                   final FileItemStream item = iter.next();
  287.                   // Don't use getName() here to prevent an InvalidFileNameException.
  288. >                 final String fileName = ((FileItemStreamImpl) item).getName();
  289.                   FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),
  290.                                                      item.isFormField(), fileName);

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:310: error: NULL_DEREFERENCE
  object returned by `bsh.getSendResult()` could be null and is dereferenced at line 310.
  308.           for (MessagePart mp : messageParts) {
  309.               writeMessagePart(mp);
  310. >             if (!bsh.getSendResult().isOK()) {
  311.                   messagePartInProgress.release();
  312.                   Throwable t = bsh.getSendResult().getException();

java/org/apache/catalina/mbeans/MBeanFactory.java:306: error: NULL_DEREFERENCE
  object `coname` last assigned on line 304 could be null and is dereferenced at line 306.
  304.           ObjectName coname = retobj.getObjectName();
  305.   
  306. >         return coname.toString();
  307.       }
  308.   

java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java:300: error: NULL_DEREFERENCE
  object `sender` last assigned on line 299 could be null and is dereferenced at line 300.
  298.               try {
  299.                   NioSender sender = nioSenders.get(mbr);
  300. >                 sender.disconnect();
  301.               }catch ( Exception e ) {
  302.                   if ( x == null ) x = new ChannelException(e);

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:296: error: NULL_DEREFERENCE
  object `tag` last assigned on line 295 could be null and is dereferenced at line 296.
  294.               Variable variable = (Variable) digester.pop();
  295.               TagXml tag = (TagXml) digester.peek();
  296. >             tag.getVariables().add(variable.toTagVariableInfo());
  297.           }
  298.       }

java/org/apache/tomcat/util/descriptor/tld/TldRuleSet.java:296: error: NULL_DEREFERENCE
  object `variable` last assigned on line 294 could be null and is dereferenced at line 296.
  294.               Variable variable = (Variable) digester.pop();
  295.               TagXml tag = (TagXml) digester.peek();
  296. >             tag.getVariables().add(variable.toTagVariableInfo());
  297.           }
  298.       }

java/org/apache/jasper/compiler/Compiler.java:312: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 312 is not released after line 312.
  310.   
  311.           try {
  312. >             osw = new OutputStreamWriter(
  313.                       new FileOutputStream(javaFileName), javaEncoding);
  314.           } catch (UnsupportedEncodingException ex) {

java/org/apache/jasper/compiler/SmapStratum.java:347: error: NULL_DEREFERENCE
  object `li` last assigned on line 346 could be null and is dereferenced at line 347.
  345.           for (int i = 0; i < bound; i++) {
  346.               LineInfo li = lineData.get(i);
  347. >             out.append(li.getString());
  348.           }
  349.   

java/org/apache/jasper/compiler/TagLibraryInfoImpl.java:329: error: NULL_DEREFERENCE
  object `path` last assigned on line 319 could be null and is dereferenced by call to `parseTagFileDirectives(...)` at line 329.
  327.   
  328.           TagInfo tagInfo =
  329. >                 TagFileProcessor.parseTagFileDirectives(parserController, name, path, jar, this);
  330.           return new TagFileInfo(name, path, tagInfo);
  331.       }

java/org/apache/tomcat/util/buf/UDecoder.java:376: error: RESOURCE_LEAK
  resource of type `java.io.OutputStreamWriter` acquired by call to `new()` at line 349 is not released after line 376.
  374.                   }
  375.               }
  376. >             osw.flush();
  377.   
  378.               return baos.toString(charset.name());

java/org/apache/tomcat/util/buf/UDecoder.java:379: error: RESOURCE_LEAK
  resource of type `java.io.OutputStreamWriter` acquired to `osw` by call to `new()` at line 349 is not released after line 379.
**Note**: potential exception at line 373
  377.   
  378.               return baos.toString(charset.name());
  379. >         } catch (IOException ioe) {
  380.               throw new IllegalArgumentException(
  381.                       sm.getString("uDecoder.urlDecode.conversionError", str, charset.name()), ioe);

java/org/apache/catalina/authenticator/FormAuthenticator.java:329: error: NULL_DEREFERENCE
  object `decodedRequestURI` last assigned on line 328 could be null and is dereferenced at line 329.
  327.           String contextPath = this.context.getPath();
  328.           String decodedRequestURI = request.getDecodedRequestURI();
  329. >         if (decodedRequestURI.startsWith(contextPath) &&
  330.                   decodedRequestURI.endsWith(Constants.FORM_ACTION)) {
  331.               return true;

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:350: error: NULL_DEREFERENCE
  object `data.address` last assigned on line 343 could be null and is dereferenced by call to `createDataPackage(...)` at line 350.
  348.                   else options = (options & (~Channel.SEND_OPTIONS_USE_ACK));
  349.                   data.setOptions(options);
  350. >                 byte[] message = XByteBuffer.createDataPackage(data);
  351.                   socket.getOutputStream().write(message);
  352.                   if ( readTest ) {

java/org/apache/catalina/core/ApplicationFilterConfig.java:360: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 360.
  358.           try {
  359.               oname = new ObjectName(onameStr);
  360. >             Registry.getRegistry(null, null).registerComponent(this, oname, null);
  361.           } catch (Exception ex) {
  362.               log.warn(sm.getString("applicationFilterConfig.jmxRegisterFail",

java/org/apache/tomcat/dbcp/pool2/impl/SoftReferenceObjectPool.java:338: error: NULL_DEREFERENCE
  object `ref` last assigned on line 337 could be null and is dereferenced at line 338.
  336.                   try {
  337.                       final PooledSoftReference<T> ref = iter.next();
  338. >                     if (null != ref.getObject()) {
  339.                           factory.destroyObject(ref);
  340.                       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:344: error: NULL_DEREFERENCE
  object `local` last assigned on line 343 could be null and is dereferenced at line 344.
  342.       protected void handleToken(CoordinationMessage msg, Membership merged) throws ChannelException {
  343.           Member local = getLocalMember(false);
  344. >         if ( local.equals(msg.getSource()) ) {
  345.               //my message msg.src=local
  346.               handleMyToken(local, msg, merged);

java/org/apache/jasper/servlet/JspCServletContext.java:351: error: NULL_DEREFERENCE
  object returned by `getResource(path)` could be null and is dereferenced at line 351.
  349.               return null;
  350.           try {
  351. >             File f = new File(getResource(path).toURI());
  352.               return f.getAbsolutePath();
  353.           } catch (Throwable t) {

java/org/apache/jasper/compiler/PageInfo.java:349: error: NULL_DEREFERENCE
  object `stack` last assigned on line 348 could be null and is dereferenced at line 349.
  347.       public void popPrefixMapping(String prefix) {
  348.           LinkedList<String> stack = xmlPrefixMapper.get(prefix);
  349. >         stack.removeFirst();
  350.       }
  351.   

java/org/apache/catalina/core/ApplicationFilterConfig.java:372: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 372.
  370.           if (oname != null) {
  371.               try {
  372. >                 Registry.getRegistry(null, null).unregisterComponent(oname);
  373.                   if (log.isDebugEnabled())
  374.                       log.debug(sm.getString("applicationFilterConfig.jmxUnregister",

java/org/apache/catalina/startup/Tomcat.java:372: error: NULL_DEREFERENCE
  object `ctx` last assigned on line 371 could be null and is dereferenced by call to `addServlet(...)` at line 372.
  370.               String servletClass) {
  371.           Container ctx = getHost().findChild(contextPath);
  372. >         return addServlet((Context) ctx, servletName, servletClass);
  373.       }
  374.   

java/org/apache/catalina/tribes/membership/McastService.java:372: error: NULL_DEREFERENCE
  object returned by `getRegistry(MembershipServiceBase.channel)` could be null and is dereferenced at line 372.
  370.               if ( impl != null && impl.stop(svc) ) {
  371.                   if (oname != null) {
  372. >                     JmxRegistry.getRegistry(channel).unregisterJmx(oname);
  373.                       oname = null;
  374.                   }

java/org/apache/tomcat/util/net/SecureNio2Channel.java:399: error: NULL_DEREFERENCE
  object returned by `extractor.getResult()` could be null and is dereferenced at line 399.
  397.           List<Cipher> clientRequestedCiphers = null;
  398.           List<String> clientRequestedApplicationProtocols = null;
  399. >         switch (extractor.getResult()) {
  400.           case COMPLETE:
  401.               hostName = extractor.getSNIValue();

java/org/apache/jasper/JspCompilationContext.java:410: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 389 is not released after line 410.
  408.               if (uc != null) {
  409.                   try {
  410. >                     uc.getInputStream().close();
  411.                   } catch (IOException e) {
  412.                       if (log.isDebugEnabled()) {

java/org/apache/jasper/JspCompilationContext.java:410: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 389 is not released after line 410.
  408.               if (uc != null) {
  409.                   try {
  410. >                     uc.getInputStream().close();
  411.                   } catch (IOException e) {
  412.                       if (log.isDebugEnabled()) {

java/org/apache/catalina/realm/DataSourceRealm.java:383: error: NULL_DEREFERENCE
  object returned by `getServer()` could be null and is dereferenced at line 383.
  381.                   context = (Context) context.lookup("comp/env");
  382.               } else {
  383. >                 context = getServer().getGlobalNamingContext();
  384.               }
  385.               DataSource dataSource = (DataSource)context.lookup(dataSourceName);

java/org/apache/tomcat/util/codec/binary/BaseNCodec.java:411: error: NULL_DEREFERENCE
  object returned by `getBytesUtf8(pArray)` could be null and is dereferenced by call to `decode(...)` at line 411.
  409.        */
  410.       public byte[] decode(final String pArray) {
  411. >         return decode(StringUtils.getBytesUtf8(pArray));
  412.       }
  413.   

java/org/apache/catalina/users/MemoryUserDatabase.java:427: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 427 is not released after line 427.
  425.               String pathName = getPathname();
  426.               try (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getResource(pathName)) {
  427. >                 this.lastModified = resource.getURI().toURL().openConnection().getLastModified();
  428.   
  429.                   // Construct a digester to read the XML input file

java/org/apache/catalina/users/MemoryUserDatabase.java:427: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 427 is not released after line 427.
  425.               String pathName = getPathname();
  426.               try (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getResource(pathName)) {
  427. >                 this.lastModified = resource.getURI().toURL().openConnection().getLastModified();
  428.   
  429.                   // Construct a digester to read the XML input file

java/org/apache/catalina/mbeans/MBeanFactory.java:471: error: NULL_DEREFERENCE
  object returned by `context.getObjectName()` could be null and is dereferenced at line 471.
  469.   
  470.           // Return the corresponding MBean name
  471. >         return context.getObjectName().toString();
  472.   
  473.       }

java/org/apache/catalina/startup/WebAnnotationSet.java:429: error: NULL_DEREFERENCE
  object `type` last assigned on line 423 could be null and is dereferenced by call to `convertPrimitiveType(...)` at line 429.
  427.               }
  428.           }
  429. >         return Introspection.convertPrimitiveType(type).getCanonicalName();
  430.       }
  431.   

java/org/apache/jasper/servlet/JspCServletContext.java:424: error: NULL_DEREFERENCE
  object returned by `getResource(path)` could be null and is dereferenced at line 424.
  422.       public InputStream getResourceAsStream(String path) {
  423.           try {
  424. >             return getResource(path).openStream();
  425.           } catch (Throwable t) {
  426.               ExceptionUtils.handleThrowable(t);

java/org/apache/catalina/loader/WebappLoader.java:457: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 457.
  455.                           classLoader.getClass().getSimpleName() + ",host=" +
  456.                           context.getParent().getName() + ",context=" + contextName);
  457. >                 Registry.getRegistry(null, null).unregisterComponent(cloname);
  458.               } catch (Exception e) {
  459.                   log.warn(sm.getString("webappLoader.stopError"), e);

java/org/apache/tomcat/util/http/MimeHeaders.java:432: error: NULL_DEREFERENCE
  object returned by `NamesEnumerator.headers.getName(NamesEnumerator.pos)` could be null and is dereferenced at line 432.
  430.           next=null;
  431.           for(; pos< size; pos++ ) {
  432. >             next=headers.getName( pos ).toString();
  433.               for( int j=0; j<pos ; j++ ) {
  434.                   if( headers.getName( j ).equalsIgnoreCase( next )) {

java/org/apache/catalina/startup/Bootstrap.java:466: error: NULL_DEREFERENCE
  object `org.apache.catalina.startup.Bootstrap.daemon.catalinaDaemon` last assigned on line 441 could be null and is dereferenced by call to `load(...)` at line 466.
  464.               if (command.equals("startd")) {
  465.                   args[args.length - 1] = "start";
  466. >                 daemon.load(args);
  467.                   daemon.start();
  468.               } else if (command.equals("stopd")) {

java/org/apache/catalina/startup/Bootstrap.java:481: error: NULL_DEREFERENCE
  object `org.apache.catalina.startup.Bootstrap.daemon.catalinaDaemon` last assigned on line 441 could be null and is dereferenced by call to `load(...)` at line 481.
  479.                   daemon.stopServer(args);
  480.               } else if (command.equals("configtest")) {
  481. >                 daemon.load(args);
  482.                   if (null == daemon.getServer()) {
  483.                       System.exit(1);

java/org/apache/catalina/startup/Bootstrap.java:472: error: NULL_DEREFERENCE
  object `org.apache.catalina.startup.Bootstrap.daemon.catalinaDaemon` last assigned on line 441 could be null and is dereferenced by call to `setAwait(...)` at line 472.
  470.                   daemon.stop();
  471.               } else if (command.equals("start")) {
  472. >                 daemon.setAwait(true);
  473.                   daemon.load(args);
  474.                   daemon.start();

java/org/apache/catalina/startup/Bootstrap.java:470: error: NULL_DEREFERENCE
  object `org.apache.catalina.startup.Bootstrap.daemon.catalinaDaemon` last assigned on line 441 could be null and is dereferenced by call to `stop()` at line 470.
  468.               } else if (command.equals("stopd")) {
  469.                   args[args.length - 1] = "stop";
  470. >                 daemon.stop();
  471.               } else if (command.equals("start")) {
  472.                   daemon.setAwait(true);

java/org/apache/catalina/startup/Bootstrap.java:479: error: NULL_DEREFERENCE
  object `org.apache.catalina.startup.Bootstrap.daemon.catalinaDaemon` last assigned on line 441 could be null and is dereferenced by call to `stopServer(...)` at line 479.
  477.                   }
  478.               } else if (command.equals("stop")) {
  479. >                 daemon.stopServer(args);
  480.               } else if (command.equals("configtest")) {
  481.                   daemon.load(args);

java/org/apache/tomcat/util/buf/MessageBytes.java:450: error: NULL_DEREFERENCE
  object `MessageBytes.strValue` last assigned on line 449 could be null and is dereferenced at line 450.
  448.       public int indexOf(String s, int starting) {
  449.           toString();
  450. >         return strValue.indexOf( s, starting );
  451.       }
  452.   

java/javax/servlet/http/HttpServlet.java:505: error: NULL_DEREFERENCE
  object `methods` last assigned on line 483 could be null and is dereferenced at line 505.
  503.           // End of Tomcat specific hack
  504.   
  505. >         for (int i=0; i<methods.length; i++) {
  506.               Method m = methods[i];
  507.   

java/org/apache/tomcat/util/http/MimeHeaders.java:485: error: NULL_DEREFERENCE
  object `n1` last assigned on line 484 could be null and is dereferenced at line 485.
  483.           for(; pos< size; pos++ ) {
  484.               MessageBytes n1=headers.getName( pos );
  485. >             if( n1.equalsIgnoreCase( name )) {
  486.                   next=headers.getValue( pos );
  487.                   break;

java/org/apache/catalina/webresources/CachedResource.java:483: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 483.
  481.           @Override
  482.           public InputStream getInputStream() throws IOException {
  483. >             return getResource().getInputStream();
  484.           }
  485.   

java/org/apache/jasper/compiler/JspDocumentParser.java:626: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired by call to `new()` at line 539 is not released after line 626.
  624.                   @SuppressWarnings("unused")
  625.                   Node unused = new Node.TemplateText(
  626. >                         ttext.toString(), startMark, current);
  627.               }
  628.           }

java/org/apache/jasper/compiler/JspDocumentParser.java:623: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired to `ttext` by call to `new()` at line 539 is not released after line 623.
  621.                   ttext.write(lastCh);
  622.               }
  623. >             if (ttext.size() > 0) {
  624.                   @SuppressWarnings("unused")
  625.                   Node unused = new Node.TemplateText(

java/org/apache/catalina/webresources/CachedResource.java:489: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 489 is not released after line 489.
  487.           public Permission getPermission() throws IOException {
  488.               // Doesn't trigger a call to connect for file:// URLs
  489. >             return resourceURL.openConnection().getPermission();
  490.           }
  491.   

java/org/apache/catalina/webresources/CachedResource.java:489: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 489 is not released after line 489.
  487.           public Permission getPermission() throws IOException {
  488.               // Doesn't trigger a call to connect for file:// URLs
  489. >             return resourceURL.openConnection().getPermission();
  490.           }
  491.   

java/org/apache/juli/FileHandler.java:521: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired to `FileHandler.writer` by call to `new()` at line 515 is not released after line 521.
**Note**: potential exception at line 518
  519.           } catch (Exception e) {
  520.               reportError(null, e, ErrorManager.OPEN_FAILURE);
  521. >             writer = null;
  522.               if (fos != null) {
  523.                   try {

java/org/apache/catalina/webresources/CachedResource.java:494: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 494.
  492.           @Override
  493.           public long getLastModified() {
  494. >             return getResource().getLastModified();
  495.           }
  496.   

java/org/apache/catalina/webresources/CachedResource.java:499: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 499.
  497.           @Override
  498.           public long getContentLengthLong() {
  499. >             return getResource().getContentLength();
  500.           }
  501.   

java/org/apache/catalina/ssi/SSIServletExternalResolver.java:545: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.ssi.ByteArrayServletOutputStream` acquired to `basos` by call to `ByteArrayServletOutputStream()` at line 521 is not released after line 545.
**Note**: potential exception at line 522
  543.               }
  544.               return retVal;
  545. >         } catch (ServletException e) {
  546.               throw new IOException(sm.getString("ssiServletExternalResolver.noIncludeFile", originalPath), e);
  547.           }

java/org/apache/catalina/tribes/group/GroupChannel.java:529: error: NULL_DEREFERENCE
  object returned by `getRegistry(this)` could be null and is dereferenced at line 529.
  527.           }
  528.           if (oname != null) {
  529. >             JmxRegistry.getRegistry(this).unregisterJmx(oname);
  530.               oname = null;
  531.           }

java/org/apache/catalina/ha/tcp/SimpleTcpCluster.java:530: error: NULL_DEREFERENCE
  object returned by `getService(getContainer())` could be null and is dereferenced at line 530.
  528.               onameClusterDeployer = register(clusterDeployer, name.toString());
  529.           }
  530. >         channel.setUtilityExecutor(Container.getService(getContainer()).getServer().getUtilityExecutor());
  531.       }
  532.   

java/org/apache/catalina/core/NamingContextListener.java:534: error: NULL_DEREFERENCE
  object `NamingContextListener.compCtx` last assigned on line 533 could be null and is dereferenced at line 534.
  532.           } else {
  533.               compCtx = namingContext.createSubcontext("comp");
  534. >             envCtx = compCtx.createSubcontext("env");
  535.           }
  536.   

java/org/apache/jasper/compiler/Validator.java:534: error: NULL_DEREFERENCE
  object `version` last assigned on line 533 could be null and is dereferenced at line 534.
  532.               JspUtil.checkAttributes("Jsp:root", n, jspRootAttrs, err);
  533.               String version = n.getTextAttribute("version");
  534. >             if (!version.equals("1.2") && !version.equals("2.0") &&
  535.                       !version.equals("2.1") && !version.equals("2.2") &&
  536.                       !version.equals("2.3")) {

java/org/apache/catalina/mbeans/MBeanFactory.java:551: error: NULL_DEREFERENCE
  object returned by `engine.getObjectName()` could be null and is dereferenced at line 551.
  549.           ((Server) container).addService(service);
  550.   
  551. >         return engine.getObjectName().toString();
  552.       }
  553.   

java/org/apache/catalina/webresources/CachedResource.java:534: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 534.
  532.           @Override
  533.           public InputStream getInputStream() throws IOException {
  534. >             return getResource().getInputStream();
  535.           }
  536.   

java/org/apache/catalina/webresources/CachedResource.java:540: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 540 is not released after line 540.
  538.           public Permission getPermission() throws IOException {
  539.               // Doesn't trigger a call to connect for jar:// URLs
  540. >             return resourceURL.openConnection().getPermission();
  541.           }
  542.   

java/org/apache/catalina/webresources/CachedResource.java:540: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 540 is not released after line 540.
  538.           public Permission getPermission() throws IOException {
  539.               // Doesn't trigger a call to connect for jar:// URLs
  540. >             return resourceURL.openConnection().getPermission();
  541.           }
  542.   

java/org/apache/catalina/startup/Catalina.java:562: error: NULL_DEREFERENCE
  object `resource` last assigned on line 561 could be null and is dereferenced at line 562.
  560.   
  561.           try (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getServerXml()) {
  562. >             InputStream inputStream = resource.getInputStream();
  563.               InputSource inputSource = new InputSource(resource.getURI().toURL().toString());
  564.               inputSource.setByteStream(inputStream);

java/org/apache/catalina/mbeans/MBeanUtils.java:548: error: NULL_DEREFERENCE
  object `org.apache.catalina.mbeans.MBeanUtils.registry` last assigned on line 545 could be null and is dereferenced at line 548.
  546.               ClassLoader cl = MBeanUtils.class.getClassLoader();
  547.   
  548. >             registry.loadDescriptors("org.apache.catalina.mbeans",  cl);
  549.               registry.loadDescriptors("org.apache.catalina.authenticator", cl);
  550.               registry.loadDescriptors("org.apache.catalina.core", cl);

java/org/apache/catalina/webresources/CachedResource.java:545: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 545.
  543.           @Override
  544.           public long getLastModified() {
  545. >             return getResource().getLastModified();
  546.           }
  547.   

java/org/apache/catalina/startup/HostConfig.java:641: error: NULL_DEREFERENCE
  object `context` last assigned on line 560 could be null and is dereferenced at line 641.
  639.               // default to appBase dir + name
  640.               expandedDocBase = new File(host.getAppBaseFile(), cn.getBaseName());
  641. >             if (context.getDocBase() != null
  642.                       && !context.getDocBase().toLowerCase(Locale.ENGLISH).endsWith(".war")) {
  643.                   // first assume docBase is absolute

java/org/apache/catalina/ha/session/DeltaManager.java:553: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.tribes.io.ReplicationStream` acquired to `ois` by call to `getReplicationStream(...)` at line 550 is not released after line 553.
**Note**: potential exception at line 551
  551.           String sessionId = ois.readUTF();
  552.           ois.close();
  553. >         return sessionId;
  554.       }
  555.   

java/org/apache/catalina/webresources/CachedResource.java:550: error: NULL_DEREFERENCE
  object returned by `getResource(this)` could be null and is dereferenced at line 550.
  548.           @Override
  549.           public long getContentLengthLong() {
  550. >             return getResource().getContentLength();
  551.           }
  552.   

java/org/apache/catalina/tribes/io/XByteBuffer.java:562: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.tribes.io.ReplicationStream` acquired by call to `new()` at line 559 is not released after line 562.
  560.               message = stream.readObject();
  561.               instream.close();
  562. >             stream.close();
  563.           }
  564.           if ( message == null ) {

java/org/apache/catalina/tribes/io/XByteBuffer.java:569: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.tribes.io.ReplicationStream` acquired by call to `new()` at line 559 is not released after line 569.
**Note**: potential exception at line 560
  567.               return (Serializable) message;
  568.           else {
  569. >             throw new ClassCastException(sm.getString("xByteBuffer.wrong.class", message.getClass().getName()));
  570.           }
  571.       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:561: error: NULL_DEREFERENCE
  object returned by `getLocalMember(0)` could be null and is dereferenced at line 561.
  559.       public boolean isCoordinator() {
  560.           Member coord = getCoordinator();
  561. >         return coord != null && getLocalMember(false).equals(coord);
  562.       }
  563.   

java/org/apache/tomcat/util/http/fileupload/MultipartStream.java:572: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.util.http.fileupload.MultipartStream$ItemInputStream` acquired by call to `newInputStream()` at line 572 is not released after line 572.
  570.       public int readBodyData(OutputStream output)
  571.               throws MalformedStreamException, IOException {
  572. >         return (int) Streams.copy(newInputStream(), output, false); // N.B. Streams.copy closes the input stream
  573.       }
  574.   

java/org/apache/catalina/ha/session/DeltaManager.java:580: error: RESOURCE_LEAK
  resource of type `org.apache.catalina.tribes.io.ReplicationStream` acquired to `ois` by call to `getReplicationStream(...)` at line 575 is not released after line 580.
**Note**: potential exception at line 576
  578.               return session.getDeltaRequest();
  579.           } finally {
  580. >             session.unlock();
  581.           }
  582.       }

java/org/apache/catalina/mbeans/MBeanUtils.java:576: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 576.
  574.       public static synchronized MBeanServer createServer() {
  575.           if (mserver == null) {
  576. >             mserver = Registry.getRegistry(null, null).getMBeanServer();
  577.           }
  578.           return mserver;

java/org/apache/catalina/connector/Connector.java:576: error: NULL_DEREFERENCE
  object returned by `getProperty("localPort")` could be null and is dereferenced at line 576.
  574.        */
  575.       public int getLocalPort() {
  576. >         return ((Integer) getProperty("localPort")).intValue();
  577.       }
  578.   

java/org/apache/tomcat/util/modeler/Registry.java:614: error: NULL_DEREFERENCE
  object `managed` last assigned on line 611 could be null and is dereferenced at line 614.
  612.   
  613.               // The real mbean is created and registered
  614. >             DynamicMBean mbean = managed.createMBean(bean);
  615.   
  616.               if (getMBeanServer().isRegistered(oname)) {

java/org/apache/catalina/ant/jmx/JMXAccessorTask.java:632: error: INEFFICIENT_KEYSET_ITERATOR
  Accessing a value using a key that was retrieved from a `keySet` iterator. It is more efficient to use an iterator on the `entrySet` of the map, avoiding the extra `HashMap.get(key)` lookup.
  630.               for (Object key : data.keySet()) {
  631.                   for (Object key1 : ((List<?>) key)) {
  632. >                     CompositeData valuedata = data.get(new Object[] { key1 });
  633.                       Object value = valuedata.get("value");
  634.                       OpenType<?> type = valuedata.getCompositeType().getType(

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:626: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool` acquired by call to `GenericObjectPool(...)` at line 626 is not released after line 626.
**Note**: potential exception at line 626
  624.           if (abandonedConfig != null && (abandonedConfig.getRemoveAbandonedOnBorrow()
  625.                   || abandonedConfig.getRemoveAbandonedOnMaintenance())) {
  626. >             gop = new GenericObjectPool<>(factory, poolConfig, abandonedConfig);
  627.           } else {
  628.               gop = new GenericObjectPool<>(factory, poolConfig);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:628: error: RESOURCE_LEAK
  resource of type `org.apache.tomcat.dbcp.pool2.impl.GenericObjectPool` acquired by call to `GenericObjectPool(...)` at line 628 is not released after line 628.
**Note**: potential exception at line 628
  626.               gop = new GenericObjectPool<>(factory, poolConfig, abandonedConfig);
  627.           } else {
  628. >             gop = new GenericObjectPool<>(factory, poolConfig);
  629.           }
  630.           return gop;

java/org/apache/catalina/manager/HTMLManagerServlet.java:641: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 639 is not released after line 641.
  639.           PrintWriter printWriter = new PrintWriter(stringWriter);
  640.   
  641. >         super.reload(printWriter, cn, smClient);
  642.   
  643.           return stringWriter.toString();

java/org/apache/catalina/users/MemoryUserDatabase.java:685: error: RESOURCE_LEAK
  resource of type `java.net.HttpURLConnection` acquired by call to `openConnection()` at line 661 is not released after line 685.
  683.                   try {
  684.                       // Can't close a uConn directly. Have to do it like this.
  685. >                     uConn.getInputStream().close();
  686.                   } catch (IOException ioe) {
  687.                       log.warn(sm.getString("memoryUserDatabase.fileClose", pathname), ioe);

java/org/apache/catalina/users/MemoryUserDatabase.java:685: error: RESOURCE_LEAK
  resource of type `javax.net.ssl.HttpsURLConnection` acquired by call to `openConnection()` at line 661 is not released after line 685.
  683.                   try {
  684.                       // Can't close a uConn directly. Have to do it like this.
  685. >                     uConn.getInputStream().close();
  686.                   } catch (IOException ioe) {
  687.                       log.warn(sm.getString("memoryUserDatabase.fileClose", pathname), ioe);

java/org/apache/catalina/mbeans/MBeanFactory.java:669: error: NULL_DEREFERENCE
  object `loader.context` last assigned on line 658 could be null and is dereferenced by call to `createObjectName(...)` at line 669.
  667.           //ObjectName oname = loader.getObjectName();
  668.           ObjectName oname =
  669. >             MBeanUtils.createObjectName(pname.getDomain(), loader);
  670.           return oname.toString();
  671.   

java/org/apache/jasper/compiler/PageDataImpl.java:688: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired by call to `new()` at line 670 is not released after line 688.
  686.                   }
  687.               }
  688. >             return result.toString();
  689.           }
  690.   

java/org/apache/catalina/mbeans/MBeanFactory.java:706: error: NULL_DEREFERENCE
  object `port` last assigned on line 687 could be null and is dereferenced at line 706.
  704.                   // Don't combine this with outer if or we could get an NPE in
  705.                   // 'else if' below
  706. >                 if (connAddress == null && port.equals(connPort)) {
  707.                       service.removeConnector(conns[i]);
  708.                       conns[i].destroy();

java/org/apache/coyote/AbstractProtocol.java:700: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 700.
  698.               if (oname != null) {
  699.                   if (mserver == null) {
  700. >                     Registry.getRegistry(null, null).unregisterComponent(oname);
  701.                   } else {
  702.                       // Possibly registered with a different MBeanServer

java/org/apache/coyote/AbstractProtocol.java:713: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 713.
  711.   
  712.               if (rgOname != null) {
  713. >                 Registry.getRegistry(null, null).unregisterComponent(rgOname);
  714.               }
  715.           }

java/org/apache/catalina/startup/HostConfig.java:766: error: NULL_DEREFERENCE
  object returned by `cn.getBaseName()` could be null and is dereferenced by call to `validateContextPath(...)` at line 766.
  764.   
  765.                   // Check for WARs with /../ /./ or similar sequences in the name
  766. >                 if (!validateContextPath(appBase, cn.getBaseName())) {
  767.                       log.error(sm.getString(
  768.                               "hostConfig.illegalWarName", files[i]));

java/org/apache/catalina/servlets/CGIServlet.java:738: error: NULL_DEREFERENCE
  object `CGIServlet$CGIEnvironment.command` last assigned on line 705 could be null and is dereferenced at line 738.
  736.               if (valid) {
  737.                   workingDirectory = new File(command.substring(0,
  738. >                       command.lastIndexOf(File.separator)));
  739.               } else {
  740.                   workingDirectory = null;

java/org/apache/catalina/manager/HTMLManagerServlet.java:740: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 738 is not released after line 740.
  738.           PrintWriter printWriter = new PrintWriter(stringWriter);
  739.   
  740. >         super.findleaks(false, printWriter, smClient);
  741.   
  742.           String writerText = stringWriter.toString();

java/org/apache/jasper/compiler/SmapUtil.java:773: error: NULL_DEREFERENCE
  object `is` last assigned on line 770 could be null and is dereferenced at line 773.
  771.                   // Alternative approach would be to read the class file as per the
  772.                   // JLS. That would require duplicating a lot of BCEL functionality.
  773. >                 int b = is.read();
  774.                   while (b != -1) {
  775.                       if (b == 'S') {

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:797: error: NULL_DEREFERENCE
  object `securityConstraint` last assigned on line 796 could be null and is dereferenced at line 797.
  795.           SecurityConstraint securityConstraint =
  796.               (SecurityConstraint) digester.peek();
  797. >         securityConstraint.setAuthConstraint(true);
  798.           if (digester.getLogger().isDebugEnabled()) {
  799.               digester.getLogger()

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:821: error: NULL_DEREFERENCE
  object `webXml` last assigned on line 820 could be null and is dereferenced at line 821.
  819.           throws Exception {
  820.           WebXml webXml = (WebXml) digester.peek();
  821. >         webXml.setDistributable(true);
  822.           if (digester.getLogger().isDebugEnabled()) {
  823.               digester.getLogger().debug

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:844: error: NULL_DEREFERENCE
  object `webXml` last assigned on line 843 could be null and is dereferenced at line 844.
  842.           throws Exception {
  843.           WebXml webXml = (WebXml) digester.peek();
  844. >         webXml.setDenyUncoveredHttpMethods(true);
  845.           if (digester.getLogger().isDebugEnabled()) {
  846.               digester.getLogger().debug(webXml.getClass().getName() +

java/org/apache/catalina/startup/Catalina.java:852: error: NULL_DEREFERENCE
  object `top` last assigned on line 851 could be null and is dereferenced at line 852.
  850.   
  851.           Container top = (Container) digester.peek();
  852. >         top.setParentClassLoader(parentClassLoader);
  853.   
  854.       }

java/org/apache/catalina/core/StandardServer.java:852: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 852.
  850.               // Note: Hard-coded domain used since this object is per Server/JVM
  851.               ObjectName sname = new ObjectName("Catalina:type=StoreConfig");
  852. >             MBeanServer server = Registry.getRegistry(null, null).getMBeanServer();
  853.               if (server.isRegistered(sname)) {
  854.                   server.invoke(sname, "storeConfig", null, null);

java/org/apache/jasper/compiler/JspUtil.java:876: error: RESOURCE_LEAK
  resource of type `java.io.BufferedInputStream` acquired by call to `getInputStream(...)` at line 862 is not released after line 876.
  874.           }
  875.           try {
  876. >             reader = new InputStreamReader(in, encoding);
  877.           } catch (UnsupportedEncodingException ex) {
  878.               err.jspError("jsp.error.unsupported.encoding", encoding);

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:878: error: NULL_DEREFERENCE
  object `top` last assigned on line 870 could be null and is dereferenced at line 878.
  876.           Method m = null;
  877.           try {
  878. >             m = top.getClass().getMethod(method, paramClasses);
  879.           } catch (NoSuchMethodException e) {
  880.               digester.getLogger().error("Can't find method " + method + " in "

java/org/apache/catalina/core/ContainerBase.java:876: error: NULL_DEREFERENCE
  object returned by `getService(this)` could be null and is dereferenced at line 876.
  874.           } else {
  875.               // Delegate utility execution to the Service
  876. >             Server server = Container.getService(this).getServer();
  877.               server.setUtilityThreads(threads);
  878.               startStopExecutor = server.getUtilityExecutor();

java/org/apache/catalina/core/StandardServer.java:882: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 882.
  880.               // Note: Hard-coded domain used since this object is per Server/JVM
  881.               ObjectName sname = new ObjectName("Catalina:type=StoreConfig");
  882. >             MBeanServer server = Registry.getRegistry(null, null).getMBeanServer();
  883.               if (server.isRegistered(sname)) {
  884.                   server.invoke(sname, "store",

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:920: error: NULL_DEREFERENCE
  object `servletDef` last assigned on line 918 could be null and is dereferenced at line 920.
  918.           ServletDef servletDef = (ServletDef) digester.pop();
  919.           if (digester.getLogger().isDebugEnabled())
  920. >             digester.getLogger().debug("pop " + servletDef.getClass().getName());
  921.       }
  922.   

java/org/apache/jasper/runtime/JspRuntimeLibrary.java:955: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `ServletResponseWrapperInclude(...)` at line 955 is not released after line 955.
  953.           RequestDispatcher rd = request.getRequestDispatcher(resourcePath);
  954.   
  955. >         rd.include(request,
  956.                      new ServletResponseWrapperInclude(response, out));
  957.   

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:942: error: NULL_DEREFERENCE
  object `parameters` last assigned on line 940 could be null and is dereferenced at line 942.
  940.               Object parameters[] = (Object[]) digester.peekParams();
  941.               @SuppressWarnings("unchecked")
  942. >             ArrayList<String> params = (ArrayList<String>) parameters[paramIndex];
  943.               if (params == null) {
  944.                   params = new ArrayList<>();

java/org/apache/catalina/connector/Response.java:952: error: NULL_DEREFERENCE
  object returned by `headers.getName(i).toString()` could be null and is dereferenced at line 952.
  950.           int n = headers.size();
  951.           for (int i = 0; i < n; i++) {
  952. >             if (headers.getName(i).toString().equals(headername)) {
  953.                   if (headers.getValue(i).toString().startsWith(startsWith)) {
  954.                       headers.getValue(i).setString(header);

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:953: error: NULL_DEREFERENCE
  object `LinkedBlockingDeque.first` last assigned on line 954 could be null and is dereferenced at line 953.
  951.               final int n = Math.min(maxElements, count);
  952.               for (int i = 0; i < n; i++) {
  953. >                 c.add(first.item);   // In this order, in case add() throws.
  954.                   unlinkFirst();
  955.               }

java/org/apache/catalina/startup/Tomcat.java:963: error: NULL_DEREFERENCE
  object returned by `host.getParent()` could be null and is dereferenced at line 963.
  961.           loggerName.append(".[");
  962.           // Engine name
  963. >         loggerName.append(host.getParent().getName());
  964.           loggerName.append("].[");
  965.           // Host name

java/org/apache/tomcat/util/net/AbstractEndpoint.java:1001: error: RESOURCE_LEAK
  resource of type `java.io.OutputStreamWriter` acquired by call to `OutputStreamWriter(...)` at line 998 is not released after line 1001.
  999.                       sw.write("OPTIONS * HTTP/1.0\r\n" +
  1000.                               "User-Agent: Tomcat wakeup connection\r\n\r\n");
  1001. >                     sw.flush();
  1002.                   }
  1003.                   if (getLog().isDebugEnabled()) {

java/org/apache/tomcat/util/net/AbstractEndpoint.java:977: error: RESOURCE_LEAK
  resource of type `java.io.OutputStreamWriter` acquired to `sw` by call to `OutputStreamWriter(...)` at line 998 is not released after line 977.
**Note**: potential exception at line 999
  975.               unlockAddress = getUnlockAddress(localAddress);
  976.   
  977. >             try (java.net.Socket s = new java.net.Socket()) {
  978.                   int stmo = 2 * 1000;
  979.                   int utmo = 2 * 1000;

java/org/apache/jasper/compiler/Generator.java:987: error: NULL_DEREFERENCE
  object returned by `attr.getEL()` could be null and is dereferenced at line 987.
  985.               } else if (attr.isELInterpreterInput()) {
  986.                   v = elInterpreter.interpreterCall(ctxt, this.isTagFile, v,
  987. >                         expectedType, attr.getEL().getMapName());
  988.                   if (encode) {
  989.                       return "org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode("

java/org/apache/catalina/core/NamingContextListener.java:1018: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1018.
  1016.                   ObjectName on = createObjectName(resource);
  1017.                   actualResource = envCtx.lookup(resource.getName());
  1018. >                 Registry.getRegistry(null, null).registerComponent(actualResource, on, null);
  1019.                   objectNames.put(resource.getName(), on);
  1020.               } catch (Exception e) {

java/org/apache/catalina/core/StandardWrapper.java:1003: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1003.
  1001.               try {
  1002.                   jspMonitorON = new ObjectName(oname.toString());
  1003. >                 Registry.getRegistry(null, null).registerComponent(instance, jspMonitorON, null);
  1004.               } catch (Exception ex) {
  1005.                   log.warn(sm.getString("standardWrapper.jspMonitorError", instance));

java/org/apache/coyote/http11/Http11Processor.java:997: error: NULL_DEREFERENCE
  object returned by `AbstractProcessor.request.getAttribute("org.apache.tomcat.sendfile.end")` could be null and is dereferenced at line 997.
  995.                       org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();
  996.               long end = ((Long) request.getAttribute(
  997. >                     org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();
  998.               sendfileData = socketWrapper.createSendfileData(fileName, pos, end - pos);
  999.           }

java/org/apache/coyote/http11/Http11Processor.java:995: error: NULL_DEREFERENCE
  object returned by `AbstractProcessor.request.getAttribute("org.apache.tomcat.sendfile.start")` could be null and is dereferenced at line 995.
  993.               contentDelimitation = true;
  994.               long pos = ((Long) request.getAttribute(
  995. >                     org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();
  996.               long end = ((Long) request.getAttribute(
  997.                       org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();

java/org/apache/catalina/manager/HTMLManagerServlet.java:1022: error: NULL_DEREFERENCE
  object returned by `getSessionForNameAndId(cn,sessionId,smClient)` could be null and is dereferenced at line 1022.
  1020.               String sessionId = sessionIds[i];
  1021.               HttpSession session =
  1022. >                 getSessionForNameAndId(cn, sessionId, smClient).getSession();
  1023.               if (null == session) {
  1024.                   // Shouldn't happen, but let's play nice...

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1071: error: NULL_DEREFERENCE
  object returned by `request.getUserPrincipal()` could be null and is dereferenced at line 1071.
  1069.               if (log.isDebugEnabled()) {
  1070.                   log.debug("Reauthenticated cached principal '" +
  1071. >                         request.getUserPrincipal().getName() +
  1072.                           "' with auth type '" + request.getAuthType() + "'");
  1073.               }

java/org/apache/catalina/manager/HTMLManagerServlet.java:1057: error: NULL_DEREFERENCE
  object returned by `getSessionForNameAndId(cn,sessionId,smClient)` could be null and is dereferenced at line 1057.
  1055.               String attributeName, StringManager smClient) {
  1056.           HttpSession session =
  1057. >             getSessionForNameAndId(cn, sessionId, smClient).getSession();
  1058.           if (null == session) {
  1059.               // Shouldn't happen, but let's play nice...

java/org/apache/catalina/startup/Tomcat.java:1062: error: NULL_DEREFERENCE
  object `ctx` last assigned on line 1061 could be null and is dereferenced by call to `initWebappDefaults(...)` at line 1062.
  1060.       public void initWebappDefaults(String contextPath) {
  1061.           Container ctx = getHost().findChild(contextPath);
  1062. >         initWebappDefaults((Context) ctx);
  1063.       }
  1064.   

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1072: error: NULL_DEREFERENCE
  object `webxml` last assigned on line 1069 could be null and is dereferenced at line 1072.
  1070.           String value = attributes.getValue("metadata-complete");
  1071.           if ("true".equals(value)) {
  1072. >             webxml.setMetadataComplete(true);
  1073.           } else if ("false".equals(value)) {
  1074.               webxml.setMetadataComplete(false);

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1074: error: NULL_DEREFERENCE
  object `webxml` last assigned on line 1069 could be null and is dereferenced at line 1074.
  1072.               webxml.setMetadataComplete(true);
  1073.           } else if ("false".equals(value)) {
  1074. >             webxml.setMetadataComplete(false);
  1075.           }
  1076.           if (digester.getLogger().isDebugEnabled()) {

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1078: error: NULL_DEREFERENCE
  object `webxml` last assigned on line 1069 could be null and is dereferenced at line 1078.
  1076.           if (digester.getLogger().isDebugEnabled()) {
  1077.               digester.getLogger().debug
  1078. >                 (webxml.getClass().getName() + ".setMetadataComplete( " +
  1079.                           webxml.isMetadataComplete() + ")");
  1080.           }

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1100: error: NULL_DEREFERENCE
  object `webxml` last assigned on line 1099 could be null and is dereferenced at line 1100.
  1098.           throws Exception {
  1099.           WebXml webxml = (WebXml) digester.peek(digester.getCount() - 1);
  1100. >         webxml.setVersion(attributes.getValue("version"));
  1101.   
  1102.           if (digester.getLogger().isDebugEnabled()) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:1130: error: NULL_DEREFERENCE
  object `pooledObjectType` last assigned on line 1129 could be null and is dereferenced at line 1130.
  1128.               final Class<?> pooledObjectType =
  1129.                       PoolImplUtils.getFactoryType(factory.getClass());
  1130. >             result.append(pooledObjectType.getName());
  1131.               result.append('>');
  1132.               factoryType = result.toString();

java/org/apache/coyote/AbstractProtocol.java:1151: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1151.
  1149.                               getLog().debug("Unregister [" + rpName + "]");
  1150.                           }
  1151. >                         Registry.getRegistry(null, null).unregisterComponent(
  1152.                                   rpName);
  1153.                           rp.setRpName(null);

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1137: error: NULL_DEREFERENCE
  object returned by `Rule.digester.peek()` could be null and is dereferenced at line 1137.
  1135.               throws Exception {
  1136.           super.body(namespace, name, text);
  1137. >         ((WebXml) digester.peek()).setName(text);
  1138.       }
  1139.   }

java/org/apache/tomcat/util/net/AbstractEndpoint.java:1160: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1160.
  1158.               // Register endpoint (as ThreadPool - historical name)
  1159.               oname = new ObjectName(domain + ":type=ThreadPool,name=\"" + getName() + "\"");
  1160. >             Registry.getRegistry(null, null).registerComponent(this, oname, null);
  1161.   
  1162.               ObjectName socketPropertiesOname = new ObjectName(domain +

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1168: error: NULL_DEREFERENCE
  object `webXml` last assigned on line 1167 could be null and is dereferenced at line 1168.
  1166.               isAbsoluteOrderingSet = true;
  1167.               WebXml webXml = (WebXml) digester.peek();
  1168. >             webXml.createAbsoluteOrdering();
  1169.               if (digester.getLogger().isDebugEnabled()) {
  1170.                   digester.getLogger().debug(

java/org/apache/tomcat/util/net/AbstractEndpoint.java:1185: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1185.
  1183.               sslHostConfig.setObjectName(sslOname);
  1184.               try {
  1185. >                 Registry.getRegistry(null, null).registerComponent(sslHostConfig, sslOname, null);
  1186.               } catch (Exception e) {
  1187.                   getLog().warn(sm.getString("endpoint.jmxRegistrationFailed", sslOname), e);

java/org/apache/catalina/core/NamingContextListener.java:1211: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1211.
  1209.           ObjectName on = objectNames.get(name);
  1210.           if (on != null) {
  1211. >             Registry.getRegistry(null, null).unregisterComponent(on);
  1212.           }
  1213.   

java/org/apache/tomcat/util/net/AbstractEndpoint.java:1218: error: NULL_DEREFERENCE
  object `registry` last assigned on line 1217 could be null and is dereferenced at line 1218.
  1216.       private void unregisterJmx(SSLHostConfig sslHostConfig) {
  1217.           Registry registry = Registry.getRegistry(null, null);
  1218. >         registry.unregisterComponent(sslHostConfig.getObjectName());
  1219.           for (SSLHostConfigCertificate sslHostConfigCert : sslHostConfig.getCertificates()) {
  1220.               registry.unregisterComponent(sslHostConfigCert.getObjectName());

java/org/apache/catalina/core/StandardWrapper.java:1222: error: NULL_DEREFERENCE
  object returned by `getServletContext()` could be null and is dereferenced at line 1222.
  1220.       @Override
  1221.       public void unavailable(UnavailableException unavailable) {
  1222. >         getServletContext().log(sm.getString("standardWrapper.unavailable", getName()));
  1223.           if (unavailable == null)
  1224.               setAvailable(Long.MAX_VALUE);

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1237: error: NULL_DEREFERENCE
  object `contextHandler` last assigned on line 1236 could be null and is dereferenced at line 1237.
  1235.           }
  1236.           ContextHandler contextHandler = (ContextHandler)digester.peek();
  1237. >         contextHandler.addSoapHeaders(localpart,namespaceuri);
  1238.       }
  1239.   }

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1273: error: NULL_DEREFERENCE
  object `contextService` last assigned on line 1272 could be null and is dereferenced at line 1273.
  1271.           }
  1272.           ContextService contextService = (ContextService)digester.peek();
  1273. >         contextService.setServiceqnameLocalpart(localpart);
  1274.           contextService.setServiceqnameNamespaceURI(namespaceuri);
  1275.       }

java/org/apache/catalina/core/ContainerBase.java:1281: error: NULL_DEREFERENCE
  object returned by `getService(this)` could be null and is dereferenced at line 1281.
  1279.                   }
  1280.               }
  1281. >             backgroundProcessorFuture = Container.getService(this).getServer().getUtilityExecutor()
  1282.                       .scheduleWithFixedDelay(new ContainerBackgroundProcessor(),
  1283.                               backgroundProcessorDelay, backgroundProcessorDelay,

java/org/apache/tomcat/util/net/AbstractEndpoint.java:1282: error: NULL_DEREFERENCE
  object `registry` last assigned on line 1281 could be null and is dereferenced at line 1282.
  1280.           }
  1281.           Registry registry = Registry.getRegistry(null, null);
  1282. >         registry.unregisterComponent(oname);
  1283.           registry.unregisterComponent(socketProperties.getObjectName());
  1284.           for (SSLHostConfig sslHostConfig : findSslHostConfigs()) {

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1295: error: NULL_DEREFERENCE
  object `webXml` last assigned on line 1293 could be null and is dereferenced at line 1295.
  1293.           WebXml webXml = (WebXml) digester.peek(digester.getCount() - 1);
  1294.           // If we have a public ID, this is not a 2.4 or later webapp
  1295. >         boolean havePublicId = (webXml.getPublicId() != null);
  1296.           // havePublicId and isServlet24OrLater should be mutually exclusive
  1297.           if (havePublicId == isServlet24OrLater) {

java/org/apache/jasper/compiler/Parser.java:1350: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired by call to `new()` at line 1309 is not released after line 1350.
  1348.   
  1349.           @SuppressWarnings("unused")
  1350. >         Node unused = new Node.TemplateText(ttext.toString(), start, parent);
  1351.       }
  1352.   

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1327: error: NULL_DEREFERENCE
  object `resourceBase` last assigned on line 1326 could be null and is dereferenced at line 1327.
  1325.               throws Exception {
  1326.           ResourceBase resourceBase = (ResourceBase) digester.peek();
  1327. >         resourceBase.setProperty("mappedName", text.trim());
  1328.       }
  1329.   }

java/org/apache/jasper/compiler/Parser.java:1413: error: RESOURCE_LEAK
  resource of type `java.io.CharArrayWriter` acquired by call to `new()` at line 1365 is not released after line 1413.
  1411.               @SuppressWarnings("unused")
  1412.               Node unused =
  1413. >                     new Node.TemplateText(ttext.toString(), start, parent);
  1414.   
  1415.               if (!reader.hasMoreInput()) {

java/org/apache/tomcat/util/descriptor/web/WebRuleSet.java:1375: error: NULL_DEREFERENCE
  object `envEntry` last assigned on line 1374 could be null and is dereferenced at line 1375.
  1373.       public void begin(String namespace, String name, Attributes attributes) throws Exception {
  1374.           ContextEnvironment envEntry = (ContextEnvironment) digester.peek();
  1375. >         envEntry.setOverride(false);
  1376.           if (digester.getLogger().isDebugEnabled()) {
  1377.               digester.getLogger().debug(envEntry.getClass().getName() + ".setOverride(false)");

java/org/apache/catalina/connector/Response.java:1536: error: NULL_DEREFERENCE
  object returned by `hreq.getScheme()` could be null and is dereferenced at line 1536.
  1534.   
  1535.           // Does this URL match down to (and including) the context path?
  1536. >         if (!hreq.getScheme().equalsIgnoreCase(url.getProtocol())) {
  1537.               return false;
  1538.           }

java/org/apache/catalina/startup/HostConfig.java:1563: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1563.
  1561.                   (hostON.getDomain() + ":type=Deployer,host=" + host.getName());
  1562.               Registry.getRegistry(null, null).registerComponent
  1563. >                 (this, oname, this.getClass().getName());
  1564.           } catch (Exception e) {
  1565.               log.warn(sm.getString("hostConfig.jmx.register", oname), e);

java/org/apache/jasper/compiler/Generator.java:1569: error: NULL_DEREFERENCE
  object `name` last assigned on line 1568 could be null and is dereferenced at line 1569.
  1567.   
  1568.                       String name = n.getTextAttribute("name");
  1569. >                     if (name.equalsIgnoreCase("object"))
  1570.                           name = "java_object";
  1571.                       else if (name.equalsIgnoreCase("type"))

java/org/apache/catalina/startup/HostConfig.java:1591: error: NULL_DEREFERENCE
  object returned by `getRegistry(null,null)` could be null and is dereferenced at line 1591.
  1589.           if (oname != null) {
  1590.               try {
  1591. >                 Registry.getRegistry(null, null).unregisterComponent(oname);
  1592.               } catch (Exception e) {
  1593.                   log.warn(sm.getString("hostConfig.jmx.unregister", oname), e);

java/org/apache/catalina/core/StandardWrapper.java:1651: error: NULL_DEREFERENCE
  object `contextName` last assigned on line 1650 could be null and is dereferenced at line 1651.
  1649.   
  1650.           String contextName = getParent().getName();
  1651. >         if (!contextName.startsWith("/")) {
  1652.               keyProperties.append('/');
  1653.           }

java/org/apache/catalina/startup/HostConfig.java:1664: error: NULL_DEREFERENCE
  object returned by `current.getPath()` could be null and is dereferenced at line 1664.
  1662.               ContextName current = new ContextName(iter.next(), false);
  1663.   
  1664. >             if (current.getPath().equals(previous.getPath())) {
  1665.                   // Current and previous are same path - current will always
  1666.                   // be a later version

java/org/apache/tomcat/util/net/AprEndpoint.java:1904: error: NULL_DEREFERENCE
  object `state` last assigned on line 1902 could be null and is dereferenced by call to `remove(...)` at line 1904.
  1902.                                   SendfileData state = sendfileData.get(Long.valueOf(desc[n]));
  1903.                                   // Close socket and clear pool
  1904. >                                 remove(state);
  1905.                                   // Destroy file descriptor pool, which should close the file
  1906.                                   // Close the socket, as the response would be incomplete

java/org/apache/jasper/compiler/Validator.java:1791: error: NULL_DEREFERENCE
  object `tagInfo` last assigned on line 1785 could be null and is dereferenced at line 1791.
  1789.   
  1790.               @SuppressWarnings("null") // tagInfo can't be null here
  1791. >             ValidationMessage[] errors = tagInfo.validate(n.getTagData());
  1792.               if (errors != null && errors.length != 0) {
  1793.                   StringBuilder errMsg = new StringBuilder();

java/org/apache/catalina/servlets/DefaultServlet.java:1972: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 1807 is not released after line 1972.
  1970.           // Return an input stream to the underlying bytes
  1971.           writer.write(sb.toString());
  1972. >         writer.flush();
  1973.           return new ByteArrayInputStream(stream.toByteArray());
  1974.   

java/org/apache/el/parser/ELParser.java:1849: error: NULL_DEREFERENCE
  object `t0` last assigned on line 1835 could be null and is dereferenced at line 1849.
  1847.               jjtn000.setLocalName(t1.image);
  1848.           } else {
  1849. >             jjtn000.setLocalName(t0.image);
  1850.           }
  1851.         label_19:

java/org/apache/jasper/JspC.java:1869: error: RESOURCE_LEAK
  resource of type `java.io.FileOutputStream` acquired to `fos` by call to `FileOutputStream(...)` at line 1867 is not released after line 1869.
  1867.           FileOutputStream fos = new FileOutputStream(file);
  1868.           try {
  1869. >             return webxmlEncoding != null ? new OutputStreamWriter(fos,
  1870.                       webxmlEncoding) : new OutputStreamWriter(fos);
  1871.           } catch (IOException ex) {

java/org/apache/catalina/servlets/DefaultServlet.java:2016: error: RESOURCE_LEAK
  resource of type `java.io.PrintWriter` acquired by call to `new()` at line 2016 is not released after line 2016.
**Note**: potential exception at line 2016
  2014.                           reader = new InputStreamReader(is);
  2015.                       }
  2016. >                     copyRange(reader, new PrintWriter(buffer));
  2017.                   } catch (IOException e) {
  2018.                       log(sm.getString("defaultServlet.readerCloseFailed"), e);

java/org/apache/catalina/connector/Request.java:2092: error: NULL_DEREFERENCE
  object `uri` last assigned on line 2079 could be null and is dereferenced at line 2092.
  2090.           }
  2091.   
  2092. >         char[] uriChars = uri.toCharArray();
  2093.           // Need at least the number of slashes in the context path
  2094.           while (lastSlash > 0) {

java/org/apache/catalina/startup/ContextConfig.java:2123: error: RESOURCE_LEAK
  resource of type `java.io.DataInputStream` acquired by call to `ClassParser(...)` at line 2122 is not released after line 2123.
  2121.   
  2122.           ClassParser parser = new ClassParser(is);
  2123. >         JavaClass clazz = parser.parse();
  2124.           checkHandlesTypes(clazz, javaClassCache);
  2125.   

java/org/apache/jasper/compiler/Generator.java:2265: error: NULL_DEREFERENCE
  object returned by `n.getTextAttribute("fragment")` could be null and is dereferenced by call to `toGetterMethod(...)` at line 2265.
  2263.               // Invoke fragment, unless fragment is null
  2264.               out.printin("if (");
  2265. >             out.print(toGetterMethod(n.getTextAttribute("fragment")));
  2266.               out.println(" != null) {");
  2267.               out.pushIndent();

java/org/apache/catalina/startup/ContextConfig.java:2292: error: RESOURCE_LEAK
  resource of type `java.io.DataInputStream` acquired by call to `ClassParser(...)` at line 2291 is not released after line 2292.
  2290.                   }
  2291.                   ClassParser parser = new ClassParser(is);
  2292. >                 JavaClass clazz = parser.parse();
  2293.                   populateJavaClassCache(clazz.getClassName(), clazz, javaClassCache);
  2294.               } catch (ClassFormatException e) {

java/org/apache/catalina/core/StandardContext.java:2579: error: NULL_DEREFERENCE
  object returned by `getCatalinaBase()` could be null and is dereferenced at line 2579.
  2577.           if (!workDir.isAbsolute()) {
  2578.               try {
  2579. >                 workDir = new File(getCatalinaBase().getCanonicalFile(),
  2580.                           getWorkDir());
  2581.               } catch (IOException e) {

java/org/apache/tomcat/util/net/AprEndpoint.java:2661: error: NULL_DEREFERENCE
  object `buffer` last assigned on line 2640 could be null and is dereferenced at line 2661.
  2659.                                       } else {
  2660.                                           @SuppressWarnings("null") // Not possible
  2661. >                                         int remaining = buffer.remaining();
  2662.                                           write(block == BlockingMode.BLOCK, buffer);
  2663.                                           nBytes = remaining - buffer.remaining();

java/org/apache/jasper/compiler/Generator.java:2794: error: NULL_DEREFERENCE
  object `declaredVariables` last assigned on line 2786 could be null and is dereferenced at line 2794.
  2792.                       // If the scripting variable has been declared, skip codes
  2793.                       // for saving and restoring it.
  2794. >                     if (declaredVariables.contains(varInfos[i]))
  2795.                           continue;
  2796.                       String varName = varInfos[i].getVarName();

java/org/apache/jasper/compiler/Generator.java:2864: error: NULL_DEREFERENCE
  object `declaredVariables` last assigned on line 2856 could be null and is dereferenced at line 2864.
  2862.                       // If the scripting variable has been declared, skip codes
  2863.                       // for saving and restoring it.
  2864. >                     if (declaredVariables.contains(varInfos[i]))
  2865.                           continue;
  2866.                       String varName = varInfos[i].getVarName();

java/org/apache/catalina/core/StandardContext.java:3069: error: NULL_DEREFERENCE
  object returned by `getNamingResources()` could be null and is dereferenced at line 3069.
  3067.       @Deprecated
  3068.       public void addMessageDestinationRef(MessageDestinationRef mdr) {
  3069. >         getNamingResources().addMessageDestinationRef(mdr);
  3070.       }
  3071.   

java/org/apache/catalina/core/StandardContext.java:3474: error: NULL_DEREFERENCE
  object returned by `getNamingResources()` could be null and is dereferenced at line 3474.
  3472.       @Deprecated
  3473.       public MessageDestinationRef findMessageDestinationRef(String name) {
  3474. >         return getNamingResources().findMessageDestinationRef(name);
  3475.       }
  3476.   

java/org/apache/catalina/core/StandardContext.java:3488: error: NULL_DEREFERENCE
  object returned by `getNamingResources()` could be null and is dereferenced at line 3488.
  3486.       @Deprecated
  3487.       public MessageDestinationRef[] findMessageDestinationRefs() {
  3488. >         return getNamingResources().findMessageDestinationRefs();
  3489.       }
  3490.   

java/org/apache/catalina/core/StandardContext.java:3982: error: NULL_DEREFERENCE
  object returned by `getNamingResources()` could be null and is dereferenced at line 3982.
  3980.       @Deprecated
  3981.       public void removeMessageDestinationRef(String name) {
  3982. >         getNamingResources().removeMessageDestinationRef(name);
  3983.       }
  3984.   

java/org/apache/catalina/core/StandardContext.java:6048: error: NULL_DEREFERENCE
  object `temp` last assigned on line 6047 could be null and is dereferenced at line 6048.
  6046.   
  6047.               String temp = getBaseName();
  6048. >             if (temp.startsWith("/"))
  6049.                   temp = temp.substring(1);
  6050.               temp = temp.replace('/', '_');

java/org/apache/catalina/core/StandardWrapper.java:804: error: DEADLOCK
  Potential deadlock. `Servlet StandardWrapper.allocate()` (Trace 1) and `void StandardWrapper.unload()` (Trace 2) acquire locks `this` in `class org.apache.catalina.core.StandardWrapper` and `this.instancePool` in `class org.apache.catalina.core.StandardWrapper` in reverse orders. Additional report(s) on the same line were suppressed.
  802.           }
  803.   
  804. >         synchronized (instancePool) {
  805.               while (countAllocated.get() >= nInstances) {
  806.                   // Allocate a new instance if possible, or else wait

webapps/examples/WEB-INF/classes/websocket/echo/EchoAsyncAnnotation.java:79: error: STARVATION
  Method `void EchoAsyncAnnotation.echoBinaryMessage(byte[],Session,boolean)` runs on UI thread (because `void EchoAsyncAnnotation.echoBinaryMessage(byte[],Session,boolean)` is annotated `UiThread`), and may block; calls `Object Future.get()`.
  77.               // message to complete
  78.               try {
  79. >                 f.get();
  80.               } catch (InterruptedException | ExecutionException e) {
  81.                   // Let the container deal with it

webapps/examples/WEB-INF/classes/websocket/echo/EchoAsyncAnnotation.java:58: error: STARVATION
  Method `void EchoAsyncAnnotation.echoTextMessage(Session,String,boolean)` runs on UI thread (because `void EchoAsyncAnnotation.echoTextMessage(Session,String,boolean)` is annotated `UiThread`), and may block; calls `Object Future.get()`.
  56.               // message to complete
  57.               try {
  58. >                 f.get();
  59.               } catch (InterruptedException | ExecutionException e) {
  60.                   // Let the container deal with it

java/org/apache/catalina/core/StandardWrapperValve.java:135: error: DEADLOCK
  Potential deadlock. `void StandardWrapperValve.invoke(Request,Response)` (Trace 1) and `void StandardWrapper.unload()` (Trace 2) acquire locks `this` in `class org.apache.catalina.core.StandardWrapper` and `this.instancePool` in `class org.apache.catalina.core.StandardWrapper` in reverse orders. Additional report(s) on the same line were suppressed.
  133.           try {
  134.               if (!unavailable) {
  135. >                 servlet = wrapper.allocate();
  136.               }
  137.           } catch (UnavailableException e) {

java/org/apache/catalina/startup/HostConfig.java:157: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `HostConfig.<init>()` indirectly writes to field `digester.Digester.propertySourceSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  155.        * The <code>Digester</code> instance used to parse context descriptors.
  156.        */
  157. >     protected Digester digester = createDigester(contextClass);
  158.       private final Object digesterLock = new Object();
  159.   

java/org/apache/catalina/core/AsyncContextImpl.java:81: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AsyncContextImpl.<init>(Request)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  79.       public AsyncContextImpl(Request request) {
  80.           if (log.isDebugEnabled()) {
  81. >             logDebug("Constructor");
  82.           }
  83.           this.request = request;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:188: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractReplicatedMap.<init>(AbstractReplicatedMap$MapOwner,Channel,long,String,int,float,int,java.lang.ClassLoader[],boolean)` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  186.                                    boolean terminate) {
  187.           innerMap = new ConcurrentHashMap<>(initialCapacity, loadFactor, 15);
  188. >         init(owner, channel, mapContextName, timeout, channelSendOptions, cls, terminate);
  189.   
  190.       }

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:51: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Http2AsyncUpgradeHandler.<init>(Http2Protocol,Adapter,Request)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  49.       public Http2AsyncUpgradeHandler(Http2Protocol protocol, Adapter adapter,
  50.               Request coyoteRequest) {
  51. >         super(protocol, adapter, coyoteRequest);
  52.       }
  53.   

java/org/apache/coyote/http2/Http2UpgradeHandler.java:172: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Http2UpgradeHandler.<init>(Http2Protocol,Adapter,Request)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.               }
  171.               Integer key = Integer.valueOf(1);
  172. >             Stream stream = new Stream(key, this, coyoteRequest);
  173.               streams.put(key, stream);
  174.               maxActiveRemoteStreamId = 1;

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:135: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `OpenSSLContext.<init>(SSLHostConfigCertificate,List)` indirectly reads without synchronization from `this.sslHostConfig.enabledProtocols`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  133.               // SSL protocol
  134.               int value = SSL.SSL_PROTOCOL_NONE;
  135. >             for (String protocol : sslHostConfig.getEnabledProtocols()) {
  136.                   if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(protocol)) {
  137.                       // NO-OP. OpenSSL always supports SSLv2Hello

java/org/apache/coyote/AbstractProcessor.java:432: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractProcessor.action(ActionCode,Object)` indirectly reads without synchronization from `sc.socketWrapper`. Potentially races with write in method `AbstractProcessor.executeDispatches()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  430.                   setErrorState(ErrorState.CLOSE_NOW, (Throwable) param);
  431.               } else {
  432. >                 setErrorState(ErrorState.CLOSE_NOW, null);
  433.               }
  434.               break;

java/org/apache/coyote/AbstractProcessor.java:509: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.action(ActionCode,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  507.           case ASYNC_DISPATCH: {
  508.               if (asyncStateMachine.asyncDispatch()) {
  509. >                 processSocketEvent(SocketEvent.OPEN_READ, true);
  510.               }
  511.               break;

java/org/apache/catalina/session/StandardSession.java:918: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.activate()` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  916.               if (attribute instanceof HttpSessionActivationListener) {
  917.                   if (event == null)
  918. >                     event = new HttpSessionEvent(getSession());
  919.                   try {
  920.                       ((HttpSessionActivationListener)attribute)

java/org/apache/catalina/session/ManagerBase.java:646: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagerBase.add(Session)` indirectly reads without synchronization from container `this.sessions` via call to `size`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because this access may occur on a background thread.
  644.       public void add(Session session) {
  645.           sessions.put(session.getIdInternal(), session);
  646. >         int size = getActiveSessions();
  647.           if( size > maxActive ) {
  648.               synchronized(maxActiveUpdateLock) {

java/org/apache/catalina/session/ManagerBase.java:645: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagerBase.add(Session)` mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  643.       @Override
  644.       public void add(Session session) {
  645. >         sessions.put(session.getIdInternal(), session);
  646.           int size = getActiveSessions();
  647.           if( size > maxActive ) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1711: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` writes to field `data.pos` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1709.                           }
  1710.                       } else {
  1711. >                         data.pos += nw;
  1712.                           data.length -= nw;
  1713.                           if (data.length == 0) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1699: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` reads without synchronization from `data.fd`. Potentially races with write in method `AprEndpoint$Sendfile.add(...)`.
 Reporting because this access may occur on a background thread.
  1697.                   Socket.timeoutSet(data.socket, 0);
  1698.                   while (sendfileRunning) {
  1699. >                     long nw = Socket.sendfilen(data.socket, data.fd,
  1700.                                                  data.pos, data.length, 0);
  1701.                       if (nw < 0) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1704: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` writes to field `data.socket` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1702.                           if (!(-nw == Status.EAGAIN)) {
  1703.                               Pool.destroy(data.fdpool);
  1704. >                             data.socket = 0;
  1705.                               return SendfileState.ERROR;
  1706.                           } else {

java/org/apache/tomcat/util/net/AprEndpoint.java:1712: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` writes to field `data.length` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1710.                       } else {
  1711.                           data.pos += nw;
  1712. >                         data.length -= nw;
  1713.                           if (data.length == 0) {
  1714.                               // Entire file has been sent

java/org/apache/tomcat/util/net/AprEndpoint.java:1691: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` writes to field `data.fdpool` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1689.               // Initialize fd from data given
  1690.               try {
  1691. >                 data.fdpool = Socket.pool(data.socket);
  1692.                   data.fd = File.open
  1693.                       (data.fileName, File.APR_FOPEN_READ

java/org/apache/tomcat/util/net/AprEndpoint.java:1693: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState AprEndpoint$Sendfile.add(AprEndpoint$SendfileData)` writes to field `data.fd` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1691.                   data.fdpool = Socket.pool(data.socket);
  1692.                   data.fd = File.open
  1693. >                     (data.fileName, File.APR_FOPEN_READ
  1694.                        | File.APR_FOPEN_SENDFILE_ENABLED | File.APR_FOPEN_BINARY,
  1695.                        0, data.fdpool);

java/org/apache/tomcat/util/net/NioEndpoint.java:617: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.add(NioEndpoint$NioSocketWrapper,int)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  615.               addEvent(r);
  616.               if (close) {
  617. >                 processSocket(socketWrapper, SocketEvent.STOP, false);
  618.               }
  619.           }

java/org/apache/tomcat/util/net/NioEndpoint.java:613: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.add(NioEndpoint$NioSocketWrapper,int)` indirectly writes to field `r.interestOps` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  611.                   r = new PollerEvent(socketWrapper.getSocket(), interestOps);
  612.               } else {
  613. >                 r.reset(socketWrapper.getSocket(), interestOps);
  614.               }
  615.               addEvent(r);

java/org/apache/catalina/core/StandardContext.java:1340: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addApplicationEventListener(Object)` mutates container `this.applicationEventListenersList` via call to `add` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1338.        */
  1339.       public void addApplicationEventListener(Object listener) {
  1340. >         applicationEventListenersList.add(listener);
  1341.       }
  1342.   

java/org/apache/catalina/core/StandardContext.java:1374: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addApplicationLifecycleListener(Object)` writes to field `this.applicationLifecycleListenersObjects` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1372.                   applicationLifecycleListenersObjects, len + 1);
  1373.           newListeners[len] = listener;
  1374. >         applicationLifecycleListenersObjects = newListeners;
  1375.       }
  1376.   

java/org/apache/catalina/core/StandardContext.java:1370: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addApplicationLifecycleListener(Object)` reads without synchronization from `this.applicationLifecycleListenersObjects`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1368.        */
  1369.       public void addApplicationLifecycleListener(Object listener) {
  1370. >         int len = applicationLifecycleListenersObjects.length;
  1371.           Object[] newListeners = Arrays.copyOf(
  1372.                   applicationLifecycleListenersObjects, len + 1);

java/org/apache/catalina/core/StandardContext.java:2889: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addConstraint(SecurityConstraint)` indirectly reads without synchronization from `this.name`. Potentially races with write in method `StandardContext.setPath(...)`.
 Reporting because this access may occur on a background thread.
  2887.               for (int j = 0; j < patterns.length; j++) {
  2888.                   patterns[j] = adjustURLPattern(patterns[j]);
  2889. >                 if (!validateURLPattern(patterns[j]))
  2890.                       throw new IllegalArgumentException
  2891.                           (sm.getString

java/org/apache/catalina/core/StandardContext.java:2888: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addConstraint(SecurityConstraint)` writes to field `patterns.[_]` outside of synchronization.
 Reporting because this access may occur on a background thread.
  2886.               String patterns[] = collections[i].findPatterns();
  2887.               for (int j = 0; j < patterns.length; j++) {
  2888. >                 patterns[j] = adjustURLPattern(patterns[j]);
  2889.                   if (!validateURLPattern(patterns[j]))
  2890.                       throw new IllegalArgumentException

java/org/apache/catalina/deploy/NamingResourcesImpl.java:264: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addEnvironment(ContextEnvironment)` indirectly writes to field `resourceLink.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  262.                   if (global.findEnvironment(rl.getGlobal()) != null) {
  263.                       if (global.findEnvironment(rl.getGlobal()).getOverride()) {
  264. >                         removeResourceLink(environment.getName());
  265.                       } else {
  266.                           return;

java/org/apache/catalina/deploy/NamingResourcesImpl.java:291: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addEnvironment(ContextEnvironment)` indirectly writes to field `environment.type` outside of synchronization.
 Reporting because this access may occur on a background thread.
  289.           }
  290.   
  291. >         if (!checkResourceType(environment)) {
  292.               throw new IllegalArgumentException(sm.getString(
  293.                       "namingResources.resourceTypeFail", environment.getName(),

java/org/apache/catalina/deploy/NamingResourcesImpl.java:261: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.addEnvironment(ContextEnvironment)` indirectly reads without synchronization from `this.container`. Potentially races with write in method `NamingResourcesImpl.setContainer(...)`.
 Reporting because this access may occur on a background thread.
  259.               } else if (rl != null) {
  260.                   // Link. Need to look at the global resources
  261. >                 NamingResourcesImpl global = getServer().getGlobalNamingResources();
  262.                   if (global.findEnvironment(rl.getGlobal()) != null) {
  263.                       if (global.findEnvironment(rl.getGlobal()).getOverride()) {

java/org/apache/catalina/deploy/NamingResourcesImpl.java:308: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.addEnvironment(ContextEnvironment)` indirectly reads without synchronization from `environment.resources`. Potentially races with write in method `NamingResourcesImpl.addEnvironment(...)`.
 Reporting because this access may occur on a background thread.
  306.           if (resourceRequireExplicitRegistration) {
  307.               try {
  308. >                 MBeanUtils.createMBean(environment);
  309.               } catch (Exception e) {
  310.                   log.warn(sm.getString("namingResources.mbeanCreateFail",

java/org/apache/catalina/deploy/NamingResourcesImpl.java:255: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addEnvironment(ContextEnvironment)` indirectly writes to field `environment.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  253.               if (ce != null) {
  254.                   if (ce.getOverride()) {
  255. >                     removeEnvironment(environment.getName());
  256.                   } else {
  257.                       return;

java/org/apache/catalina/tribes/group/GroupChannel.java:181: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GroupChannel.addInterceptor(ChannelInterceptor)` indirectly writes to field `this.coordinator.previous` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  179.               interceptors.setNext(coordinator);
  180.               interceptors.setPrevious(null);
  181. >             coordinator.setPrevious(interceptors);
  182.           } else {
  183.               ChannelInterceptor last = interceptors;

java/org/apache/catalina/tribes/group/GroupChannel.java:177: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GroupChannel.addInterceptor(ChannelInterceptor)` reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  175.       @Override
  176.       public void addInterceptor(ChannelInterceptor interceptor) {
  177. >         if ( interceptors == null ) {
  178.               interceptors = interceptor;
  179.               interceptors.setNext(coordinator);

java/org/apache/catalina/tribes/group/GroupChannel.java:178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GroupChannel.addInterceptor(ChannelInterceptor)` writes to field `this.interceptors` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  176.       public void addInterceptor(ChannelInterceptor interceptor) {
  177.           if ( interceptors == null ) {
  178. >             interceptors = interceptor;
  179.               interceptors.setNext(coordinator);
  180.               interceptors.setPrevious(null);

java/org/apache/catalina/core/AsyncContextImpl.java:259: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.addListener(AsyncListener)` mutates container `this.listeners` via call to `add` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  257.           AsyncListenerWrapper wrapper = new AsyncListenerWrapper();
  258.           wrapper.setListener(listener);
  259. >         listeners.add(wrapper);
  260.       }
  261.   

java/org/apache/catalina/core/AsyncContextImpl.java:270: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.addListener(AsyncListener,ServletRequest,ServletResponse)` mutates container `this.listeners` via call to `add` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  268.           wrapper.setServletRequest(servletRequest);
  269.           wrapper.setServletResponse(servletResponse);
  270. >         listeners.add(wrapper);
  271.       }
  272.   

java/org/apache/catalina/core/StandardContext.java:3040: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addLocaleEncodingMappingParameter(String,String)` indirectly writes to field `this.charsetMapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3038.       @Override
  3039.       public void addLocaleEncodingMappingParameter(String locale, String encoding){
  3040. >         getCharsetMapper().addCharsetMappingFromDeploymentDescriptor(locale, encoding);
  3041.       }
  3042.   

java/org/apache/catalina/core/StandardWrapper.java:698: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardWrapper.addMapping(String)` reads without synchronization from `this.parent`. Potentially races with write in method `StandardWrapper.setParent(...)`.
 Reporting because this access may occur on a background thread.
  696.               mappingsLock.writeLock().unlock();
  697.           }
  698. >         if(parent.getState().equals(LifecycleState.STARTED))
  699.               fireContainerEvent(ADD_MAPPING_EVENT, mapping);
  700.   

java/org/apache/catalina/core/StandardContext.java:3069: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addMessageDestinationRef(MessageDestinationRef)` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3067.       @Deprecated
  3068.       public void addMessageDestinationRef(MessageDestinationRef mdr) {
  3069. >         getNamingResources().addMessageDestinationRef(mdr);
  3070.       }
  3071.   

java/org/apache/catalina/deploy/NamingResourcesImpl.java:363: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addMessageDestinationRef(MessageDestinationRef)` indirectly writes to field `mdr.type` outside of synchronization.
 Reporting because this access may occur on a background thread.
  361.               return;
  362.           } else {
  363. >             if (!checkResourceType(mdr)) {
  364.                   throw new IllegalArgumentException(sm.getString(
  365.                           "namingResources.resourceTypeFail", mdr.getName(),

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:1004: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.addObject()` indirectly mutates container `this.allObjects` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1002.                       "Cannot add objects without a factory.");
  1003.           }
  1004. >         final PooledObject<T> p = create();
  1005.           addIdleObject(p);
  1006.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1256: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.addObject(Object)` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1254.           register(key);
  1255.           try {
  1256. >             final PooledObject<T> p = create(key);
  1257.               addIdleObject(key, p);
  1258.           } finally {

java/org/apache/catalina/core/StandardContext.java:5961: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addPostConstructMethod(String,String)` mutates container `this.postConstructMethods` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5959.                       "standardContext.postconstruct.duplicate", clazz));
  5960.   
  5961. >         postConstructMethods.put(clazz, method);
  5962.           fireContainerEvent("addPostConstructMethod", clazz);
  5963.       }

java/org/apache/catalina/core/StandardContext.java:5957: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addPostConstructMethod(String,String)` reads without synchronization from container `this.postConstructMethods` via call to `get`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5955.               throw new IllegalArgumentException(
  5956.                       sm.getString("standardContext.postconstruct.required"));
  5957. >         if (postConstructMethods.get(clazz) != null)
  5958.               throw new IllegalArgumentException(sm.getString(
  5959.                       "standardContext.postconstruct.duplicate", clazz));

java/org/apache/catalina/core/StandardContext.java:5978: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addPreDestroyMethod(String,String)` reads without synchronization from container `this.preDestroyMethods` via call to `get`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5976.               throw new IllegalArgumentException(
  5977.                       sm.getString("standardContext.predestroy.required"));
  5978. >         if (preDestroyMethods.get(clazz) != null)
  5979.               throw new IllegalArgumentException(sm.getString(
  5980.                       "standardContext.predestroy.duplicate", clazz));

java/org/apache/catalina/core/StandardContext.java:5982: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addPreDestroyMethod(String,String)` mutates container `this.preDestroyMethods` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5980.                       "standardContext.predestroy.duplicate", clazz));
  5981.   
  5982. >         preDestroyMethods.put(clazz, method);
  5983.           fireContainerEvent("addPreDestroyMethod", clazz);
  5984.       }

java/org/apache/catalina/deploy/NamingResourcesImpl.java:403: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addResource(ContextResource)` indirectly writes to field `resource.type` outside of synchronization.
 Reporting because this access may occur on a background thread.
  401.               return;
  402.           } else {
  403. >             if (!checkResourceType(resource)) {
  404.                   throw new IllegalArgumentException(sm.getString(
  405.                           "namingResources.resourceTypeFail", resource.getName(),

java/org/apache/catalina/deploy/NamingResourcesImpl.java:420: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.addResource(ContextResource)` indirectly reads without synchronization from `resource.resources`. Potentially races with write in method `NamingResourcesImpl.addResource(...)`.
 Reporting because this access may occur on a background thread.
  418.           if (resourceRequireExplicitRegistration) {
  419.               try {
  420. >                 MBeanUtils.createMBean(resource);
  421.               } catch (Exception e) {
  422.                   log.warn(sm.getString("namingResources.mbeanCreateFail",

java/org/apache/catalina/deploy/NamingResourcesImpl.java:439: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.addResourceEnvRef(ContextResourceEnvRef)` indirectly writes to field `resource.type` outside of synchronization.
 Reporting because this access may occur on a background thread.
  437.               return;
  438.           } else {
  439. >             if (!checkResourceType(resource)) {
  440.                   throw new IllegalArgumentException(sm.getString(
  441.                           "namingResources.resourceTypeFail", resource.getName(),

java/org/apache/catalina/deploy/NamingResourcesImpl.java:479: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.addResourceLink(ContextResourceLink)` indirectly reads without synchronization from `resourceLink.resources`. Potentially races with write in method `NamingResourcesImpl.addResourceLink(...)`.
 Reporting because this access may occur on a background thread.
  477.           if (resourceRequireExplicitRegistration) {
  478.               try {
  479. >                 MBeanUtils.createMBean(resourceLink);
  480.               } catch (Exception e) {
  481.                   log.warn(sm.getString("namingResources.mbeanCreateFail",

java/org/apache/catalina/core/StandardContext.java:1262: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.addServletContainerInitializer(ServletContainerInitializer,Set)` mutates container `this.initializers` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1260.       public void addServletContainerInitializer(
  1261.               ServletContainerInitializer sci, Set<Class<?>> classes) {
  1262. >         initializers.put(sci, classes);
  1263.       }
  1264.   

java/org/apache/catalina/core/StandardContext.java:3176: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addServletMappingDecoded(String,String,boolean)` indirectly reads without synchronization from `this.name`. Potentially races with write in method `StandardContext.setPath(...)`.
 Reporting because this access may occur on a background thread.
  3174.                   (sm.getString("standardContext.servletMap.name", name));
  3175.           String adjustedPattern = adjustURLPattern(pattern);
  3176. >         if (!validateURLPattern(adjustedPattern))
  3177.               throw new IllegalArgumentException
  3178.                   (sm.getString("standardContext.servletMap.pattern", adjustedPattern));

java/org/apache/catalina/core/StandardContext.java:3175: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.addServletMappingDecoded(String,String,boolean)` indirectly reads without synchronization from `this.publicId`. Potentially races with write in method `StandardContext.setPublicId(...)`.
 Reporting because this access may occur on a background thread.
  3173.               throw new IllegalArgumentException
  3174.                   (sm.getString("standardContext.servletMap.name", name));
  3175. >         String adjustedPattern = adjustURLPattern(pattern);
  3176.           if (!validateURLPattern(adjustedPattern))
  3177.               throw new IllegalArgumentException

java/org/apache/catalina/core/StandardContext.java:5704: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Set StandardContext.addServletSecurity(ServletRegistration$Dynamic,ServletSecurityElement)` indirectly writes to field `results.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5702.               if (!foundConflict) {
  5703.                   SecurityConstraint[] newSecurityConstraints =
  5704. >                         SecurityConstraint.createConstraints(
  5705.                                   servletSecurityElement,
  5706.                                   urlPattern);

java/org/apache/catalina/core/StandardContext.java:5709: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Set StandardContext.addServletSecurity(ServletRegistration$Dynamic,ServletSecurityElement)` indirectly writes to field `patterns.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5707.                   for (SecurityConstraint securityConstraint :
  5708.                           newSecurityConstraints) {
  5709. >                     addConstraint(securityConstraint);
  5710.                   }
  5711.               }

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:106: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean MessageDispatchInterceptor.addToQueue(ChannelMessage,org.apache.catalina.tribes.Member[],InterceptorPayload)` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  104.               }
  105.           };
  106. >         executor.execute(r);
  107.           return true;
  108.       }

java/org/apache/jasper/compiler/JspRuntimeContext.java:196: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JspRuntimeContext.addWrapper(String,JspServletWrapper)` mutates container `this.jsps` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  194.        */
  195.       public void addWrapper(String jspUri, JspServletWrapper jsw) {
  196. >         jsps.put(jspUri, jsw);
  197.       }
  198.   

java/org/apache/catalina/core/StandardWrapper.java:743: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Servlet StandardWrapper.allocate()` indirectly reads without synchronization from `this.name`. Potentially races with write in method `StandardWrapper.setServletName(...)`.
 Reporting because this access may occur on a background thread.
  741.           // If we are currently unloading this servlet, throw an exception
  742.           if (unloading) {
  743. >             throw new ServletException(sm.getString("standardWrapper.unloading", getName()));
  744.           }
  745.   

java/org/apache/catalina/core/StandardWrapper.java:786: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Servlet StandardWrapper.allocate()` reads without synchronization from `this.instancePool`. Potentially races with write in method `StandardWrapper.getServletMethods()`.
 Reporting because this access may occur on a background thread.
  784.                       // Have to do this outside of the sync above to prevent a
  785.                       // possible deadlock
  786. >                     synchronized (instancePool) {
  787.                           instancePool.push(instance);
  788.                           nInstances++;

java/org/apache/catalina/startup/ContextConfig.java:705: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.antiLocking()` reads without synchronization from `this.antiLockingDocBase`. Potentially races with write in method `ContextConfig.beforeStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  703.                           deploymentCount++ + "-" + docBase);
  704.               }
  705. >             antiLockingDocBase = antiLockingDocBase.getAbsoluteFile();
  706.   
  707.               if (log.isDebugEnabled()) {

java/org/apache/catalina/startup/ContextConfig.java:682: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.antiLocking()` writes to field `this.originalDocBase` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  680.                   return;
  681.               }
  682. >             originalDocBase = docBase;
  683.   
  684.               File docBaseFile = new File(docBase);

java/org/apache/catalina/startup/ContextConfig.java:696: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.antiLocking()` reads without synchronization from `this.originalDocBase`. Potentially races with write in method `ContextConfig.beforeStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  694.               docBase = cn.getBaseName();
  695.   
  696. >             if (originalDocBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
  697.                   antiLockingDocBase = new File(
  698.                           System.getProperty("java.io.tmpdir"),

java/org/apache/catalina/startup/ContextConfig.java:698: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.antiLocking()` writes to field `startup.ContextConfig.deploymentCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  696.               if (originalDocBase.toLowerCase(Locale.ENGLISH).endsWith(".war")) {
  697.                   antiLockingDocBase = new File(
  698. >                         System.getProperty("java.io.tmpdir"),
  699.                           deploymentCount++ + "-" + docBase + ".war");
  700.               } else {

java/org/apache/catalina/startup/ContextConfig.java:334: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.applicationAnnotationsConfig()` indirectly writes to field `this.context.startupTime` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  332.           long t2=System.currentTimeMillis();
  333.           if (context instanceof StandardContext) {
  334. >             ((StandardContext) context).setStartupTime(t2-t1+
  335.                       ((StandardContext) context).getStartupTime());
  336.           }

java/org/apache/catalina/startup/ContextConfig.java:330: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.applicationAnnotationsConfig()` indirectly writes to field `resourceLink.resources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.           long t1=System.currentTimeMillis();
  329.   
  330. >         WebAnnotationSet.loadApplicationAnnotations(context);
  331.   
  332.           long t2=System.currentTimeMillis();

java/org/apache/catalina/startup/ContextConfig.java:335: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.applicationAnnotationsConfig()` indirectly reads without synchronization from `this.context.startupTime`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  333.           if (context instanceof StandardContext) {
  334.               ((StandardContext) context).setStartupTime(t2-t1+
  335. >                     ((StandardContext) context).getStartupTime());
  336.           }
  337.       }

java/org/apache/catalina/authenticator/AuthenticatorBase.java:891: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.associate(String,Session)` reads without synchronization from `this.sso`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  889.       protected void associate(String ssoId, Session session) {
  890.   
  891. >         if (sso == null) {
  892.               return;
  893.           }

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:113: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusterSingleSignOn.associate(String,Session)` indirectly reads without synchronization from `this.cache.channel`. Potentially races with write in method `ClusterSingleSignOn.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  111.           boolean result = super.associate(ssoId, session);
  112.           if (result) {
  113. >             ((ReplicatedMap<String,SingleSignOnEntry>) cache).replicate(ssoId, true);
  114.           }
  115.           return result;

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:111: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusterSingleSignOn.associate(String,Session)` indirectly reads without synchronization from `this.cache`. Potentially races with write in method `ClusterSingleSignOn.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  109.       @Override
  110.       protected boolean associate(String ssoId, Session session) {
  111. >         boolean result = super.associate(ssoId, session);
  112.           if (result) {
  113.               ((ReplicatedMap<String,SingleSignOnEntry>) cache).replicate(ssoId, true);

java/org/apache/catalina/realm/MemoryRealm.java:125: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Principal MemoryRealm.authenticate(String,String)` indirectly reads without synchronization from `this.credentialHandler`. Potentially races with write in method `MemoryRealm.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  123.               // User was not found in the database or the password was null
  124.               // Waste a bit of time as not to reveal that the user does not exist.
  125. >             getCredentialHandler().mutate(credentials);
  126.   
  127.               if (log.isDebugEnabled())

java/org/apache/catalina/authenticator/AuthenticatorBase.java:747: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AuthenticatorBase.authenticate(Request,HttpServletResponse)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  745.               }
  746.   
  747. >             boolean result = authenticateJaspic(request, response, jaspicState, true);
  748.   
  749.               secureResponseJspic(request, response, jaspicState);

java/org/apache/catalina/startup/ContextConfig.java:378: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.authenticatorConfig()` writes to field `this.ok` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  376.               if (authenticators == null) {
  377.                   log.error(sm.getString("contextConfig.authenticatorResources"));
  378. >                 ok = false;
  379.                   return;
  380.               }

java/org/apache/catalina/tribes/transport/RxTaskPool.java:93: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int RxTaskPool.available()` reads without synchronization from container `this.idle` via call to `size`. Potentially races with write in method `RxTaskPool.getRxTask()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  91.   
  92.       public int available() {
  93. >         return idle.size();
  94.       }
  95.   

java/org/apache/tomcat/util/net/Nio2Endpoint.java:1338: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean Nio2Endpoint$Nio2SocketWrapper.awaitReadComplete(long,TimeUnit)` reads with synchronization from `this.readNotify`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  1336.               synchronized (readCompletionHandler) {
  1337.                   try {
  1338. >                     if (readNotify) {
  1339.                           return true;
  1340.                       } else if (readPending.tryAcquire(timeout, unit)) {

java/org/apache/catalina/core/StandardContext.java:5566: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.backgroundProcess()` indirectly reads without synchronization from container `this.lifecycleListeners` via call to `iterator`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5564.               }
  5565.           }
  5566. >         super.backgroundProcess();
  5567.       }
  5568.   

java/org/apache/catalina/core/StandardContext.java:5556: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.backgroundProcess()` indirectly reads without synchronization from `this.instanceManager`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5554.               }
  5555.           }
  5556. >         InstanceManager instanceManager = getInstanceManager();
  5557.           if (instanceManager != null) {
  5558.               try {

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:574: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FarmWarDeployer.backgroundProcess()` indirectly mutates container `this.fileFactories` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  572.                   }
  573.               }
  574. >             removeInvalidFileFactories();
  575.           }
  576.   

java/org/apache/catalina/session/ManagerBase.java:558: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagerBase.backgroundProcess()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  556.           count = (count + 1) % processExpiresFrequency;
  557.           if (count == 0)
  558. >             processExpires();
  559.       }
  560.   

java/org/apache/catalina/users/MemoryUserDatabase.java:657: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.backgroundProcess()` indirectly reads without synchronization from `this.pathname`. Potentially races with write in method `MemoryUserDatabase.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  655.           }
  656.   
  657. >         URI uri = ConfigFileLoader.getSource().getURI(getPathname());
  658.           URLConnection uConn = null;
  659.           try {

java/org/apache/catalina/users/MemoryUserDatabase.java:653: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.backgroundProcess()` reads without synchronization from `this.watchSource`. Potentially races with write in method `MemoryUserDatabase.setWatchSource(...)`.
 Reporting because this access may occur on a background thread.
  651.       @Override
  652.       public void backgroundProcess() {
  653. >         if (!watchSource) {
  654.               return;
  655.           }

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:1081: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsWebSocketContainer.backgroundProcess()` reads without synchronization from container `this.sessions` via call to `keySet`. Potentially races with write in method `WsWebSocketContainer.unregisterSession(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1079.               backgroundProcessCount = 0;
  1080.   
  1081. >             for (WsSession wsSession : sessions.keySet()) {
  1082.                   wsSession.checkExpiration();
  1083.               }

java/org/apache/catalina/core/StandardContext.java:5730: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClassLoader StandardContext.bindThread()` indirectly mutates container `naming.ContextBindings.threadBindings` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5728.           if (isUseNaming()) {
  5729.               try {
  5730. >                 ContextBindings.bindThread(this, getNamingToken());
  5731.               } catch (NamingException e) {
  5732.                   // Silent catch, as this is a normal case during the early

java/org/apache/catalina/core/StandardContext.java:5728: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ClassLoader StandardContext.bindThread()` indirectly reads without synchronization from `this.useNaming`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5726.           ClassLoader oldContextClassLoader = bind(false, null);
  5727.   
  5728. >         if (isUseNaming()) {
  5729.               try {
  5730.                   ContextBindings.bindThread(this, getNamingToken());

java/org/apache/catalina/tribes/transport/ReceiverBase.java:234: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int ReceiverBase.bindUdp(DatagramSocket,int,int)` indirectly writes to field `this.bind` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  232.           while ( retries > 0 ) {
  233.               try {
  234. >                 addr = new InetSocketAddress(getBind(), portstart);
  235.                   socket.bind(addr);
  236.                   setUdpPort(portstart);

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:353: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object GenericObjectPool.borrowObject()` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  351.       @Override
  352.       public T borrowObject() throws Exception {
  353. >         return borrowObject(getMaxWaitMillis());
  354.       }
  355.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:412: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object GenericObjectPool.borrowObject(long)` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  410.                   (getNumIdle() < 2) &&
  411.                   (getNumActive() > getMaxTotal() - 3) ) {
  412. >             removeAbandoned(ac);
  413.           }
  414.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:411: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object GenericObjectPool.borrowObject(long)` indirectly reads without synchronization from container `this.allObjects` via call to `size`. Potentially races with write in method `GenericObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  409.           if (ac != null && ac.getRemoveAbandonedOnBorrow() &&
  410.                   (getNumIdle() < 2) &&
  411. >                 (getNumActive() > getMaxTotal() - 3) ) {
  412.               removeAbandoned(ac);
  413.           }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:269: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object GenericKeyedObjectPool.borrowObject(Object)` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  267.       @Override
  268.       public T borrowObject(final K key) throws Exception {
  269. >         return borrowObject(key, getMaxWaitMillis());
  270.       }
  271.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:346: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object GenericKeyedObjectPool.borrowObject(Object,long)` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  344.                   p = objectDeque.getIdleObjects().pollFirst();
  345.                   if (p == null) {
  346. >                     p = create(key);
  347.                       if (p != null) {
  348.                           create = true;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:374: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.breakdown()` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  372.           }
  373.           if (this.channel != null) {
  374. >             try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
  375.               //cleanup
  376.               this.channel.removeChannelListener(this);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:381: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.breakdown()` mutates container `this.mapMembers` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  379.           this.rpcChannel = null;
  380.           this.channel = null;
  381. >         this.mapMembers.clear();
  382.           innerMap.clear();
  383.           this.stateTransferred = false;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:383: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.breakdown()` writes to field `this.stateTransferred` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  381.           this.mapMembers.clear();
  382.           innerMap.clear();
  383. >         this.stateTransferred = false;
  384.           this.externalLoaders = null;
  385.       }

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:358: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.broadcast(int,boolean)` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  356.                   for (int i = 0; i < resp.length; i++) {
  357.                       mapMemberAdded(resp[i].getSource());
  358. >                     messageReceived(resp[i].getMessage(), resp[i].getSource());
  359.                   }
  360.               } else {

java/org/apache/coyote/http2/Stream.java:239: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Stream.cancelAllocationRequests()` indirectly reads without synchronization from `this.allocationManager.waitingFor`. Potentially races with write in method `Stream.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  237.   
  238.       final void cancelAllocationRequests() {
  239. >         allocationManager.notifyAny();
  240.       }
  241.   

java/org/apache/catalina/ha/session/DeltaManager.java:488: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.changeSessionId(Session)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  486.       @Override
  487.       public void changeSessionId(Session session) {
  488. >         changeSessionId(session, true);
  489.       }
  490.   

java/org/apache/catalina/session/ManagerBase.java:756: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagerBase.changeSessionId(Session)` indirectly reads without synchronization from container `this.sessions` via call to `containsKey`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  754.       @Override
  755.       public void changeSessionId(Session session) {
  756. >         rotateSessionId(session);
  757.       }
  758.   

java/org/apache/catalina/ha/session/DeltaManager.java:499: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.changeSessionId(Session,boolean)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  497.           String orgSessionID = session.getId();
  498.           super.changeSessionId(session);
  499. >         if (notify) sendChangeSessionId(session.getId(), orgSessionID);
  500.       }
  501.   

java/org/apache/catalina/ha/session/DeltaManager.java:498: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.changeSessionId(Session,boolean)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  496.       protected void changeSessionId(Session session, boolean notify) {
  497.           String orgSessionID = session.getId();
  498. >         super.changeSessionId(session);
  499.           if (notify) sendChangeSessionId(session.getId(), orgSessionID);
  500.       }

java/org/apache/catalina/ha/session/DeltaManager.java:493: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.changeSessionId(Session,String)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.       @Override
  492.       public void changeSessionId(Session session, String newId) {
  493. >         changeSessionId(session, newId, true);
  494.       }
  495.   

java/org/apache/catalina/ha/session/DeltaManager.java:505: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.changeSessionId(Session,String,boolean)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  503.           String orgSessionID = session.getId();
  504.           super.changeSessionId(session, newId);
  505. >         if (notify) sendChangeSessionId(session.getId(), orgSessionID);
  506.       }
  507.   

java/org/apache/catalina/startup/HostConfig.java:1608: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.check()` reads without synchronization from container `this.deployed` via call to `values`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1606.               // Check for resources modification to trigger redeployment
  1607.               DeployedApplication[] apps =
  1608. >                 deployed.values().toArray(new DeployedApplication[0]);
  1609.               for (int i = 0; i < apps.length; i++) {
  1610.                   if (!isServiced(apps[i].name))

java/org/apache/catalina/startup/HostConfig.java:1642: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.check(String)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1640.               checkResources(app, true);
  1641.           }
  1642. >         deployApps(name);
  1643.       }
  1644.   

java/org/apache/catalina/startup/HostConfig.java:1638: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.check(String)` reads without synchronization from container `this.deployed` via call to `get`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1636.        */
  1637.       public void check(String name) {
  1638. >         DeployedApplication app = deployed.get(name);
  1639.           if (app != null) {
  1640.               checkResources(app, true);

java/org/apache/jasper/compiler/JspRuntimeContext.java:376: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspRuntimeContext.checkCompile()` reads without synchronization from container `this.jsps` via call to `values`. Potentially races with write in method `JspRuntimeContext.push(...)`.
 Reporting because this access may occur on a background thread.
  374.           compileCheckInProgress = true;
  375.   
  376. >         Object [] wrappers = jsps.values().toArray();
  377.           for (int i = 0; i < wrappers.length; i++ ) {
  378.               JspServletWrapper jsw = (JspServletWrapper)wrappers[i];

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1006: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AuthenticatorBase.checkForCachedAuthentication(Request,HttpServletResponse,boolean)` indirectly reads without synchronization from `this.sso`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1004.                * prompt the user for a logon
  1005.                */
  1006. >             if (reauthenticateFromSSO(ssoId, request)) {
  1007.                   return true;
  1008.               }

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1032: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AuthenticatorBase.checkForCachedAuthentication(Request,HttpServletResponse,boolean)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1030.                       authType = getAuthMethod();
  1031.                   }
  1032. >                 register(request, response, authorized, authType, username, null);
  1033.                   return true;
  1034.               }

java/org/apache/catalina/startup/ContextConfig.java:2204: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` mutates container `this.initializerClassMap` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2202.                       if (classes == null) {
  2203.                           classes = new HashSet<>();
  2204. >                         initializerClassMap.put(sci, classes);
  2205.                       }
  2206.                       classes.add(clazz);

java/org/apache/catalina/startup/ContextConfig.java:2184: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` indirectly writes to field `entry.sciSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2182.               if (entry.getSciSet() == null) {
  2183.                   try {
  2184. >                     populateSCIsForCacheEntry(entry, javaClassCache);
  2185.                   } catch (StackOverflowError soe) {
  2186.                       throw new IllegalStateException(sm.getString(

java/org/apache/catalina/startup/ContextConfig.java:2178: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` reads without synchronization from `this.handlesTypesNonAnnotations`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2176.   
  2177.           Class<?> clazz = null;
  2178. >         if (handlesTypesNonAnnotations) {
  2179.               // This *might* be match for a HandlesType.
  2180.               populateJavaClassCache(className, javaClass, javaClassCache);

java/org/apache/catalina/startup/ContextConfig.java:2211: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` reads without synchronization from `this.handlesTypesAnnotations`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2209.           }
  2210.   
  2211. >         if (handlesTypesAnnotations) {
  2212.               AnnotationEntry[] annotationEntries = javaClass.getAnnotationEntries();
  2213.               if (annotationEntries != null) {

java/org/apache/catalina/startup/ContextConfig.java:2165: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` reads without synchronization from container `this.typeInitializerMap` via call to `size`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2163.   
  2164.           // Skip this if we can
  2165. >         if (typeInitializerMap.size() == 0) {
  2166.               return;
  2167.           }

java/org/apache/catalina/startup/ContextConfig.java:2201: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` reads without synchronization from container `this.initializerClassMap` via call to `get`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2199.   
  2200.                   for (ServletContainerInitializer sci : entry.getSciSet()) {
  2201. >                     Set<Class<?>> classes = initializerClassMap.get(sci);
  2202.                       if (classes == null) {
  2203.                           classes = new HashSet<>();

java/org/apache/catalina/startup/ContextConfig.java:2182: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.checkHandlesTypes(JavaClass,Map)` indirectly reads without synchronization from `entry.sciSet`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2180.               populateJavaClassCache(className, javaClass, javaClassCache);
  2181.               JavaClassCacheEntry entry = javaClassCache.get(className);
  2182. >             if (entry.getSciSet() == null) {
  2183.                   try {
  2184.                       populateSCIsForCacheEntry(entry, javaClassCache);

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:228: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.checkMembers(boolean)` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  226.       public void checkMembers(boolean checkAll) {
  227.           try {
  228. >             if (membership == null) setupMembership();
  229.               synchronized (membership) {
  230.                   if (!checkAll) performBasicCheck();

java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java:95: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagedConnection.checkOpen()` indirectly writes to field `this.isSharedConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.       protected void checkOpen() throws SQLException {
  94.           super.checkOpen();
  95. >         updateTransactionStatus();
  96.       }
  97.   

java/org/apache/catalina/tribes/group/GroupChannel.java:433: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GroupChannel.checkOptionFlags()` reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  431.       protected void checkOptionFlags() throws ChannelException {
  432.           StringBuilder conflicts = new StringBuilder();
  433. >         ChannelInterceptor first = interceptors;
  434.           while ( first != null ) {
  435.               int flag = first.getOptionFlag();

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:332: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.checkState(boolean)` indirectly writes to field `this.closed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  330.               throws IllegalArgumentException {
  331.           if (this.openForWrite != openForWrite) {
  332. >             cleanup();
  333.               if (openForWrite) {
  334.                   throw new IllegalArgumentException(sm.getString("fileMessageFactory.cannotWrite"));

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:340: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.checkState(boolean)` indirectly writes to field `this.in` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  338.           }
  339.           if (this.closed) {
  340. >             cleanup();
  341.               throw new IllegalArgumentException(sm.getString("fileMessageFactory.closed"));
  342.           }

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:339: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FileMessageFactory.checkState(boolean)` reads without synchronization from `this.closed`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  337.               }
  338.           }
  339. >         if (this.closed) {
  340.               cleanup();
  341.               throw new IllegalArgumentException(sm.getString("fileMessageFactory.closed"));

java/org/apache/catalina/startup/HostConfig.java:1650: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.checkUndeploy()` reads with synchronization from container `this.deployed` via call to `size`. Potentially races with unsynchronized write in method `HostConfig.deployDescriptor(...)`.
 Reporting because this access may occur on a background thread.
  1648.        */
  1649.       public synchronized void checkUndeploy() {
  1650. >         if (deployed.size() < 2) {
  1651.               return;
  1652.           }

java/org/apache/jasper/compiler/JspRuntimeContext.java:590: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspRuntimeContext.checkUnload()` reads without synchronization from container `this.jsps` via call to `values`. Potentially races with write in method `JspRuntimeContext.push(...)`.
 Reporting because this access may occur on a background thread.
  588.           if (jspIdleTimeout > 0) {
  589.               long unloadBefore = now - jspIdleTimeout;
  590. >             Object [] wrappers = jsps.values().toArray();
  591.               for (int i = 0; i < wrappers.length; i++ ) {
  592.                   JspServletWrapper jsw = (JspServletWrapper)wrappers[i];

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:311: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.out` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  309.               }
  310.           in = null;
  311. >         out = null;
  312.           size = 0;
  313.           closed = true;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:315: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.nrOfMessagesProcessed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  313.           closed = true;
  314.           data = null;
  315. >         nrOfMessagesProcessed = 0;
  316.           totalNrOfMessages = 0;
  317.           msgBuffer.clear();

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:318: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.lastMessageProcessed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.           totalNrOfMessages = 0;
  317.           msgBuffer.clear();
  318. >         lastMessageProcessed = null;
  319.       }
  320.   

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:312: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.size` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  310.           in = null;
  311.           out = null;
  312. >         size = 0;
  313.           closed = true;
  314.           data = null;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:310: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.in` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  308.               } catch (IOException ignore) {
  309.               }
  310. >         in = null;
  311.           out = null;
  312.           size = 0;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:313: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.closed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  311.           out = null;
  312.           size = 0;
  313. >         closed = true;
  314.           data = null;
  315.           nrOfMessagesProcessed = 0;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:314: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.data` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  312.           size = 0;
  313.           closed = true;
  314. >         data = null;
  315.           nrOfMessagesProcessed = 0;
  316.           totalNrOfMessages = 0;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:316: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` writes to field `this.totalNrOfMessages` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  314.           data = null;
  315.           nrOfMessagesProcessed = 0;
  316. >         totalNrOfMessages = 0;
  317.           msgBuffer.clear();
  318.           lastMessageProcessed = null;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:317: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FileMessageFactory.cleanup()` mutates container `this.msgBuffer` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  315.           nrOfMessagesProcessed = 0;
  316.           totalNrOfMessages = 0;
  317. >         msgBuffer.clear();
  318.           lastMessageProcessed = null;
  319.       }

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:305: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FileMessageFactory.cleanup()` reads without synchronization from `this.out`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  303.               } catch (IOException ignore) {
  304.               }
  305. >         if (out != null)
  306.               try {
  307.                   out.close();

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:300: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FileMessageFactory.cleanup()` reads without synchronization from `this.in`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  298.        */
  299.       public void cleanup() {
  300. >         if (in != null)
  301.               try {
  302.                   in.close();

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:103: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PerUserPoolDataSource.clear()` reads without synchronization from container `this.managers` via call to `values`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  101.        */
  102.       public void clear() {
  103. >         for (final PooledConnectionManager manager : managers.values()) {
  104.               try {
  105.                   getCPDSConnectionFactoryPool(manager).clear();

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:602: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.clear()` reads without synchronization from container `this.poolMap` via call to `keySet`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  600.       @Override
  601.       public void clear() {
  602. >         final Iterator<K> iter = poolMap.keySet().iterator();
  603.   
  604.           while (iter.hasNext()) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:659: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.clear()` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  657.           while (p != null) {
  658.               try {
  659. >                 destroy(p);
  660.               } catch (final Exception e) {
  661.                   swallowException(e);

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:731: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.clearOldest()` reads without synchronization from container `this.poolMap` via call to `entrySet`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  729.           final Map<PooledObject<T>, K> map = new TreeMap<>();
  730.   
  731. >         for (final Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
  732.               final K k = entry.getKey();
  733.               final ObjectDeque<T> deque = entry.getValue();

java/org/apache/catalina/loader/WebappClassLoaderBase.java:1619: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WebappClassLoaderBase.clearReferences()` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1617.           if (!JreCompat.isGraalAvailable()) {
  1618.               // De-register any remaining JDBC drivers
  1619. >             clearReferencesJdbc();
  1620.           }
  1621.   

java/org/apache/catalina/ha/session/BackupManager.java:255: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClusterManager BackupManager.cloneFromTemplate()` indirectly writes to field `this.sessionIdGenerator` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  253.       public ClusterManager cloneFromTemplate() {
  254.           BackupManager result = new BackupManager();
  255. >         clone(result);
  256.           result.mapSendOptions = mapSendOptions;
  257.           result.rpcTimeout = rpcTimeout;

java/org/apache/catalina/ha/session/DeltaManager.java:1440: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClusterManager DeltaManager.cloneFromTemplate()` indirectly writes to field `this.sessionIdGenerator` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1438.       public ClusterManager cloneFromTemplate() {
  1439.           DeltaManager result = new DeltaManager();
  1440. >         clone(result);
  1441.           result.expireSessionsOnShutdown = expireSessionsOnShutdown;
  1442.           result.notifySessionListenersOnReplication = notifySessionListenersOnReplication;

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:186: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BioReplicationTask.close()` writes to field `this.socket` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  184.           }
  185.           reader = null;
  186. >         socket = null;
  187.           super.close();
  188.       }

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.close()` reads without synchronization from `this.socket`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.       public void close() {
  171.           try {
  172. >             socket.close();
  173.           }catch (Exception e) {
  174.               if (log.isDebugEnabled()) {

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:179: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.close()` reads without synchronization from `this.reader`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  177.           }
  178.           try {
  179. >             reader.close();
  180.           }catch (Exception e) {
  181.               if (log.isDebugEnabled()) {

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:187: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BioReplicationTask.close()` indirectly writes to field `this.doRun` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  185.           reader = null;
  186.           socket = null;
  187. >         super.close();
  188.       }
  189.   }

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:185: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BioReplicationTask.close()` writes to field `this.reader` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  183.               }
  184.           }
  185. >         reader = null;
  186.           socket = null;
  187.           super.close();

java/org/apache/catalina/valves/JDBCAccessLogValve.java:614: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.close()` reads without synchronization from `this.conn`. Potentially races with write in method `JDBCAccessLogValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  612.   
  613.           // Do nothing if the database connection is already closed
  614. >         if (conn == null) {
  615.               return;
  616.           }

java/org/apache/catalina/valves/JDBCAccessLogValve.java:620: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.close()` reads without synchronization from `this.ps`. Potentially races with write in method `JDBCAccessLogValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  618.           // Close our prepared statements (if any)
  619.           try {
  620. >             ps.close();
  621.           } catch (Throwable f) {
  622.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/valves/JDBCAccessLogValve.java:624: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.close()` writes to field `this.ps` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  622.               ExceptionUtils.handleThrowable(f);
  623.           }
  624. >         this.ps = null;
  625.   
  626.   

java/org/apache/catalina/valves/JDBCAccessLogValve.java:634: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.close()` writes to field `this.conn` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  632.               container.getLogger().error(sm.getString("jdbcAccessLogValve.close"), e); // Just log it here
  633.           } finally {
  634. >            this.conn = null;
  635.           }
  636.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:120: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PerUserPoolDataSource.close()` reads without synchronization from container `this.managers` via call to `values`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  118.       @Override
  119.       public void close() {
  120. >         for (final PooledConnectionManager manager : managers.values()) {
  121.               try {
  122.                   getCPDSConnectionFactoryPool(manager).close();

java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java:73: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SharedPoolDataSource.close()` reads without synchronization from `this.pool`. Potentially races with write in method `SharedPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.       @Override
  72.       public void close() throws Exception {
  73. >         if (pool != null) {
  74.               pool.close();
  75.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:1040: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase$WsOutputStream.close()` indirectly writes to field `this.endpoint.fragmented` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1038.               }
  1039.   
  1040. >             doWrite(true);
  1041.           }
  1042.   

java/org/apache/catalina/realm/JDBCRealm.java:438: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCRealm.close(Connection)` reads without synchronization from `this.preparedRoles`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  436.   
  437.           try {
  438. >             preparedRoles.close();
  439.           } catch (Throwable f) {
  440.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/realm/JDBCRealm.java:430: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCRealm.close(Connection)` reads without synchronization from `this.preparedCredentials`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  428.           // Close our prepared statements (if any)
  429.           try {
  430. >             preparedCredentials.close();
  431.           } catch (Throwable f) {
  432.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/realm/JDBCRealm.java:434: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCRealm.close(Connection)` writes to field `this.preparedCredentials` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  432.               ExceptionUtils.handleThrowable(f);
  433.           }
  434. >         this.preparedCredentials = null;
  435.   
  436.   

java/org/apache/catalina/realm/JDBCRealm.java:451: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCRealm.close(Connection)` writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  449.               containerLog.warn(sm.getString("jdbcRealm.close"), e); // Just log it here
  450.           } finally {
  451. >            this.dbConnection = null;
  452.           }
  453.   

java/org/apache/catalina/realm/JDBCRealm.java:442: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCRealm.close(Connection)` writes to field `this.preparedRoles` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  440.               ExceptionUtils.handleThrowable(f);
  441.           }
  442. >         this.preparedRoles = null;
  443.   
  444.   

java/org/apache/catalina/session/JDBCStore.java:968: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.close(Connection)` writes to field `this.preparedSaveSql` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  966.               ExceptionUtils.handleThrowable(f);
  967.           }
  968. >         this.preparedSaveSql = null;
  969.   
  970.           try {

java/org/apache/catalina/session/JDBCStore.java:988: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.close(Connection)` writes to field `this.preparedLoadSql` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  986.               ExceptionUtils.handleThrowable(f);
  987.           }
  988. >         this.preparedLoadSql = null;
  989.   
  990.           // Commit if autoCommit is false

java/org/apache/catalina/session/JDBCStore.java:957: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.close(Connection)` reads without synchronization from `this.preparedSizeSql`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  955.           // Close our prepared statements (if any)
  956.           try {
  957. >             preparedSizeSql.close();
  958.           } catch (Throwable f) {
  959.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/session/JDBCStore.java:961: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.close(Connection)` writes to field `this.preparedSizeSql` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  959.               ExceptionUtils.handleThrowable(f);
  960.           }
  961. >         this.preparedSizeSql = null;
  962.   
  963.           try {

java/org/apache/catalina/session/JDBCStore.java:971: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.close(Connection)` reads without synchronization from `this.preparedClearSql`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  969.   
  970.           try {
  971. >             preparedClearSql.close();
  972.           } catch (Throwable f) {
  973.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/session/JDBCStore.java:964: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.close(Connection)` reads without synchronization from `this.preparedSaveSql`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  962.   
  963.           try {
  964. >             preparedSaveSql.close();
  965.           } catch (Throwable f) {
  966.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/session/JDBCStore.java:977: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.close(Connection)` reads without synchronization from `this.preparedRemoveSql`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  975.   
  976.           try {
  977. >             preparedRemoveSql.close();
  978.           } catch (Throwable f) {
  979.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/session/JDBCStore.java:984: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.close(Connection)` reads without synchronization from `this.preparedLoadSql`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  982.   
  983.           try {
  984. >             preparedLoadSql.close();
  985.           } catch (Throwable f) {
  986.               ExceptionUtils.handleThrowable(f);

java/org/apache/catalina/session/JDBCStore.java:981: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.close(Connection)` writes to field `this.preparedRemoveSql` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  979.               ExceptionUtils.handleThrowable(f);
  980.           }
  981. >         this.preparedRemoveSql = null;
  982.   
  983.           try {

java/org/apache/catalina/session/JDBCStore.java:1005: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.close(Connection)` writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1003.               manager.getContext().getLogger().error(sm.getString(getStoreName() + ".close", e.toString())); // Just log it here
  1004.           } finally {
  1005. >             this.dbConnection = null;
  1006.           }
  1007.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java:86: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void InstanceKeyDataSourceFactory.closeAll()` reads without synchronization from container `datasources.InstanceKeyDataSourceFactory.instanceMap` via call to `size`. Potentially races with write in method `InstanceKeyDataSourceFactory.registerNewInstance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  84.       public static void closeAll() throws Exception {
  85.           // Get iterator to loop over all instances of this data source.
  86. >         final List<Throwable> exceptionList = new ArrayList<>(instanceMap.size());
  87.           final Iterator<Entry<String, InstanceKeyDataSource>> instanceIterator = instanceMap.entrySet().iterator();
  88.           while (instanceIterator.hasNext()) {

java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java:103: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InstanceKeyDataSourceFactory.closeAll()` mutates container `datasources.InstanceKeyDataSourceFactory.instanceMap` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  101.               }
  102.           }
  103. >         instanceMap.clear();
  104.           if (!exceptionList.isEmpty()) {
  105.               throw new ListException("Could not close all InstanceKeyDataSource instances.", exceptionList);

java/org/apache/coyote/http2/Http2UpgradeHandler.java:564: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.closeConnection(Http2Exception)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2UpgradeHandler.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  562.               // error has already been logged.
  563.           }
  564. >         close();
  565.       }
  566.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:385: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CPDSConnectionFactory.closePool(String)` reads without synchronization from `this.pool`. Potentially races with write in method `CPDSConnectionFactory.setPool(...)`.
 Reporting because this access may occur on a background thread.
  383.           }
  384.           try {
  385. >             pool.close();
  386.           } catch (final Exception ex) {
  387.               throw new SQLException("Error closing connection pool", ex);

java/org/apache/catalina/core/AsyncContextImpl.java:89: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.complete()` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  87.       public void complete() {
  88.           if (log.isDebugEnabled()) {
  89. >             logDebug("complete   ");
  90.           }
  91.           check();

java/org/apache/tomcat/util/net/Nio2Endpoint.java:586: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Integer,ByteBuffer)` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper$2.completed(...)`.
 Reporting because this access may occur on a background thread.
  584.                       synchronized (readCompletionHandler) {
  585.                           if (nBytes.intValue() < 0) {
  586. >                             failed(new EOFException(), attachment);
  587.                           } else {
  588.                               if (readInterest && !Nio2Endpoint.isInline()) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:581: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Integer,ByteBuffer)` reads without synchronization from `this.this$0.readInterest`. Potentially races with write in method `Nio2Endpoint$Nio2SocketWrapper$2.completed(...)`.
 Reporting because this access may occur on a background thread.
  579.                   public void completed(Integer nBytes, ByteBuffer attachment) {
  580.                       if (log.isDebugEnabled()) {
  581. >                         log.debug("Socket: [" + Nio2SocketWrapper.this + "], Interest: [" + readInterest + "]");
  582.                       }
  583.                       readNotify = false;

java/org/apache/tomcat/util/net/Nio2Endpoint.java:599: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Integer,ByteBuffer)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  597.                       }
  598.                       if (readNotify) {
  599. >                         getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_READ, false);
  600.                       }
  601.                   }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:583: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Integer,ByteBuffer)` writes to field `this.this$0.readNotify` outside of synchronization.
 Reporting because this access may occur on a background thread.
  581.                           log.debug("Socket: [" + Nio2SocketWrapper.this + "], Interest: [" + readInterest + "]");
  582.                       }
  583. >                     readNotify = false;
  584.                       synchronized (readCompletionHandler) {
  585.                           if (nBytes.intValue() < 0) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:598: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Integer,ByteBuffer)` reads without synchronization from `this.this$0.readNotify`. Potentially races with write in method `Nio2Endpoint$Nio2SocketWrapper$2.completed(...)`.
 Reporting because this access may occur on a background thread.
  596.                           }
  597.                       }
  598. >                     if (readNotify) {
  599.                           getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_READ, false);
  600.                       }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:656: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.completed(Integer,ByteBuffer)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  654.                       }
  655.                       if (notify) {
  656. >                         if (!endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, true)) {
  657.                               close();
  658.                           }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:630: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.completed(Integer,ByteBuffer)` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper$3.completed(...)`.
 Reporting because this access may occur on a background thread.
  628.                       synchronized (writeCompletionHandler) {
  629.                           if (nBytes.intValue() < 0) {
  630. >                             failed(new EOFException(sm.getString("iob.failedwrite")), attachment);
  631.                           } else if (!nonBlockingWriteBuffer.isEmpty()) {
  632.                               // Continue writing data using a gathering write

java/org/apache/tomcat/util/net/Nio2Endpoint.java:626: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.completed(Integer,ByteBuffer)` writes to field `this.this$0.writeNotify` outside of synchronization.
 Reporting because this access may occur on a background thread.
  624.                   @Override
  625.                   public void completed(Integer nBytes, ByteBuffer attachment) {
  626. >                     writeNotify = false;
  627.                       boolean notify = false;
  628.                       synchronized (writeCompletionHandler) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:706: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.completed(Long,java.nio.ByteBuffer[])` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  704.                       }
  705.                       if (notify) {
  706. >                         if (!endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.OPEN_WRITE, true)) {
  707.                               close();
  708.                           }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:684: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.completed(Long,java.nio.ByteBuffer[])` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper$4.completed(...)`.
 Reporting because this access may occur on a background thread.
  682.                       synchronized (writeCompletionHandler) {
  683.                           if (nBytes.longValue() < 0) {
  684. >                             failed(new EOFException(sm.getString("iob.failedwrite")), attachment);
  685.                           } else if (!nonBlockingWriteBuffer.isEmpty() || arrayHasData(attachment)) {
  686.                               // Continue writing data using a gathering write

java/org/apache/tomcat/util/net/Nio2Endpoint.java:680: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.completed(Long,java.nio.ByteBuffer[])` writes to field `this.this$0.writeNotify` outside of synchronization.
 Reporting because this access may occur on a background thread.
  678.                   @Override
  679.                   public void completed(Long nBytes, ByteBuffer[] attachment) {
  680. >                     writeNotify = false;
  681.                       boolean notify = false;
  682.                       synchronized (writeCompletionHandler) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:577: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.completed(Object,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  575.               socketBufferHandler = channel.getBufHandler();
  576.   
  577. >             this.readCompletionHandler = new CompletionHandler<Integer, ByteBuffer>() {
  578.                   @Override
  579.                   public void completed(Integer nBytes, ByteBuffer attachment) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:623: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.completed(Object,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  621.               };
  622.   
  623. >             this.writeCompletionHandler = new CompletionHandler<Integer, ByteBuffer>() {
  624.                   @Override
  625.                   public void completed(Integer nBytes, ByteBuffer attachment) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:677: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.completed(Object,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  675.               };
  676.   
  677. >             gatheringWriteCompletionHandler = new CompletionHandler<Long, ByteBuffer[]>() {
  678.                   @Override
  679.                   public void completed(Long nBytes, ByteBuffer[] attachment) {

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:171: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session WsWebSocketContainer.connectToServer(Class,URI)` indirectly mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  169.           }
  170.   
  171. >         return connectToServer(pojo, path);
  172.       }
  173.   

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:189: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session WsWebSocketContainer.connectToServer(Class,ClientEndpointConfig,URI)` indirectly mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  187.           }
  188.   
  189. >         return connectToServer(endpoint, clientEndpointConfiguration, path);
  190.       }
  191.   

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:154: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session WsWebSocketContainer.connectToServer(Object,URI)` indirectly mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  152.                   preferredSubprotocols(Arrays.asList(annotation.subprotocols())).
  153.                   build();
  154. >         return connectToServer(ep, config, path);
  155.       }
  156.   

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:197: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session WsWebSocketContainer.connectToServer(Endpoint,ClientEndpointConfig,URI)` indirectly mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  195.               ClientEndpointConfig clientEndpointConfiguration, URI path)
  196.               throws DeploymentException {
  197. >         return connectToServerRecursive(endpoint, clientEndpointConfiguration, path, new HashSet<>());
  198.       }
  199.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CPDSConnectionFactory.connectionClosed(ConnectionEvent)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `CPDSConnectionFactory.makeObject()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  273.           // otherwise return the connection to the pool.
  274.           if (!validatingSet.contains(pc)) {
  275. >             final PooledConnectionAndInfo pci = pcMap.get(pc);
  276.               if (pci == null) {
  277.                   throw new IllegalStateException(NO_KEY_MESSAGE);

java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java:243: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void KeyedCPDSConnectionFactory.connectionClosed(ConnectionEvent)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `KeyedCPDSConnectionFactory.makeObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  241.           // otherwise return the connection to the pool.
  242.           if (!validatingSet.contains(pc)) {
  243. >             final PooledConnectionAndInfo pci = pcMap.get(pc);
  244.               if (pci == null) {
  245.                   throw new IllegalStateException(NO_KEY_MESSAGE);

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:306: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CPDSConnectionFactory.connectionErrorOccurred(ConnectionEvent)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `CPDSConnectionFactory.makeObject()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  304.           pc.removeConnectionEventListener(this);
  305.   
  306. >         final PooledConnectionAndInfo pci = pcMap.get(pc);
  307.           if (pci == null) {
  308.               throw new IllegalStateException(NO_KEY_MESSAGE);

java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java:273: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void KeyedCPDSConnectionFactory.connectionErrorOccurred(ConnectionEvent)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `KeyedCPDSConnectionFactory.makeObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  271.           pc.removeConnectionEventListener(this);
  272.   
  273. >         final PooledConnectionAndInfo info = pcMap.get(pc);
  274.           if (info == null) {
  275.               throw new IllegalStateException(NO_KEY_MESSAGE);

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java:269: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean MultiLockFairBlockingQueue.contains(Object)` reads without synchronization from container `this.items.[_]` via call to `contains`. Potentially races with write in method `MultiLockFairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  267.       public boolean contains(Object e) {
  268.           for (int idx=0; idx<LOCK_COUNT; idx++) {
  269. >             boolean result = items[idx].contains(e);
  270.               if (result) return result;
  271.           }

java/org/apache/catalina/startup/ContextConfig.java:466: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.contextConfig(Digester)` indirectly writes to field `this.ok` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  464.                       ConfigFileLoader.getSource().getResource(defaultContextXml)) {
  465.                   URL defaultContextUrl = contextXmlResource.getURI().toURL();
  466. >                 processContextConfig(digester, defaultContextUrl, contextXmlResource.getInputStream());
  467.               } catch (MalformedURLException e) {
  468.                   log.error(sm.getString("contextConfig.badUrl", defaultContextXml), e);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:472: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ConnectionFactory BasicDataSource.createConnectionFactory()` indirectly mutates container `connectionProperties` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  470.       protected ConnectionFactory createConnectionFactory() throws SQLException {
  471.           // Load the JDBC driver class
  472. >         return ConnectionFactoryFactory.createConnectionFactory(this, DriverFactory.createDriver(this));
  473.       }
  474.   

java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java:183: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ConnectionFactory BasicManagedDataSource.createConnectionFactory()` reads without synchronization from `this.xaDataSourceInstance`. Potentially races with write in method `BasicManagedDataSource.setXaDataSourceInstance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  181.   
  182.           // Create the XADataSource instance using the configured class name if it has not been set
  183. >         if (xaDataSourceInstance == null) {
  184.               Class<?> xaDataSourceClass = null;
  185.               try {

java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java:174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ConnectionFactory BasicManagedDataSource.createConnectionFactory()` reads without synchronization from `this.xaDataSource`. Potentially races with write in method `BasicManagedDataSource.setXADataSource(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  172.           // If xa data source is not specified a DriverConnectionFactory is created and wrapped with a
  173.           // LocalXAConnectionFactory
  174. >         if (xaDataSource == null) {
  175.               final ConnectionFactory connectionFactory = super.createConnectionFactory();
  176.               final XAConnectionFactory xaConnectionFactory = new LocalXAConnectionFactory(getTransactionManager(),

java/org/apache/tomcat/dbcp/dbcp2/managed/BasicManagedDataSource.java:193: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ConnectionFactory BasicManagedDataSource.createConnectionFactory()` writes to field `this.xaDataSourceInstance` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  191.   
  192.               try {
  193. >                 xaDataSourceInstance = (XADataSource) xaDataSourceClass.getConstructor().newInstance();
  194.               } catch (final Exception t) {
  195.                   final String message = "Cannot create XA data source of class '" + xaDataSource + "'";

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:489: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` indirectly reads without synchronization from `this.registeredJmxObjectName`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  487.           // Create an object pool to contain our active connections
  488.           final GenericObjectPoolConfig<PoolableConnection> config = new GenericObjectPoolConfig<>();
  489. >         updateJmxName(config);
  490.           // Disable JMX on the underlying pool if the DS is not registered:
  491.           config.setJmxEnabled(registeredJmxObjectName != null);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:504: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.lifo`. Potentially races with write in method `BasicDataSource.setLifo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  502.           gop.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
  503.           gop.setTestWhileIdle(testWhileIdle);
  504. >         gop.setLifo(lifo);
  505.           gop.setSwallowedExceptionListener(new SwallowedExceptionLogger(log, logExpiredConnections));
  506.           gop.setEvictionPolicyClassName(evictionPolicyClassName);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:502: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.softMinEvictableIdleTimeMillis`. Potentially races with write in method `BasicDataSource.setSoftMinEvictableIdleTimeMillis(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  500.           gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
  501.           gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
  502. >         gop.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
  503.           gop.setTestWhileIdle(testWhileIdle);
  504.           gop.setLifo(lifo);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:503: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.testWhileIdle`. Potentially races with write in method `BasicDataSource.setTestWhileIdle(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  501.           gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
  502.           gop.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
  503. >         gop.setTestWhileIdle(testWhileIdle);
  504.           gop.setLifo(lifo);
  505.           gop.setSwallowedExceptionListener(new SwallowedExceptionLogger(log, logExpiredConnections));

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:494: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.maxIdle`. Potentially races with write in method `BasicDataSource.setMaxIdle(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  492.           final GenericObjectPool<PoolableConnection> gop = createObjectPool(factory, config, abandonedConfig);
  493.           gop.setMaxTotal(maxTotal);
  494. >         gop.setMaxIdle(maxIdle);
  495.           gop.setMinIdle(minIdle);
  496.           gop.setMaxWaitMillis(maxWaitMillis);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:498: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.testOnBorrow`. Potentially races with write in method `BasicDataSource.setTestOnBorrow(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  496.           gop.setMaxWaitMillis(maxWaitMillis);
  497.           gop.setTestOnCreate(testOnCreate);
  498. >         gop.setTestOnBorrow(testOnBorrow);
  499.           gop.setTestOnReturn(testOnReturn);
  500.           gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:495: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.minIdle`. Potentially races with write in method `BasicDataSource.setMinIdle(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  493.           gop.setMaxTotal(maxTotal);
  494.           gop.setMaxIdle(maxIdle);
  495. >         gop.setMinIdle(minIdle);
  496.           gop.setMaxWaitMillis(maxWaitMillis);
  497.           gop.setTestOnCreate(testOnCreate);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:497: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.testOnCreate`. Potentially races with write in method `BasicDataSource.setTestOnCreate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  495.           gop.setMinIdle(minIdle);
  496.           gop.setMaxWaitMillis(maxWaitMillis);
  497. >         gop.setTestOnCreate(testOnCreate);
  498.           gop.setTestOnBorrow(testOnBorrow);
  499.           gop.setTestOnReturn(testOnReturn);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:500: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.numTestsPerEvictionRun`. Potentially races with write in method `BasicDataSource.setNumTestsPerEvictionRun(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  498.           gop.setTestOnBorrow(testOnBorrow);
  499.           gop.setTestOnReturn(testOnReturn);
  500. >         gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
  501.           gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
  502.           gop.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:496: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.maxWaitMillis`. Potentially races with write in method `BasicDataSource.setMaxWaitMillis(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  494.           gop.setMaxIdle(maxIdle);
  495.           gop.setMinIdle(minIdle);
  496. >         gop.setMaxWaitMillis(maxWaitMillis);
  497.           gop.setTestOnCreate(testOnCreate);
  498.           gop.setTestOnBorrow(testOnBorrow);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:493: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.maxTotal`. Potentially races with write in method `BasicDataSource.setMaxTotal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.           config.setJmxEnabled(registeredJmxObjectName != null);
  492.           final GenericObjectPool<PoolableConnection> gop = createObjectPool(factory, config, abandonedConfig);
  493. >         gop.setMaxTotal(maxTotal);
  494.           gop.setMaxIdle(maxIdle);
  495.           gop.setMinIdle(minIdle);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:499: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.testOnReturn`. Potentially races with write in method `BasicDataSource.setTestOnReturn(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  497.           gop.setTestOnCreate(testOnCreate);
  498.           gop.setTestOnBorrow(testOnBorrow);
  499. >         gop.setTestOnReturn(testOnReturn);
  500.           gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
  501.           gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:506: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.evictionPolicyClassName`. Potentially races with write in method `BasicDataSource.setEvictionPolicyClassName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  504.           gop.setLifo(lifo);
  505.           gop.setSwallowedExceptionListener(new SwallowedExceptionLogger(log, logExpiredConnections));
  506. >         gop.setEvictionPolicyClassName(evictionPolicyClassName);
  507.           factory.setPool(gop);
  508.           connectionPool = gop;

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:501: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.createConnectionPool(PoolableConnectionFactory)` reads without synchronization from `this.minEvictableIdleTimeMillis`. Potentially races with write in method `BasicDataSource.setMinEvictableIdleTimeMillis(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  499.           gop.setTestOnReturn(testOnReturn);
  500.           gop.setNumTestsPerEvictionRun(numTestsPerEvictionRun);
  501. >         gop.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
  502.           gop.setSoftMinEvictableIdleTimeMillis(softMinEvictableIdleTimeMillis);
  503.           gop.setTestWhileIdle(testWhileIdle);

java/org/apache/catalina/startup/ContextConfig.java:425: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Digester ContextConfig.createContextDigester()` indirectly writes to field `digester.Digester.propertySourceSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  423.        */
  424.       protected Digester createContextDigester() {
  425. >         Digester digester = new Digester();
  426.           digester.setValidating(false);
  427.           digester.setRulesValidation(true);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:520: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DataSource BasicDataSource.createDataSource()` reads without synchronization from `this.closed`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because this access may occur on a background thread.
  518.        */
  519.       protected DataSource createDataSource() throws SQLException {
  520. >         if (closed) {
  521.               throw new SQLException("Data source is closed");
  522.           }

java/org/apache/catalina/startup/HostConfig.java:383: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Digester HostConfig.createDigester(String)` indirectly writes to field `digester.Digester.propertySourceSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  381.        */
  382.       protected static Digester createDigester(String contextClassName) {
  383. >         Digester digester = new Digester();
  384.           digester.setValidating(false);
  385.           // Add object creation rule

java/org/apache/catalina/core/StandardContext.java:5253: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `InstanceManager StandardContext.createInstanceManager()` indirectly mutates container `injections` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5251.               context = getNamingContextListener().getEnvContext();
  5252.           }
  5253. >         Map<String, Map<String, String>> injectionMap = buildInjectionMap(
  5254.                   getIgnoreAnnotations() ? new NamingResourcesImpl(): getNamingResources());
  5255.          return new DefaultInstanceManager(context, injectionMap,

java/org/apache/catalina/core/StandardContext.java:5254: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `InstanceManager StandardContext.createInstanceManager()` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5252.           }
  5253.           Map<String, Map<String, String>> injectionMap = buildInjectionMap(
  5254. >                 getIgnoreAnnotations() ? new NamingResourcesImpl(): getNamingResources());
  5255.          return new DefaultInstanceManager(context, injectionMap,
  5256.                  this, this.getClass().getClassLoader());

java/org/apache/catalina/core/StandardContext.java:5250: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InstanceManager StandardContext.createInstanceManager()` indirectly reads without synchronization from `this.namingContextListener`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5248.       public InstanceManager createInstanceManager() {
  5249.           javax.naming.Context context = null;
  5250. >         if (isUseNaming() && getNamingContextListener() != null) {
  5251.               context = getNamingContextListener().getEnvContext();
  5252.           }

java/org/apache/catalina/core/AsyncContextImpl.java:280: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AsyncListener AsyncContextImpl.createListener(Class)` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  278.           T listener = null;
  279.           try {
  280. >              listener = (T) context.getInstanceManager().newInstance(
  281.                        clazz.getName(), clazz.getClassLoader());
  282.           } catch (ReflectiveOperationException | NamingException e) {

java/org/apache/tomcat/util/modeler/ManagedBean.java:296: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean ManagedBean.createMBean(Object)` indirectly reads without synchronization from `this.className`. Potentially races with write in method `ManagedBean.setClassName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  294.   
  295.           // Load the ModelMBean implementation class
  296. >         if(getClassName().equals(BASE_MBEAN)) {
  297.               // Skip introspection
  298.               mbean = new BaseModelMBean();

java/org/apache/catalina/mbeans/MBeanUtils.java:222: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(Group)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  220.           String domain = managed.getDomain();
  221.           if (domain == null)
  222. >             domain = mserver.getDefaultDomain();
  223.           DynamicMBean mbean = managed.createMBean(group);
  224.           ObjectName oname = createObjectName(domain, group);

java/org/apache/catalina/mbeans/MBeanUtils.java:215: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(Group)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.   
  214.           String mname = createManagedName(group);
  215. >         ManagedBean managed = registry.findManagedBean(mname);
  216.           if (managed == null) {
  217.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:246: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(Role)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  244.   
  245.           String mname = createManagedName(role);
  246. >         ManagedBean managed = registry.findManagedBean(mname);
  247.           if (managed == null) {
  248.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:253: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(Role)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  251.           String domain = managed.getDomain();
  252.           if (domain == null)
  253. >             domain = mserver.getDefaultDomain();
  254.           DynamicMBean mbean = managed.createMBean(role);
  255.           ObjectName oname = createObjectName(domain, role);

java/org/apache/catalina/mbeans/MBeanUtils.java:284: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(User)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  282.           String domain = managed.getDomain();
  283.           if (domain == null)
  284. >             domain = mserver.getDefaultDomain();
  285.           DynamicMBean mbean = managed.createMBean(user);
  286.           ObjectName oname = createObjectName(domain, user);

java/org/apache/catalina/mbeans/MBeanUtils.java:277: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(User)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  275.   
  276.           String mname = createManagedName(user);
  277. >         ManagedBean managed = registry.findManagedBean(mname);
  278.           if (managed == null) {
  279.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:308: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(UserDatabase)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  306.   
  307.           String mname = createManagedName(userDatabase);
  308. >         ManagedBean managed = registry.findManagedBean(mname);
  309.           if (managed == null) {
  310.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:315: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(UserDatabase)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  313.           String domain = managed.getDomain();
  314.           if (domain == null)
  315. >             domain = mserver.getDefaultDomain();
  316.           DynamicMBean mbean = managed.createMBean(userDatabase);
  317.           ObjectName oname = createObjectName(domain, userDatabase);

java/org/apache/catalina/mbeans/MBeanUtils.java:129: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextEnvironment)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  127.           String domain = managed.getDomain();
  128.           if (domain == null)
  129. >             domain = mserver.getDefaultDomain();
  130.           DynamicMBean mbean = managed.createMBean(environment);
  131.           ObjectName oname = createObjectName(domain, environment);

java/org/apache/catalina/mbeans/MBeanUtils.java:122: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextEnvironment)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  120.   
  121.           String mname = createManagedName(environment);
  122. >         ManagedBean managed = registry.findManagedBean(mname);
  123.           if (managed == null) {
  124.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:153: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextResource)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  151.   
  152.           String mname = createManagedName(resource);
  153. >         ManagedBean managed = registry.findManagedBean(mname);
  154.           if (managed == null) {
  155.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:160: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextResource)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  158.           String domain = managed.getDomain();
  159.           if (domain == null)
  160. >             domain = mserver.getDefaultDomain();
  161.           DynamicMBean mbean = managed.createMBean(resource);
  162.           ObjectName oname = createObjectName(domain, resource);

java/org/apache/catalina/mbeans/MBeanUtils.java:184: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextResourceLink)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  182.   
  183.           String mname = createManagedName(resourceLink);
  184. >         ManagedBean managed = registry.findManagedBean(mname);
  185.           if (managed == null) {
  186.               Exception e = new Exception(sm.getString("mBeanUtils.noManagedBean", mname));

java/org/apache/catalina/mbeans/MBeanUtils.java:191: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `DynamicMBean MBeanUtils.createMBean(ContextResourceLink)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  189.           String domain = managed.getDomain();
  190.           if (domain == null)
  191. >             domain = mserver.getDefaultDomain();
  192.           DynamicMBean mbean = managed.createMBean(resourceLink);
  193.           ObjectName oname = createObjectName(domain, resourceLink);

java/org/apache/tomcat/util/modeler/NotificationInfo.java:125: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MBeanNotificationInfo NotificationInfo.createNotificationInfo()` writes to field `this.info` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  123.           // Create and return a new information object
  124.           info = new MBeanNotificationInfo
  125. >             (getNotifTypes(), getName(), getDescription());
  126.           //Descriptor descriptor = info.getDescriptor();
  127.           //addFields(descriptor);

java/org/apache/tomcat/util/modeler/NotificationInfo.java:120: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MBeanNotificationInfo NotificationInfo.createNotificationInfo()` reads without synchronization from `this.info`. Potentially races with write in method `NotificationInfo.addNotifType(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  118.   
  119.           // Return our cached information (if any)
  120. >         if (info != null)
  121.               return info;
  122.   

java/org/apache/tomcat/util/modeler/OperationInfo.java:147: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MBeanOperationInfo OperationInfo.createOperationInfo()` reads without synchronization from `this.info`. Potentially races with write in method `OperationInfo.addParameter(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  145.   
  146.           // Return our cached information (if any)
  147. >         if (info == null) {
  148.               // Create and return a new information object
  149.               int impact = MBeanOperationInfo.UNKNOWN;

java/org/apache/tomcat/util/modeler/OperationInfo.java:159: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MBeanOperationInfo OperationInfo.createOperationInfo()` writes to field `this.info` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  157.               info = new MBeanOperationInfo(getName(), getDescription(),
  158.                                             getMBeanParameterInfo(),
  159. >                                           getReturnType(), impact);
  160.           }
  161.           return (MBeanOperationInfo)info;

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:647: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PoolableConnectionFactory BasicDataSource.createPoolableConnectionFactory(ConnectionFactory)` reads without synchronization from `this.registeredJmxObjectName`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  645.           try {
  646.               connectionFactory = new PoolableConnectionFactory(driverConnectionFactory,
  647. >                     ObjectNameWrapper.unwrap(registeredJmxObjectName));
  648.               connectionFactory.setValidationQuery(validationQuery);
  649.               connectionFactory.setValidationQueryTimeout(validationQueryTimeoutSeconds);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:658: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PoolableConnectionFactory BasicDataSource.createPoolableConnectionFactory(ConnectionFactory)` reads without synchronization from `this.maxOpenPreparedStatements`. Potentially races with write in method `BasicDataSource.setMaxOpenPreparedStatements(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  656.               connectionFactory.setCacheState(cacheState);
  657.               connectionFactory.setPoolStatements(poolPreparedStatements);
  658. >             connectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
  659.               connectionFactory.setMaxConnLifetimeMillis(maxConnLifetimeMillis);
  660.               connectionFactory.setRollbackOnReturn(getRollbackOnReturn());

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:657: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PoolableConnectionFactory BasicDataSource.createPoolableConnectionFactory(ConnectionFactory)` reads without synchronization from `this.poolPreparedStatements`. Potentially races with write in method `BasicDataSource.setPoolPreparedStatements(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  655.               connectionFactory.setDefaultSchema(defaultSchema);
  656.               connectionFactory.setCacheState(cacheState);
  657. >             connectionFactory.setPoolStatements(poolPreparedStatements);
  658.               connectionFactory.setMaxOpenPreparedStatements(maxOpenPreparedStatements);
  659.               connectionFactory.setMaxConnLifetimeMillis(maxConnLifetimeMillis);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:665: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PoolableConnectionFactory BasicDataSource.createPoolableConnectionFactory(ConnectionFactory)` indirectly writes to field `conn.autoCommitCached` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  663.               connectionFactory.setFastFailValidation(fastFailValidation);
  664.               connectionFactory.setDisconnectionSqlCodes(disconnectionSqlCodes);
  665. >             validateConnectionFactory(connectionFactory);
  666.           } catch (final RuntimeException e) {
  667.               throw e;

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:492: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SSLEngine OpenSSLContext.createSSLEngine()` reads without synchronization from `this.sessionContext`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  490.       @Override
  491.       public SSLEngine createSSLEngine() {
  492. >         return new OpenSSLEngine(ctx, defaultProtocol, false, sessionContext,
  493.                   (negotiableProtocols != null && negotiableProtocols.size() > 0), initialized,
  494.                   sslHostConfig.getCertificateVerificationDepth(),

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:495: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SSLEngine OpenSSLContext.createSSLEngine()` reads without synchronization from `this.initialized`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  493.                   (negotiableProtocols != null && negotiableProtocols.size() > 0), initialized,
  494.                   sslHostConfig.getCertificateVerificationDepth(),
  495. >                 sslHostConfig.getCertificateVerification() == CertificateVerification.OPTIONAL_NO_CA);
  496.       }
  497.   

java/org/apache/catalina/ha/session/DeltaManager.java:410: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session DeltaManager.createSession(String)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  408.       @Override
  409.       public Session createSession(String sessionId) {
  410. >         return createSession(sessionId, true);
  411.       }
  412.   

java/org/apache/catalina/session/ManagerBase.java:681: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session ManagerBase.createSession(String)` indirectly reads without synchronization from `this.context`. Potentially races with write in method `ManagerBase.setContext(...)`.
 Reporting because this access may occur on a background thread.
  679.           session.setValid(true);
  680.           session.setCreationTime(System.currentTimeMillis());
  681. >         session.setMaxInactiveInterval(getContext().getSessionTimeout() * 60);
  682.           String id = sessionId;
  683.           if (id == null) {

java/org/apache/catalina/session/ManagerBase.java:687: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session ManagerBase.createSession(String)` writes to field `this.sessionCounter` outside of synchronization.
 Reporting because this access may occur on a background thread.
  685.           }
  686.           session.setId(id);
  687. >         sessionCounter++;
  688.   
  689.           SessionTiming timing = new SessionTiming(session.getCreationTime(), 0);

java/org/apache/catalina/session/ManagerBase.java:667: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session ManagerBase.createSession(String)` indirectly reads without synchronization from container `this.sessions` via call to `size`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because this access may occur on a background thread.
  665.   
  666.           if ((maxActiveSessions >= 0) &&
  667. >                 (getActiveSessions() >= maxActiveSessions)) {
  668.               rejectedSessions++;
  669.               throw new TooManyActiveSessionsException(

java/org/apache/catalina/session/ManagerBase.java:668: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session ManagerBase.createSession(String)` writes to field `this.rejectedSessions` outside of synchronization.
 Reporting because this access may occur on a background thread.
  666.           if ((maxActiveSessions >= 0) &&
  667.                   (getActiveSessions() >= maxActiveSessions)) {
  668. >             rejectedSessions++;
  669.               throw new TooManyActiveSessionsException(
  670.                       sm.getString("managerBase.createSession.ise"),

java/org/apache/catalina/session/ManagerBase.java:666: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session ManagerBase.createSession(String)` reads without synchronization from `this.maxActiveSessions`. Potentially races with write in method `ManagerBase.setMaxActiveSessions(...)`.
 Reporting because this access may occur on a background thread.
  664.       public Session createSession(String sessionId) {
  665.   
  666. >         if ((maxActiveSessions >= 0) &&
  667.                   (getActiveSessions() >= maxActiveSessions)) {
  668.               rejectedSessions++;

java/org/apache/catalina/session/ManagerBase.java:684: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session ManagerBase.createSession(String)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `ManagerBase.startInternal()`.
 Reporting because this access may occur on a background thread.
  682.           String id = sessionId;
  683.           if (id == null) {
  684. >             id = generateSessionId();
  685.           }
  686.           session.setId(id);

java/org/apache/catalina/ha/session/DeltaManager.java:424: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session DeltaManager.createSession(String,boolean)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  422.           DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
  423.           if (distribute) {
  424. >             sendCreateSession(session.getId(), session);
  425.           }
  426.           if (log.isDebugEnabled())

java/org/apache/catalina/ha/session/DeltaManager.java:428: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session DeltaManager.createSession(String,boolean)` reads without synchronization from container `this.sessions` via call to `size`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  426.           if (log.isDebugEnabled())
  427.               log.debug(sm.getString("deltaManager.createSession.newSession",
  428. >                     session.getId(), Integer.valueOf(sessions.size())));
  429.           return session;
  430.       }

java/org/apache/catalina/ha/session/DeltaManager.java:422: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Session DeltaManager.createSession(String,boolean)` indirectly writes to field `this.rejectedSessions` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  420.        */
  421.       public Session createSession(String sessionId, boolean distribute) {
  422. >         DeltaSession session = (DeltaSession) super.createSession(sessionId) ;
  423.           if (distribute) {
  424.               sendCreateSession(session.getId(), session);

java/org/apache/catalina/core/StandardContext.java:3287: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Wrapper StandardContext.createWrapper()` reads without synchronization from `this.wrapperClass`. Potentially races with write in method `StandardContext.setWrapperClass(...)`.
 Reporting because this access may occur on a background thread.
  3285.   
  3286.           Wrapper wrapper = null;
  3287. >         if (wrapperClass != null) {
  3288.               try {
  3289.                   wrapper = (Wrapper) wrapperClass.getConstructor().newInstance();

java/org/apache/catalina/realm/JDBCRealm.java:469: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement JDBCRealm.credentials(Connection,String)` reads without synchronization from `this.preparedCredentials`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  467.               throws SQLException {
  468.   
  469. >         if (preparedCredentials == null) {
  470.               StringBuilder sb = new StringBuilder("SELECT ");
  471.               sb.append(userCredCol);

java/org/apache/catalina/realm/JDBCRealm.java:483: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `PreparedStatement JDBCRealm.credentials(Connection,String)` writes to field `this.preparedCredentials` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  481.   
  482.               preparedCredentials =
  483. >                 dbConnection.prepareStatement(sb.toString());
  484.           }
  485.   

java/org/apache/catalina/core/StandardWrapper.java:853: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardWrapper.deallocate(Servlet)` reads without synchronization from `this.instancePool`. Potentially races with write in method `StandardWrapper.getServletMethods()`.
 Reporting because this access may occur on a background thread.
  851.   
  852.           // Unlock and free this instance
  853. >         synchronized (instancePool) {
  854.               countAllocated.decrementAndGet();
  855.               instancePool.push(servlet);

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:104: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FragmentationInterceptor.defrag(ChannelMessage)` indirectly mutates container `this.fragpieces` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  102.   
  103.           if ( coll.complete() ) {
  104. >             removeFragCollection(key);
  105.               ChannelMessage complete = coll.assemble();
  106.               super.messageReceived(complete);

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:100: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FragmentationInterceptor.defrag(ChannelMessage)` indirectly reads without synchronization from container `this.fragpieces` via call to `get`. Potentially races with write in method `FragmentationInterceptor.getFragCollection(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  98.       public void defrag(ChannelMessage msg ) {
  99.           FragKey key = new FragKey(msg.getUniqueId());
  100. >         FragCollection coll = getFragCollection(key,msg);
  101.           coll.addMessage((ChannelMessage)msg.deepclone());
  102.   

java/org/apache/catalina/startup/HostConfig.java:427: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployApps()` indirectly reads without synchronization from container `this.deployed` via call to `get`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  425.           deployDescriptors(configBase, configBase.list());
  426.           // Deploy WARs
  427. >         deployWARs(appBase, filteredAppPaths);
  428.           // Deploy expanded folders
  429.           deployDirectories(appBase, filteredAppPaths);

java/org/apache/catalina/startup/HostConfig.java:487: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployApps(String)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  485.           File xml = new File(configBase, baseName + ".xml");
  486.           if (xml.exists()) {
  487. >             deployDescriptor(cn, xml);
  488.               return;
  489.           }

java/org/apache/catalina/startup/HostConfig.java:493: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployApps(String)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  491.           File war = new File(appBase, baseName + ".war");
  492.           if (war.exists()) {
  493. >             deployWAR(cn, war);
  494.               return;
  495.           }

java/org/apache/catalina/startup/HostConfig.java:499: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployApps(String)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  497.           File dir = new File(appBase, baseName);
  498.           if (dir.exists())
  499. >             deployDirectory(cn, dir);
  500.       }
  501.   

java/org/apache/catalina/startup/HostConfig.java:480: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployApps(String)` indirectly reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  478.           String baseName = cn.getBaseName();
  479.   
  480. >         if (deploymentExists(cn.getName())) {
  481.               return;
  482.           }

java/org/apache/catalina/startup/HostConfig.java:593: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly writes to field `context.webappVersion` outside of synchronization.
 Reporting because this access may occur on a background thread.
  591.               context.setName(cn.getName());
  592.               context.setPath(cn.getPath());
  593. >             context.setWebappVersion(cn.getVersion());
  594.               // Add the associated docBase to the redeployed list if it's a WAR
  595.               if (context.getDocBase() != null) {

java/org/apache/catalina/startup/HostConfig.java:591: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly writes to field `context.name` outside of synchronization.
 Reporting because this access may occur on a background thread.
  589.   
  590.               context.setConfigFile(contextXml.toURI().toURL());
  591. >             context.setName(cn.getName());
  592.               context.setPath(cn.getPath());
  593.               context.setWebappVersion(cn.getVersion());

java/org/apache/catalina/startup/HostConfig.java:590: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because this access may occur on a background thread.
  588.               context.addLifecycleListener(listener);
  589.   
  590. >             context.setConfigFile(contextXml.toURI().toURL());
  591.               context.setName(cn.getName());
  592.               context.setPath(cn.getPath());

java/org/apache/catalina/startup/HostConfig.java:651: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` reads without synchronization from `this.unpackWARs`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  649.               }
  650.   
  651. >             boolean unpackWAR = unpackWARs;
  652.               if (unpackWAR && context instanceof StandardContext) {
  653.                   unpackWAR = ((StandardContext) context).getUnpackWAR();

java/org/apache/catalina/startup/HostConfig.java:581: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly reads without synchronization from `context.path`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because this access may occur on a background thread.
  579.               }
  580.   
  581. >             if (context.getPath() != null) {
  582.                   log.warn(sm.getString("hostConfig.deployDescriptor.path", context.getPath(),
  583.                           contextXml.getAbsolutePath()));

java/org/apache/catalina/startup/HostConfig.java:701: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly reads without synchronization from `context.name`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because this access may occur on a background thread.
  699.           }
  700.   
  701. >         if (host.findChild(context.getName()) != null) {
  702.               deployed.put(context.getName(), deployedApp);
  703.           }

java/org/apache/catalina/startup/HostConfig.java:702: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` mutates container `this.deployed` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  700.   
  701.           if (host.findChild(context.getName()) != null) {
  702. >             deployed.put(context.getName(), deployedApp);
  703.           }
  704.   

java/org/apache/catalina/startup/HostConfig.java:586: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` reads without synchronization from `this.host`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  584.               }
  585.   
  586. >             Class<?> clazz = Class.forName(host.getConfigClass());
  587.               LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();
  588.               context.addLifecycleListener(listener);

java/org/apache/catalina/startup/HostConfig.java:592: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly writes to field `context.path` outside of synchronization.
 Reporting because this access may occur on a background thread.
  590.               context.setConfigFile(contextXml.toURI().toURL());
  591.               context.setName(cn.getName());
  592. >             context.setPath(cn.getPath());
  593.               context.setWebappVersion(cn.getVersion());
  594.               // Add the associated docBase to the redeployed list if it's a WAR

java/org/apache/catalina/startup/HostConfig.java:627: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly writes to field `context.docBase` outside of synchronization.
 Reporting because this access may occur on a background thread.
  625.                                docBase));
  626.                       // Ignore specified docBase
  627. >                     context.setDocBase(null);
  628.                   }
  629.               }

java/org/apache/catalina/startup/HostConfig.java:595: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly reads without synchronization from `context.docBase`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because this access may occur on a background thread.
  593.               context.setWebappVersion(cn.getVersion());
  594.               // Add the associated docBase to the redeployed list if it's a WAR
  595. >             if (context.getDocBase() != null) {
  596.                   File docBase = new File(context.getDocBase());
  597.                   if (!docBase.isAbsolute()) {

java/org/apache/catalina/startup/HostConfig.java:588: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDescriptor(ContextName,File)` indirectly mutates container `context.lifecycleListeners` via call to `add` outside of synchronization.
 Reporting because this access may occur on a background thread.
  586.               Class<?> clazz = Class.forName(host.getConfigClass());
  587.               LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();
  588. >             context.addLifecycleListener(listener);
  589.   
  590.               context.setConfigFile(contextXml.toURI().toURL());

java/org/apache/catalina/startup/HostConfig.java:522: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDescriptors(File,java.lang.String[])` indirectly reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.                   ContextName cn = new ContextName(files[i], true);
  521.   
  522. >                 if (isServiced(cn.getName()) || deploymentExists(cn.getName()))
  523.                       continue;
  524.   

java/org/apache/catalina/startup/HostConfig.java:1042: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDirectories(File,java.lang.String[])` indirectly reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1040.                   ContextName cn = new ContextName(files[i], false);
  1041.   
  1042. >                 if (isServiced(cn.getName()) || deploymentExists(cn.getName()))
  1043.                       continue;
  1044.   

java/org/apache/catalina/startup/HostConfig.java:1083: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDirectory(ContextName,File)` indirectly reads without synchronization from `this.copyXML`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  1081.   
  1082.           DeployedApplication deployedApp;
  1083. >         boolean copyThisXml = isCopyXML();
  1084.           boolean deployThisXML = isDeployThisXML(dir, cn);
  1085.   

java/org/apache/catalina/startup/HostConfig.java:1181: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDirectory(ContextName,File)` mutates container `this.deployed` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1179.           }
  1180.   
  1181. >         deployed.put(cn.getName(), deployedApp);
  1182.   
  1183.           if( log.isInfoEnabled() ) {

java/org/apache/catalina/startup/HostConfig.java:1125: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDirectory(ContextName,File)` reads without synchronization from `this.host`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  1123.               }
  1124.   
  1125. >             Class<?> clazz = Class.forName(host.getConfigClass());
  1126.               LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();
  1127.               context.addLifecycleListener(listener);

java/org/apache/catalina/startup/HostConfig.java:1111: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployDirectory(ContextName,File)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1109.                   if (copyThisXml) {
  1110.                       Files.copy(xml.toPath(), xmlCopy.toPath());
  1111. >                     context.setConfigFile(xmlCopy.toURI().toURL());
  1112.                   } else {
  1113.                       context.setConfigFile(xml.toURI().toURL());

java/org/apache/catalina/startup/HostConfig.java:1084: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDirectory(ContextName,File)` indirectly reads without synchronization from `this.deployXML`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  1082.           DeployedApplication deployedApp;
  1083.           boolean copyThisXml = isCopyXML();
  1084. >         boolean deployThisXML = isDeployThisXML(dir, cn);
  1085.   
  1086.           try {

java/org/apache/catalina/startup/HostConfig.java:1122: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployDirectory(ContextName,File)` reads without synchronization from `this.contextClass`. Potentially races with write in method `HostConfig.setContextClass(...)`.
 Reporting because this access may occur on a background thread.
  1120.                   context = new FailedContext();
  1121.               } else {
  1122. >                 context = (Context) Class.forName(contextClass).getConstructor().newInstance();
  1123.               }
  1124.   

java/org/apache/catalina/startup/HostConfig.java:918: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` reads without synchronization from `this.host`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  916.           boolean copyThisXml = false;
  917.           if (deployThisXML) {
  918. >             if (host instanceof StandardHost) {
  919.                   copyThisXml = ((StandardHost) host).isCopyXML();
  920.               }

java/org/apache/catalina/startup/HostConfig.java:974: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly writes to field `context.name` outside of synchronization.
 Reporting because this access may occur on a background thread.
  972.               context.addLifecycleListener(listener);
  973.   
  974. >             context.setName(cn.getName());
  975.               context.setPath(cn.getPath());
  976.               context.setWebappVersion(cn.getVersion());

java/org/apache/catalina/startup/HostConfig.java:861: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` reads without synchronization from `this.copyXML`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  859.   
  860.           try {
  861. >             if (deployThisXML && useXml && !copyXML) {
  862.                   synchronized (digesterLock) {
  863.                       try {

java/org/apache/catalina/startup/HostConfig.java:858: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly reads without synchronization from `this.deployXML`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  856.   
  857.           Context context = null;
  858. >         boolean deployThisXML = isDeployThisXML(war, cn);
  859.   
  860.           try {

java/org/apache/catalina/startup/HostConfig.java:876: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly writes to field `context.configFile` outside of synchronization.
 Reporting because this access may occur on a background thread.
  874.                       }
  875.                   }
  876. >                 context.setConfigFile(xml.toURI().toURL());
  877.               } else if (deployThisXML && xmlInWar) {
  878.                   synchronized (digesterLock) {

java/org/apache/catalina/startup/HostConfig.java:904: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` reads without synchronization from `this.contextClass`. Potentially races with write in method `HostConfig.setContextClass(...)`.
 Reporting because this access may occur on a background thread.
  902.                           new File(host.getConfigBaseFile(), cn.getBaseName() + ".xml")));
  903.               } else {
  904. >                 context = (Context) Class.forName(contextClass).getConstructor().newInstance();
  905.               }
  906.           } catch (Throwable t) {

java/org/apache/catalina/startup/HostConfig.java:976: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly writes to field `context.webappVersion` outside of synchronization.
 Reporting because this access may occur on a background thread.
  974.               context.setName(cn.getName());
  975.               context.setPath(cn.getPath());
  976. >             context.setWebappVersion(cn.getVersion());
  977.               context.setDocBase(cn.getBaseName() + ".war");
  978.               host.addChild(context);

java/org/apache/catalina/startup/HostConfig.java:990: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly reads without synchronization from `context.docBase`. Potentially races with write in method `HostConfig.deployWAR(...)`.
 Reporting because this access may occur on a background thread.
  988.                   unpackWAR = ((StandardContext) context).getUnpackWAR();
  989.               }
  990. >             if (unpackWAR && context.getDocBase() != null) {
  991.                   File docBase = new File(host.getAppBaseFile(), cn.getBaseName());
  992.                   deployedApp.redeployResources.put(docBase.getAbsolutePath(),

java/org/apache/catalina/startup/HostConfig.java:972: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly mutates container `context.lifecycleListeners` via call to `add` outside of synchronization.
 Reporting because this access may occur on a background thread.
  970.               Class<?> clazz = Class.forName(host.getConfigClass());
  971.               LifecycleListener listener = (LifecycleListener) clazz.getConstructor().newInstance();
  972. >             context.addLifecycleListener(listener);
  973.   
  974.               context.setName(cn.getName());

java/org/apache/catalina/startup/HostConfig.java:1010: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` mutates container `this.deployed` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1008.           }
  1009.   
  1010. >         deployed.put(cn.getName(), deployedApp);
  1011.   
  1012.           if (log.isInfoEnabled()) {

java/org/apache/catalina/startup/HostConfig.java:975: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly writes to field `context.path` outside of synchronization.
 Reporting because this access may occur on a background thread.
  973.   
  974.               context.setName(cn.getName());
  975. >             context.setPath(cn.getPath());
  976.               context.setWebappVersion(cn.getVersion());
  977.               context.setDocBase(cn.getBaseName() + ".war");

java/org/apache/catalina/startup/HostConfig.java:977: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.deployWAR(ContextName,File)` indirectly writes to field `context.docBase` outside of synchronization.
 Reporting because this access may occur on a background thread.
  975.               context.setPath(cn.getPath());
  976.               context.setWebappVersion(cn.getVersion());
  977. >             context.setDocBase(cn.getBaseName() + ".war");
  978.               host.addChild(context);
  979.           } catch (Throwable t) {

java/org/apache/catalina/startup/HostConfig.java:986: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWAR(ContextName,File)` reads without synchronization from `this.unpackWARs`. Potentially races with write in method `HostConfig.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  984.               // If we're unpacking WARs, the docBase will be mutated after
  985.               // starting the context
  986. >             boolean unpackWAR = unpackWARs;
  987.               if (unpackWAR && context instanceof StandardContext) {
  988.                   unpackWAR = ((StandardContext) context).getUnpackWAR();

java/org/apache/catalina/startup/HostConfig.java:741: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.deployWARs(File,java.lang.String[])` reads without synchronization from container `this.deployed` via call to `get`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  739.                   }
  740.                   if (deploymentExists(cn.getName())) {
  741. >                     DeployedApplication app = deployed.get(cn.getName());
  742.                       boolean unpackWAR = unpackWARs;
  743.                       if (unpackWAR && host.findChild(cn.getName()) instanceof StandardContext) {

java/org/apache/catalina/startup/HostConfig.java:1197: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean HostConfig.deploymentExists(String)` reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1195.        */
  1196.       protected boolean deploymentExists(String contextName) {
  1197. >         return (deployed.containsKey(contextName) ||
  1198.                   (host.findChild(contextName) != null));
  1199.       }

java/org/apache/catalina/authenticator/SingleSignOn.java:405: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SingleSignOn.deregister(String)` indirectly reads without synchronization from `this.engine`. Potentially races with write in method `SingleSignOn.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  403.               }
  404.               // Invalidate this session
  405. >             expire(ssoKey);
  406.           }
  407.   

java/org/apache/catalina/ha/session/DeltaSession.java:686: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.deserializeAndExecuteDeltaRequest(byte[])` indirectly writes to field `info.action` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  684.   
  685.               ReplicationStream ois = ((ClusterManagerBase) manager).getReplicationStream(delta);
  686. >             newDeltaRequest.readExternal(ois);
  687.               ois.close();
  688.   

java/org/apache/catalina/ha/session/DeltaManager.java:576: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `DeltaRequest DeltaManager.deserializeDeltaRequest(DeltaSession,byte[])` indirectly writes to field `info.action` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  574.           try {
  575.               ReplicationStream ois = getReplicationStream(data);
  576. >             session.getDeltaRequest().readExternal(ois);
  577.               ois.close();
  578.               return session.getDeltaRequest();

java/org/apache/jasper/compiler/JspRuntimeContext.java:300: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspRuntimeContext.destroy()` reads without synchronization from container `this.jsps` via call to `values`. Potentially races with write in method `JspRuntimeContext.checkUnload()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  298.        */
  299.       public void destroy() {
  300. >         for (JspServletWrapper jspServletWrapper : jsps.values()) {
  301.               jspServletWrapper.destroy();
  302.           }

java/org/apache/tomcat/util/net/AprEndpoint.java:1109: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.destroy()` reads with synchronization from `this.aprPoller`. Potentially races with unsynchronized write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1107.               addList.clear();
  1108.               // Close all sockets still in the poller
  1109. >             int rv = Poll.pollset(aprPoller, desc);
  1110.               if (rv > 0) {
  1111.                   for (int n = 0; n < rv; n++) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1112: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.destroy()` reads with synchronization from `this.desc.[_]`. Potentially races with unsynchronized write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1110.               if (rv > 0) {
  1111.                   for (int n = 0; n < rv; n++) {
  1112. >                     closeSocketInternal(desc[n*2+1]);
  1113.                       destroySocketInternal(desc[n*2+1]);
  1114.                   }

java/org/apache/tomcat/util/net/AprEndpoint.java:1088: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.destroy()` indirectly reads with synchronization from `this.timeouts.size`. Potentially races with unsynchronized write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1086.                   addList.remove(info.socket);
  1087.                   // Make sure the socket isn't in the poller before we close it
  1088. >                 removeFromPoller(info.socket);
  1089.                   // Poller isn't running at this point so use destroySocket()
  1090.                   // directly

java/org/apache/tomcat/util/net/AprEndpoint.java:1674: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.destroy()` reads without synchronization from `this.pool`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1672.                   }
  1673.               }
  1674. >             Pool.destroy(pool);
  1675.               sendfileData.clear();
  1676.           }

java/org/apache/tomcat/util/net/AprEndpoint.java:1668: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.destroy()` reads without synchronization from `this.desc`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1666.               }
  1667.               // Close all sockets still in the poller
  1668. >             int rv = Poll.pollset(sendfilePollset, desc);
  1669.               if (rv > 0) {
  1670.                   for (int n = 0; n < rv; n++) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1675: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.destroy()` reads without synchronization from `this.sendfileData`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1673.               }
  1674.               Pool.destroy(pool);
  1675. >             sendfileData.clear();
  1676.           }
  1677.   

java/org/apache/tomcat/util/net/AprEndpoint.java:1663: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.destroy()` reads without synchronization from `this.addS`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1661.           protected void destroy() {
  1662.               // Close any socket remaining in the add queue
  1663. >             for (int i = (addS.size() - 1); i >= 0; i--) {
  1664.                   SendfileData data = addS.get(i);
  1665.                   closeSocketInternal(data.socket);

java/org/apache/tomcat/util/net/AprEndpoint.java:1664: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.destroy()` reads without synchronization from container `this.addS` via call to `get`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1662.               // Close any socket remaining in the add queue
  1663.               for (int i = (addS.size() - 1); i >= 0; i--) {
  1664. >                 SendfileData data = addS.get(i);
  1665.                   closeSocketInternal(data.socket);
  1666.               }

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:1034: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsWebSocketContainer.destroy()` reads without synchronization from container `this.sessions` via call to `keySet`. Potentially races with write in method `WsWebSocketContainer.connectToServer(...)`.
 Reporting because this access may occur on a background thread.
  1032.                   CloseCodes.GOING_AWAY, sm.getString("wsWebSocketContainer.shutdown"));
  1033.   
  1034. >         for (WsSession session : sessions.keySet()) {
  1035.               try {
  1036.                   session.close(cr);

java/org/apache/catalina/core/StandardContext.java:5499: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.destroyInternal()` reads without synchronization from `this.namingResources`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5497.           }
  5498.   
  5499. >         if (namingResources != null) {
  5500.               namingResources.destroy();
  5501.           }

java/org/apache/catalina/core/StandardContext.java:5513: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.destroyInternal()` reads without synchronization from `this.resources`. Potentially races with write in method `StandardContext.setResources(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5511.           }
  5512.   
  5513. >         if (resources != null) {
  5514.               resources.destroy();
  5515.           }

java/org/apache/catalina/core/StandardServer.java:1064: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.destroyInternal()` reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1062.       protected void destroyInternal() throws LifecycleException {
  1063.           // Destroy our defined Services
  1064. >         for (int i = 0; i < services.length; i++) {
  1065.               services[i].destroy();
  1066.           }

java/org/apache/catalina/core/StandardService.java:555: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.destroyInternal()` reads without synchronization from `this.engine`. Potentially races with write in method `StandardService.setContainer(...)`.
 Reporting because this access may occur on a background thread.
  553.           }
  554.   
  555. >         if (engine != null) {
  556.               engine.destroy();
  557.           }

java/org/apache/catalina/deploy/NamingResourcesImpl.java:1092: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.destroyInternal()` reads without synchronization from container `this.resourceLinks` via call to `values`. Potentially races with write in method `NamingResourcesImpl.addEnvironment(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1090.   
  1091.           // Destroy in reverse order to create, although it should not matter
  1092. >         for (ContextResourceLink crl : resourceLinks.values()) {
  1093.               try {
  1094.                   MBeanUtils.destroyMBean(crl);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:1101: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.destroyInternal()` reads without synchronization from container `this.envs` via call to `values`. Potentially races with write in method `NamingResourcesImpl.removeEnvironment(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1099.           }
  1100.   
  1101. >         for (ContextEnvironment ce : envs.values()) {
  1102.               try {
  1103.                   MBeanUtils.destroyMBean(ce);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:1110: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.destroyInternal()` reads without synchronization from container `this.resources` via call to `values`. Potentially races with write in method `NamingResourcesImpl.removeResource(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1108.           }
  1109.   
  1110. >         for (ContextResource cr : resources.values()) {
  1111.               try {
  1112.                   MBeanUtils.destroyMBean(cr);

java/org/apache/catalina/mbeans/MBeanUtils.java:677: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(Group)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  675.   
  676.           String mname = createManagedName(group);
  677. >         ManagedBean managed = registry.findManagedBean(mname);
  678.           if (managed == null) {
  679.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:683: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(Group)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  681.           String domain = managed.getDomain();
  682.           if (domain == null)
  683. >             domain = mserver.getDefaultDomain();
  684.           ObjectName oname = createObjectName(domain, group);
  685.           if( mserver.isRegistered(oname) )

java/org/apache/catalina/mbeans/MBeanUtils.java:709: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(Role)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  707.           String domain = managed.getDomain();
  708.           if (domain == null)
  709. >             domain = mserver.getDefaultDomain();
  710.           ObjectName oname = createObjectName(domain, role);
  711.           if( mserver.isRegistered(oname) )

java/org/apache/catalina/mbeans/MBeanUtils.java:703: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(Role)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  701.   
  702.           String mname = createManagedName(role);
  703. >         ManagedBean managed = registry.findManagedBean(mname);
  704.           if (managed == null) {
  705.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:735: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(User)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  733.           String domain = managed.getDomain();
  734.           if (domain == null)
  735. >             domain = mserver.getDefaultDomain();
  736.           ObjectName oname = createObjectName(domain, user);
  737.           if( mserver.isRegistered(oname) )

java/org/apache/catalina/mbeans/MBeanUtils.java:729: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(User)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  727.   
  728.           String mname = createManagedName(user);
  729. >         ManagedBean managed = registry.findManagedBean(mname);
  730.           if (managed == null) {
  731.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:594: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextEnvironment)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  592.   
  593.           String mname = createManagedName(environment);
  594. >         ManagedBean managed = registry.findManagedBean(mname);
  595.           if (managed == null) {
  596.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:600: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextEnvironment)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  598.           String domain = managed.getDomain();
  599.           if (domain == null)
  600. >             domain = mserver.getDefaultDomain();
  601.           ObjectName oname = createObjectName(domain, environment);
  602.           if( mserver.isRegistered(oname) )

java/org/apache/catalina/mbeans/MBeanUtils.java:622: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextResource)` indirectly reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  620.           // users and UserDatabase mbean
  621.           if ("org.apache.catalina.UserDatabase".equals(resource.getType())) {
  622. >             destroyMBeanUserDatabase(resource.getName());
  623.           }
  624.   

java/org/apache/catalina/mbeans/MBeanUtils.java:626: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextResource)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  624.   
  625.           String mname = createManagedName(resource);
  626. >         ManagedBean managed = registry.findManagedBean(mname);
  627.           if (managed == null) {
  628.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:658: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextResourceLink)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  656.           String domain = managed.getDomain();
  657.           if (domain == null)
  658. >             domain = mserver.getDefaultDomain();
  659.           ObjectName oname = createObjectName(domain, resourceLink);
  660.           if( mserver.isRegistered(oname) )

java/org/apache/catalina/mbeans/MBeanUtils.java:652: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBean(ContextResourceLink)` reads without synchronization from `mbeans.MBeanUtils.registry`. Potentially races with write in method `MBeanUtils.createRegistry()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  650.   
  651.           String mname = createManagedName(resourceLink);
  652. >         ManagedBean managed = registry.findManagedBean(mname);
  653.           if (managed == null) {
  654.               return;

java/org/apache/catalina/mbeans/MBeanUtils.java:760: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MBeanUtils.destroyMBeanUserDatabase(String)` reads without synchronization from `mbeans.MBeanUtils.mserver`. Potentially races with write in method `MBeanUtils.createServer()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  758.           query = new ObjectName(
  759.                   "Users:type=Group,database=" + userDatabase + ",*");
  760. >         results = mserver.queryNames(query, null);
  761.           for(ObjectName result : results) {
  762.               mserver.unregisterMBean(result);

java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java:46: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void KeyedCPDSConnectionFactory.destroyObject(Object,PooledObject)` indirectly mutates container `this.pcMap` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  44.    * @since 2.0
  45.    */
  46. > class KeyedCPDSConnectionFactory implements KeyedPooledObjectFactory<UserPassKey, PooledConnectionAndInfo>,
  47.           ConnectionEventListener, PooledConnectionManager {
  48.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java:147: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void KeyedCPDSConnectionFactory.destroyObject(UserPassKey,PooledObject)` mutates container `this.pcMap` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  145.           final PooledConnection pc = p.getObject().getPooledConnection();
  146.           pc.removeConnectionEventListener(this);
  147. >         pcMap.remove(pc);
  148.           pc.close();
  149.       }

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:183: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void CPDSConnectionFactory.destroyObject(PooledObject)` indirectly mutates container `this.pcMap` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  181.       @Override
  182.       public void destroyObject(final PooledObject<PooledConnectionAndInfo> p) throws Exception {
  183. >         doDestroyObject(p.getObject());
  184.       }
  185.   

java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java:67: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `byte[] ConcurrentMessageDigest.digest(String,byte[][])` indirectly reads without synchronization from container `security.ConcurrentMessageDigest.queues` via call to `get`. Potentially races with write in method `ConcurrentMessageDigest.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  65.   
  66.       public static byte[] digest(String algorithm, byte[]... input) {
  67. >         return digest(algorithm, 1, input);
  68.       }
  69.   

java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java:73: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `byte[] ConcurrentMessageDigest.digest(String,int,byte[][])` reads without synchronization from container `security.ConcurrentMessageDigest.queues` via call to `get`. Potentially races with write in method `ConcurrentMessageDigest.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.       public static byte[] digest(String algorithm, int iterations, byte[]... input) {
  72.   
  73. >         Queue<MessageDigest> queue = queues.get(algorithm);
  74.           if (queue == null) {
  75.               throw new IllegalStateException(sm.getString("concurrentMessageDigest.noDigest"));

java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java:59: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `byte[] ConcurrentMessageDigest.digestMD5(byte[][])` indirectly reads without synchronization from container `security.ConcurrentMessageDigest.queues` via call to `get`. Potentially races with write in method `ConcurrentMessageDigest.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  57.   
  58.       public static byte[] digestMD5(byte[]... input) {
  59. >         return digest(MD5, input);
  60.       }
  61.   

java/org/apache/tomcat/util/security/ConcurrentMessageDigest.java:63: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `byte[] ConcurrentMessageDigest.digestSHA1(byte[][])` indirectly reads without synchronization from container `security.ConcurrentMessageDigest.queues` via call to `get`. Potentially races with write in method `ConcurrentMessageDigest.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  61.   
  62.       public static byte[] digestSHA1(byte[]... input) {
  63. >         return digest(SHA1, input);
  64.       }
  65.   

java/org/apache/catalina/tribes/transport/nio/NioSender.java:270: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioSender.disconnect()` reads without synchronization from `this.socketChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  268.               connecting = false;
  269.               setConnected(false);
  270. >             if (socketChannel != null) {
  271.                   try {
  272.                       try {

java/org/apache/catalina/tribes/transport/nio/NioSender.java:290: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioSender.disconnect()` reads without synchronization from `this.dataChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  288.                   }
  289.               }
  290. >             if (dataChannel != null) {
  291.                   try {
  292.                       try {

java/org/apache/catalina/tribes/transport/nio/NioSender.java:307: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.disconnect()` writes to field `this.dataChannel` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  305.                       }
  306.                   } finally {
  307. >                     dataChannel = null;
  308.                   }
  309.               }

java/org/apache/catalina/tribes/transport/nio/NioSender.java:268: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.disconnect()` writes to field `this.connecting` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  266.       public void disconnect() {
  267.           try {
  268. >             connecting = false;
  269.               setConnected(false);
  270.               if (socketChannel != null) {

java/org/apache/catalina/tribes/transport/nio/NioSender.java:287: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.disconnect()` writes to field `this.socketChannel` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  285.                       }
  286.                   } finally {
  287. >                     socketChannel = null;
  288.                   }
  289.               }

java/org/apache/catalina/core/AsyncContextImpl.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.dispatch()` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.               path = path.substring(cpath.length());
  171.           }
  172. >         if (!context.getDispatchersUseEncodedPaths()) {
  173.               path = UDecoder.URLDecode(path, StandardCharsets.UTF_8);
  174.           }

java/org/apache/catalina/core/AsyncContextImpl.java:166: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.dispatch()` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  164.               cpath = sr.getContextPath();
  165.           } else {
  166. >             path = request.getRequestURI();
  167.               cpath = request.getContextPath();
  168.           }

java/org/apache/coyote/AbstractProcessor.java:238: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `AbstractEndpoint$Handler$SocketState AbstractProcessor.dispatch(SocketEvent)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  236.               rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
  237.               if (!getAdapter().asyncDispatch(request, response, status)) {
  238. >                 setErrorState(ErrorState.CLOSE_NOW, null);
  239.               }
  240.           } catch (InterruptedIOException e) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:219: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator.doAuthenticate(Request,HttpServletResponse)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  217.           if (authorization != null) {
  218.               if (digestInfo.parse(request, authorization)) {
  219. >                 if (digestInfo.validate(request)) {
  220.                       principal = digestInfo.authenticate(context.getRealm());
  221.                   }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:236: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator.doAuthenticate(Request,HttpServletResponse)` indirectly reads without synchronization from `this.key`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  234.           // Next, generate a nonce token (that is a token which is supposed
  235.           // to be unique).
  236. >         String nonce = generateNonce(request);
  237.   
  238.           setAuthenticateHeader(request, response, nonce,

java/org/apache/catalina/authenticator/DigestAuthenticator.java:216: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator.doAuthenticate(Request,HttpServletResponse)` reads without synchronization from `this.nonces`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  214.           String authorization = request.getHeader("authorization");
  215.           DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),
  216. >                 getKey(), nonces, isValidateUri());
  217.           if (authorization != null) {
  218.               if (digestInfo.parse(request, authorization)) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:215: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator.doAuthenticate(Request,HttpServletResponse)` indirectly reads without synchronization from `this.opaque`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.           Principal principal = null;
  214.           String authorization = request.getHeader("authorization");
  215. >         DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(),
  216.                   getKey(), nonces, isValidateUri());
  217.           if (authorization != null) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:208: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator.doAuthenticate(Request,HttpServletResponse)` indirectly reads without synchronization from `buf.StringCache.accessCount`. Potentially races with write in method `DigestAuthenticator.generateNonce(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  206.           // to authenticate users for this webapp
  207.           // TODO make this a configurable attribute (in SingleSignOn??)
  208. >         if (checkForCachedAuthentication(request, response, false)) {
  209.               return true;
  210.           }

java/org/apache/tomcat/websocket/WsSession.java:506: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsSession.doClose(CloseReason,CloseReason,boolean)` reads without synchronization from container `this.futures` via call to `keySet`. Potentially races with write in method `WsSession.registerFuture(...)`.
 Reporting because this access may occur on a background thread.
  504.           IOException ioe = new IOException(sm.getString("wsSession.messageFailed"));
  505.           SendResult sr = new SendResult(ioe);
  506. >         for (FutureToSendHandler f2sh : futures.keySet()) {
  507.               f2sh.onResult(sr);
  508.           }

java/org/apache/catalina/core/AsyncContextImpl.java:359: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.doInternalDispatch()` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  357.       protected void doInternalDispatch() throws ServletException, IOException {
  358.           if (log.isDebugEnabled()) {
  359. >             logDebug("intDispatch");
  360.           }
  361.           try {

java/org/apache/catalina/core/AsyncContextImpl.java:366: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.doInternalDispatch()` indirectly reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  364.               runnable.run();
  365.               if (!request.isAsync()) {
  366. >                 fireOnComplete();
  367.               }
  368.           } catch (RuntimeException x) {

java/org/apache/catalina/session/StandardManager.java:182: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardManager.doLoad()` mutates container `this.sessions` via call to `clear` outside of synchronization.
 Reporting because this access may occur on a background thread.
  180.   
  181.           // Initialize our internal data structures
  182. >         sessions.clear();
  183.   
  184.           // Open an input stream to the specified pathname, if any

java/org/apache/catalina/session/StandardManager.java:185: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.doLoad()` indirectly reads without synchronization from `this.pathname`. Potentially races with write in method `StandardManager.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  183.   
  184.           // Open an input stream to the specified pathname, if any
  185. >         File file = file();
  186.           if (file == null) {
  187.               return;

java/org/apache/coyote/http2/Stream.java:1123: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int Stream$StreamInputBuffer.doRead(ApplicationBufferHandler)` reads without synchronization from `this.outBuffer`. Potentially races with write in method `Stream$StreamInputBuffer.doRead(...)`.
 Reporting because this access may occur on a background thread.
  1121.               }
  1122.   
  1123. >             applicationBufferHandler.setByteBuffer(ByteBuffer.wrap(outBuffer, 0,  written));
  1124.   
  1125.               // Increment client-side flow control windows by the number of bytes

java/org/apache/catalina/ha/session/DeltaSession.java:803: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.doReadObject(ObjectInputStream)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  801.       @Override
  802.       protected void doReadObject(ObjectInputStream stream) throws ClassNotFoundException, IOException {
  803. >         doReadObject((ObjectInput)stream);
  804.       }
  805.   

java/org/apache/catalina/session/StandardManager.java:326: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.doUnload()` indirectly reads with synchronization from `session.manager`. Potentially races with unsynchronized write in method `StandardManager.doUnload()`.
 Reporting because this access may occur on a background thread.
  324.           for (StandardSession session : list) {
  325.               try {
  326. >                 session.expire(false);
  327.               } catch (Throwable t) {
  328.                   ExceptionUtils.handleThrowable(t);

java/org/apache/catalina/session/StandardManager.java:290: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.doUnload()` indirectly reads without synchronization from `this.pathname`. Potentially races with write in method `StandardManager.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  288.   
  289.           // Open an output stream to the specified pathname, if any
  290. >         File file = file();
  291.           if (file == null) {
  292.               return;

java/org/apache/catalina/session/StandardManager.java:311: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.doUnload()` reads with synchronization from container `this.sessions` via call to `values`. Potentially races with unsynchronized write in method `StandardManager.doLoad()`.
 Reporting because this access may occur on a background thread.
  309.                   // Write the number of active sessions, followed by the details
  310.                   oos.writeObject(Integer.valueOf(sessions.size()));
  311. >                 for (Session s : sessions.values()) {
  312.                       StandardSession session = (StandardSession) s;
  313.                       list.add(session);

java/org/apache/catalina/session/StandardManager.java:315: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.doUnload()` indirectly reads with synchronization from `session.creationTime`. Potentially races with unsynchronized write in method `StandardManager.doUnload()`.
 Reporting because this access may occur on a background thread.
  313.                       list.add(session);
  314.                       session.passivate();
  315. >                     session.writeObjectData(oos);
  316.                   }
  317.               }

java/org/apache/catalina/session/StandardManager.java:330: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardManager.doUnload()` indirectly writes to field `session.authType` outside of synchronization.
 Reporting because this access may occur on a background thread.
  328.                   ExceptionUtils.handleThrowable(t);
  329.               } finally {
  330. >                 session.recycle();
  331.               }
  332.           }

java/org/apache/tomcat/util/net/NioEndpoint.java:1270: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioEndpoint$NioSocketWrapper.doWrite(boolean,ByteBuffer)` indirectly reads without synchronization from `this.socket`. Potentially races with write in method `NioEndpoint$NioSocketWrapper.doClose()`.
 Reporting because this access may occur on a background thread.
  1268.           @Override
  1269.           protected void doWrite(boolean block, ByteBuffer from) throws IOException {
  1270. >             NioChannel socket = getSocket();
  1271.               if (socket instanceof ClosedNioChannel) {
  1272.                   throw new ClosedChannelException();

java/org/apache/tomcat/util/net/NioEndpoint.java:1285: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$NioSocketWrapper.doWrite(boolean,ByteBuffer)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1283.                           if (n == 0) {
  1284.                               writeBlocking = true;
  1285. >                             registerWriteInterest();
  1286.                               synchronized (writeLock) {
  1287.                                   if (writeBlocking) {

java/org/apache/coyote/http2/Http2UpgradeHandler.java:691: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Http2UpgradeHandler$HeaderFrameBuffers Http2UpgradeHandler.doWriteHeaders(Stream,int,MimeHeaders,boolean,int)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  689.                   headerFrameBuffers.getPayload().put(pushedStreamIdBytes);
  690.               }
  691. >             state = getHpackEncoder().encode(mimeHeaders, headerFrameBuffers.getPayload());
  692.               headerFrameBuffers.getPayload().flip();
  693.               if (state == State.COMPLETE || headerFrameBuffers.getPayload().limit() > 0) {

java/org/apache/catalina/session/StandardSession.java:1659: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.doWriteObject(ObjectOutputStream)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1657.                   saveValues.add(value);
  1658.               } else {
  1659. >                 removeAttributeInternal(keys[i], true);
  1660.               }
  1661.           }

java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java:159: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioReplicationTask.drainChannel(SelectionKey,ObjectReader)` reads without synchronization from `this.buffer`. Potentially races with write in method `NioReplicationTask.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  157.           ReadableByteChannel channel = (ReadableByteChannel) key.channel();
  158.           int count=-1;
  159. >         buffer.clear();         // make buffer empty
  160.           SocketAddress saddr = null;
  161.   

java/org/apache/catalina/tribes/transport/nio/NioReplicationTask.java:195: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioReplicationTask.drainChannel(SelectionKey,ObjectReader)` indirectly writes to field `xbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  193.           }
  194.   
  195. >         ChannelMessage[] msgs = pkgcnt == 0? ChannelData.EMPTY_DATA_ARRAY : reader.execute();
  196.   
  197.           registerForRead(key,reader);//register to read new data, before we send it off to avoid dead locks

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:140: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.drainSocket()` reads without synchronization from `this.socket`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  138.        */
  139.       protected void drainSocket() throws Exception {
  140. >         InputStream in = socket.getInputStream();
  141.           // loop while data available, channel is non-blocking
  142.           byte[] buf = new byte[1024];

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:145: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.drainSocket()` reads without synchronization from `this.reader`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.           int length = in.read(buf);
  144.           while ( length >= 0 ) {
  145. >             int count = reader.append(buf,0,length,true);
  146.               if ( count > 0 ) execute(reader);
  147.               length = in.read(buf);

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:146: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BioReplicationTask.drainSocket()` indirectly writes to field `xbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  144.           while ( length >= 0 ) {
  145.               int count = reader.append(buf,0,length,true);
  146. >             if ( count > 0 ) execute(reader);
  147.               length = in.read(buf);
  148.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:417: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.endMessage(SendHandler,SendResult)` reads without synchronization from `this.wsSession`. Potentially races with write in method `WsRemoteEndpointImplBase.setSession(...)`.
 Reporting because this access may occur on a background thread.
  415.           }
  416.   
  417. >         wsSession.updateLastActive();
  418.   
  419.           // Some handlers, such as the IntermediateMessageHandler, do not have a

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:414: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.endMessage(SendHandler,SendResult)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.setBatchingAllowed(...)`.
 Reporting because this access may occur on a background thread.
  412.               // deadlock between messagePartLock and writeLock in
  413.               // o.a.coyote.http11.upgrade.AbstractServletOutputStream
  414. >             writeMessagePart(mpNext);
  415.           }
  416.   

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:396: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.endMessage(SendHandler,SendResult)` reads with synchronization from `this.nextFragmented`. Potentially races with unsynchronized write in method `WsRemoteEndpointImplBase.startMessage(...)`.
 Reporting because this access may occur on a background thread.
  394.           synchronized (messagePartLock) {
  395.   
  396. >             fragmented = nextFragmented;
  397.               text = nextText;
  398.   

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:397: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.endMessage(SendHandler,SendResult)` reads with synchronization from `this.nextText`. Potentially races with unsynchronized write in method `WsRemoteEndpointImplBase.startMessage(...)`.
 Reporting because this access may occur on a background thread.
  395.   
  396.               fragmented = nextFragmented;
  397. >             text = nextText;
  398.   
  399.               mpNext = messagePartQueue.poll();

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1407: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.endRequestBodyFrame(int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1405.       @Override
  1406.       public void endRequestBodyFrame(int streamId) throws Http2Exception {
  1407. >         Stream stream = getStream(streamId, true);
  1408.           stream.getInputBuffer().onDataAvailable();
  1409.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1203: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.ensureMinIdle()` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1201.   
  1202.           for (final K k : poolMap.keySet()) {
  1203. >             ensureMinIdle(k);
  1204.           }
  1205.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:948: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.ensureMinIdle()` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  946.       @Override
  947.       void ensureMinIdle() throws Exception {
  948. >         ensureIdle(getMinIdle(), true);
  949.       }
  950.   

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:681: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BasicDataSource.evict()` indirectly mutates container `this.connectionPool.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  679.       public void evict() throws Exception {
  680.           if (connectionPool != null) {
  681. >             connectionPool.evict();
  682.           }
  683.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:857: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.evict()` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.borrowObject(...)`.
 Reporting because this access may occur on a background thread.
  855.           assertOpen();
  856.   
  857. >         if (getNumIdle() == 0) {
  858.               return;
  859.           }

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:815: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.evict()` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  813.           final AbandonedConfig ac = this.abandonedConfig;
  814.           if (ac != null && ac.getRemoveAbandonedOnMaintenance()) {
  815. >             removeAbandoned(ac);
  816.           }
  817.       }

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:154: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MbeansDescriptorsDigesterSource.execute()` writes to field `this.registry` outside of synchronization.
 Reporting because this access may occur on a background thread.
  152.       public void execute() throws Exception {
  153.           if (registry == null) {
  154. >             registry = Registry.getRegistry(null, null);
  155.           }
  156.   

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:157: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MbeansDescriptorsDigesterSource.execute()` reads without synchronization from `this.source`. Potentially races with write in method `MbeansDescriptorsDigesterSource.loadDescriptors(...)`.
 Reporting because this access may occur on a background thread.
  155.           }
  156.   
  157. >         InputStream stream = (InputStream) source;
  158.   
  159.           List<ManagedBean> loadedMbeans = new ArrayList<>();

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:179: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MbeansDescriptorsDigesterSource.execute()` reads without synchronization from `this.registry`. Potentially races with write in method `MbeansDescriptorsDigesterSource.execute()`.
 Reporting because this access may occur on a background thread.
  177.           }
  178.           for (ManagedBean loadedMbean : loadedMbeans) {
  179. >             registry.addManagedBean(loadedMbean);
  180.           }
  181.       }

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:106: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.execute(ObjectReader)` indirectly reads without synchronization from `this.socket`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  104.                    * This is considered an asynchronous request
  105.                    */
  106. >                 if (ChannelData.sendAckAsync(msgs[i].getOptions())) sendAck(Constants.ACK_COMMAND);
  107.                   try {
  108.                       //process the message

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:99: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BioReplicationTask.execute(ObjectReader)` indirectly writes to field `xbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  97.   
  98.           if ( pkgcnt > 0 ) {
  99. >             ChannelMessage[] msgs = reader.execute();
  100.               for ( int i=0; i<msgs.length; i++ ) {
  101.                   /**

java/org/apache/catalina/servlets/CGIServlet.java:1157: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CGIServlet$CGIEnvironment.expandCGIScript()` reads without synchronization from `this.tmpDir`. Potentially races with write in method `CGIServlet$CGIEnvironment.setupFromContext(...)`.
 Reporting because this access may occur on a background thread.
  1155.                   srcPath.append(pathInfo);
  1156.                   is = context.getResourceAsStream(srcPath.toString());
  1157. >                 destPath.append(tmpDir);
  1158.                   destPath.append(pathInfo);
  1159.               } else {

java/org/apache/catalina/servlets/CGIServlet.java:1155: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CGIServlet$CGIEnvironment.expandCGIScript()` reads without synchronization from `this.pathInfo`. Potentially races with write in method `CGIServlet$CGIEnvironment.setupFromRequest(...)`.
 Reporting because this access may occur on a background thread.
  1153.               // paths depend on mapping
  1154.               if (cgiPathPrefix == null ) {
  1155. >                 srcPath.append(pathInfo);
  1156.                   is = context.getResourceAsStream(srcPath.toString());
  1157.                   destPath.append(tmpDir);

java/org/apache/catalina/servlets/CGIServlet.java:1156: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CGIServlet$CGIEnvironment.expandCGIScript()` reads without synchronization from `this.context`. Potentially races with write in method `CGIServlet$CGIEnvironment.setupFromContext(...)`.
 Reporting because this access may occur on a background thread.
  1154.               if (cgiPathPrefix == null ) {
  1155.                   srcPath.append(pathInfo);
  1156. >                 is = context.getResourceAsStream(srcPath.toString());
  1157.                   destPath.append(tmpDir);
  1158.                   destPath.append(pathInfo);

java/org/apache/catalina/ha/session/DeltaManager.java:1104: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.expireAllLocalSessions()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1102.       {
  1103.           long timeNow = System.currentTimeMillis();
  1104. >         Session sessions[] = findSessions();
  1105.           int expireDirect  = 0 ;
  1106.           int expireIndirect = 0 ;

java/org/apache/catalina/session/ManagerBase.java:1174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagerBase.expireSession(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1172.   
  1173.       public void expireSession( String sessionId ) {
  1174. >         Session s = sessions.get(sessionId);
  1175.           if (s == null) {
  1176.               if (log.isInfoEnabled()) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:721: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.failed(Throwable,java.nio.ByteBuffer[])` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.                       setError(ioe);
  720.                       writePending.release();
  721. >                     if (!endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.ERROR, true)) {
  722.                           close();
  723.                       }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:577: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.failed(Throwable,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  575.               socketBufferHandler = channel.getBufHandler();
  576.   
  577. >             this.readCompletionHandler = new CompletionHandler<Integer, ByteBuffer>() {
  578.                   @Override
  579.                   public void completed(Integer nBytes, ByteBuffer attachment) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:623: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.failed(Throwable,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  621.               };
  622.   
  623. >             this.writeCompletionHandler = new CompletionHandler<Integer, ByteBuffer>() {
  624.                   @Override
  625.                   public void completed(Integer nBytes, ByteBuffer attachment) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:677: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$4.failed(Throwable,Object)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  675.               };
  676.   
  677. >             gatheringWriteCompletionHandler = new CompletionHandler<Long, ByteBuffer[]>() {
  678.                   @Override
  679.                   public void completed(Long nBytes, ByteBuffer[] attachment) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:616: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.failed(Throwable,ByteBuffer)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  614.                           readPending.release();
  615.                           // If already closed, don't call onError and close again
  616. >                         getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.STOP, false);
  617.                       } else if (!getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.ERROR, true)) {
  618.                           close();

java/org/apache/tomcat/util/net/Nio2Endpoint.java:617: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$2.failed(Throwable,ByteBuffer)` indirectly writes to field `sc.socketWrapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  615.                           // If already closed, don't call onError and close again
  616.                           getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.STOP, false);
  617. >                     } else if (!getEndpoint().processSocket(Nio2SocketWrapper.this, SocketEvent.ERROR, true)) {
  618.                           close();
  619.                       }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:671: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Nio2Endpoint$Nio2SocketWrapper$3.failed(Throwable,ByteBuffer)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  669.                       setError(ioe);
  670.                       writePending.release();
  671. >                     if (!endpoint.processSocket(Nio2SocketWrapper.this, SocketEvent.ERROR, true)) {
  672.                           close();
  673.                       }

java/org/apache/catalina/core/StandardContext.java:4528: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.filterStart()` indirectly reads with synchronization from `this.logName`. Potentially races with unsynchronized write in method `StandardContext.filterStop()`.
 Reporting because this access may occur on a background thread.
  4526.               for (Entry<String,FilterDef> entry : filterDefs.entrySet()) {
  4527.                   String name = entry.getKey();
  4528. >                 if (getLogger().isDebugEnabled()) {
  4529.                       getLogger().debug(" Starting filter '" + name + "'");
  4530.                   }

java/org/apache/catalina/core/StandardContext.java:4519: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.filterStart()` indirectly writes to field `this.logName` outside of synchronization.
 Reporting because this access may occur on a background thread.
  4517.       public boolean filterStart() {
  4518.   
  4519. >         if (getLogger().isDebugEnabled()) {
  4520.               getLogger().debug("Starting filters");
  4521.           }

java/org/apache/catalina/core/StandardContext.java:4556: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.filterStop()` indirectly writes to field `this.logName` outside of synchronization.
 Reporting because this access may occur on a background thread.
  4554.       public boolean filterStop() {
  4555.   
  4556. >         if (getLogger().isDebugEnabled())
  4557.               getLogger().debug("Stopping filters");
  4558.   

java/org/apache/catalina/core/StandardContext.java:4562: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.filterStop()` indirectly reads with synchronization from `this.logName`. Potentially races with unsynchronized write in method `StandardContext.filterStop()`.
 Reporting because this access may occur on a background thread.
  4560.           synchronized (filterConfigs) {
  4561.               for (Entry<String, ApplicationFilterConfig> entry : filterConfigs.entrySet()) {
  4562. >                 if (getLogger().isDebugEnabled())
  4563.                       getLogger().debug(" Stopping filter '" + entry.getKey() + "'");
  4564.                   ApplicationFilterConfig filterConfig = entry.getValue();

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:390: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.finalize()` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  388.       protected void finalize() throws Throwable {
  389.           try {
  390. >             breakdown();
  391.           } finally {
  392.               super.finalize();

java/org/apache/catalina/core/StandardContext.java:3339: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.lang.String[] StandardContext.findApplicationListeners()` reads without synchronization from `this.applicationListeners`. Potentially races with write in method `StandardContext.addApplicationListener(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3337.       @Override
  3338.       public String[] findApplicationListeners() {
  3339. >         return applicationListeners;
  3340.       }
  3341.   

java/org/apache/catalina/loader/WebappClassLoaderBase.java:2303: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Class WebappClassLoaderBase.findClassInternal(String)` reads without synchronization from `this.resources`. Potentially races with write in method `WebappClassLoaderBase.setResources(...)`.
 Reporting because this access may occur on a background thread.
  2301.   
  2302.           if (entry == null) {
  2303. >             resource = resources.getClassLoaderResource(path);
  2304.   
  2305.               if (!resource.exists()) {

java/org/apache/catalina/loader/WebappClassLoaderBase.java:2299: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Class WebappClassLoaderBase.findClassInternal(String)` reads without synchronization from container `this.resourceEntries` via call to `get`. Potentially races with write in method `WebappClassLoaderBase.findClass(...)`.
 Reporting because this access may occur on a background thread.
  2297.           String path = binaryNameToPath(name, true);
  2298.   
  2299. >         ResourceEntry entry = resourceEntries.get(path);
  2300.           WebResource resource = null;
  2301.   

java/org/apache/catalina/core/StandardService.java:263: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.connector.Connector[] StandardService.findConnectors()` reads without synchronization from `this.connectors`. Potentially races with write in method `StandardService.addConnector(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  261.       @Override
  262.       public Connector[] findConnectors() {
  263. >         return connectors;
  264.       }
  265.   

java/org/apache/catalina/core/StandardContext.java:4582: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FilterConfig StandardContext.findFilterConfig(String)` reads without synchronization from container `this.filterConfigs` via call to `get`. Potentially races with write in method `StandardContext.filterStop()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4580.        */
  4581.       public FilterConfig findFilterConfig(String name) {
  4582. >         return filterConfigs.get(name);
  4583.       }
  4584.   

java/org/apache/catalina/loader/WebappClassLoaderBase.java:2496: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Class WebappClassLoaderBase.findLoadedClass0(String)` reads without synchronization from container `this.resourceEntries` via call to `get`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2494.           String path = binaryNameToPath(name, true);
  2495.   
  2496. >         ResourceEntry entry = resourceEntries.get(path);
  2497.           if (entry != null) {
  2498.               return entry.loadedClass;

java/org/apache/catalina/core/StandardContext.java:3474: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `MessageDestinationRef StandardContext.findMessageDestinationRef(String)` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3472.       @Deprecated
  3473.       public MessageDestinationRef findMessageDestinationRef(String name) {
  3474. >         return getNamingResources().findMessageDestinationRef(name);
  3475.       }
  3476.   

java/org/apache/catalina/core/StandardContext.java:3488: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `org.apache.tomcat.util.descriptor.web.MessageDestinationRef[] StandardContext.findMessageDestinationRefs()` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3486.       @Deprecated
  3487.       public MessageDestinationRef[] findMessageDestinationRefs() {
  3488. >         return getNamingResources().findMessageDestinationRefs();
  3489.       }
  3490.   

java/org/apache/catalina/core/StandardContext.java:3500: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardContext.findMimeMapping(String)` reads without synchronization from container `this.mimeMappings` via call to `get`. Potentially races with write in method `StandardContext.removeMimeMapping(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3498.       @Override
  3499.       public String findMimeMapping(String extension) {
  3500. >         return mimeMappings.get(extension.toLowerCase(Locale.ENGLISH));
  3501.       }
  3502.   

java/org/apache/catalina/core/StandardContext.java:5996: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardContext.findPostConstructMethod(String)` reads without synchronization from container `this.postConstructMethods` via call to `get`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5994.       @Override
  5995.       public String findPostConstructMethod(String clazz) {
  5996. >         return postConstructMethods.get(clazz);
  5997.       }
  5998.   

java/org/apache/catalina/core/StandardContext.java:6002: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardContext.findPreDestroyMethod(String)` reads without synchronization from container `this.preDestroyMethods` via call to `get`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  6000.       @Override
  6001.       public String findPreDestroyMethod(String clazz) {
  6002. >         return preDestroyMethods.get(clazz);
  6003.       }
  6004.   

java/org/apache/catalina/loader/WebappClassLoaderBase.java:941: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `URL WebappClassLoaderBase.findResource(String)` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  939.           if (resource.exists()) {
  940.               url = resource.getURL();
  941. >             trackLastModified(path, resource);
  942.           }
  943.   

java/org/apache/catalina/core/StandardWrapper.java:933: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardWrapper.findSecurityReference(String)` indirectly reads without synchronization from `this.parent`. Potentially races with write in method `StandardWrapper.setParent(...)`.
 Reporting because this access may occur on a background thread.
  931.   
  932.           // If not specified on the Wrapper, check the Context
  933. >         if (getParent() instanceof Context) {
  934.               Context context = (Context) getParent();
  935.               if (reference != null) {

java/org/apache/catalina/core/StandardServer.java:715: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.Service[] StandardServer.findServices()` reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  713.       @Override
  714.       public Service[] findServices() {
  715. >         return services;
  716.       }
  717.   

java/org/apache/catalina/session/ManagerBase.java:709: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session ManagerBase.findSession(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  707.               return null;
  708.           }
  709. >         return sessions.get(id);
  710.       }
  711.   

java/org/apache/catalina/session/PersistentManagerBase.java:471: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session PersistentManagerBase.findSession(String)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `PersistentManagerBase.removeSuper(...)`.
 Reporting because this access may occur on a background thread.
  469.       public Session findSession(String id) throws IOException {
  470.   
  471. >         Session session = super.findSession(id);
  472.           // OK, at this point, we're not sure if another thread is trying to
  473.           // remove the session or not so the only way around this is to lock it

java/org/apache/catalina/session/PersistentManagerBase.java:493: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session PersistentManagerBase.findSession(String)` indirectly reads without synchronization from `this.store`. Potentially races with write in method `PersistentManagerBase.setStore(...)`.
 Reporting because this access may occur on a background thread.
  491.   
  492.           // See if the Session is in the Store
  493. >         session = swapIn(id);
  494.           return session;
  495.       }

java/org/apache/catalina/ha/session/DeltaManager.java:807: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Member DeltaManager.findSessionMasterMember()` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  805.       protected Member findSessionMasterMember() {
  806.           Member mbr = null;
  807. >         Member mbrs[] = cluster.getMembers();
  808.           if(mbrs.length != 0 ) mbr = mbrs[0];
  809.           if(mbr == null && log.isWarnEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:715: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.Session[] ManagerBase.findSessions()` reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  713.       @Override
  714.       public Session[] findSessions() {
  715. >         return sessions.values().toArray(new Session[0]);
  716.       }
  717.   

java/org/apache/catalina/core/AsyncContextImpl.java:107: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.fireOnComplete()` reads without synchronization from `this.event`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  105.               for (AsyncListenerWrapper listener : listenersCopy) {
  106.                   try {
  107. >                     listener.fireOnComplete(event);
  108.                   } catch (Throwable t) {
  109.                       ExceptionUtils.handleThrowable(t);

java/org/apache/catalina/core/AsyncContextImpl.java:115: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.fireOnComplete()` indirectly writes to field `this.request.applicationRequest` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  113.               }
  114.           } finally {
  115. >             context.fireRequestDestroyEvent(request.getRequest());
  116.               clearServletRequestResponse();
  117.               this.context.decrementInProgressAsyncCount();

java/org/apache/catalina/core/AsyncContextImpl.java:103: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.fireOnComplete()` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  101.           listenersCopy.addAll(listeners);
  102.   
  103. >         ClassLoader oldCL = context.bind(Globals.IS_SECURITY_ENABLED, null);
  104.           try {
  105.               for (AsyncListenerWrapper listener : listenersCopy) {

java/org/apache/catalina/core/StandardContext.java:5925: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.fireRequestDestroyEvent(ServletRequest)` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5923.   
  5924.               ServletRequestEvent event =
  5925. >                 new ServletRequestEvent(getServletContext(), request);
  5926.   
  5927.               for (int i = 0; i < instances.length; i++) {

java/org/apache/catalina/core/StandardContext.java:5920: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.fireRequestDestroyEvent(ServletRequest)` indirectly reads without synchronization from container `this.applicationEventListenersList` via call to `toArray`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5918.       @Override
  5919.       public boolean fireRequestDestroyEvent(ServletRequest request) {
  5920. >         Object instances[] = getApplicationEventListeners();
  5921.   
  5922.           if ((instances != null) && (instances.length > 0)) {

java/org/apache/catalina/core/StandardContext.java:5892: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.fireRequestInitEvent(ServletRequest)` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5890.   
  5891.               ServletRequestEvent event =
  5892. >                     new ServletRequestEvent(getServletContext(), request);
  5893.   
  5894.               for (int i = 0; i < instances.length; i++) {

java/org/apache/catalina/core/StandardContext.java:5887: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.fireRequestInitEvent(ServletRequest)` indirectly reads without synchronization from container `this.applicationEventListenersList` via call to `toArray`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5885.       public boolean fireRequestInitEvent(ServletRequest request) {
  5886.   
  5887. >         Object instances[] = getApplicationEventListeners();
  5888.   
  5889.           if ((instances != null) && (instances.length > 0)) {

java/org/apache/catalina/session/StandardSession.java:1729: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardSession.fireSessionEvent(String,Object)` reads without synchronization from `this.listeners`. Potentially races with write in method `StandardSession.doReadObject(...)`.
 Reporting because this access may occur on a background thread.
  1727.        */
  1728.       public void fireSessionEvent(String type, Object data) {
  1729. >         if (listeners.size() < 1)
  1730.               return;
  1731.           SessionEvent event = new SessionEvent(this, type, data);

java/org/apache/catalina/startup/ContextConfig.java:618: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.fixDocBase()` indirectly writes to field `this.context.originalDocBase` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  616.                   docBaseAbsoluteFile = new File(docBaseAbsolute);
  617.                   if (context instanceof StandardContext) {
  618. >                     ((StandardContext) context).setOriginalDocBase(originalDocBase);
  619.                   }
  620.               } else {

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:1027: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase$WsOutputStream.flush()` indirectly writes to field `this.endpoint.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1025.               // empty message.
  1026.               if (buffer.position() > 0) {
  1027. >                 doWrite(false);
  1028.               }
  1029.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:121: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.flushBatch()` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  119.       @Override
  120.       public void flushBatch() throws IOException {
  121. >         sendMessageBlock(Constants.INTERNAL_OPCODE_FLUSH, null, true);
  122.       }
  123.   

java/org/apache/jasper/compiler/AntCompiler.java:222: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AntCompiler.generateClass(Map)` indirectly writes to field `this.ctxt.javaPath` outside of synchronization.
 Reporting because this access may occur on a background thread.
  220.           PatternSet.NameEntry includes = javac.createInclude();
  221.   
  222. >         includes.setName(ctxt.getJavaPath());
  223.           info.append("    include="+ ctxt.getJavaPath() + "\n" );
  224.   

java/org/apache/jasper/compiler/AntCompiler.java:143: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AntCompiler.generateClass(Map)` indirectly reads without synchronization from `this.project`. Potentially races with write in method `AntCompiler.getProject()`.
 Reporting because this access may occur on a background thread.
  141.   
  142.           // Initializing javac task
  143. >         getProject();
  144.           Javac javac = (Javac) project.createTask("javac");
  145.   

java/org/apache/jasper/compiler/AntCompiler.java:130: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AntCompiler.generateClass(Map)` indirectly writes to field `this.ctxt.baseUrl` outside of synchronization.
 Reporting because this access may occur on a background thread.
  128.   
  129.           String javaEncoding = ctxt.getOptions().getJavaEncoding();
  130. >         String javaFileName = ctxt.getServletJavaFileName();
  131.           String classpath = ctxt.getClassPath();
  132.   

java/org/apache/jasper/compiler/AntCompiler.java:277: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AntCompiler.generateClass(Map)` writes to field `this.project` outside of synchronization.
 Reporting because this access may occur on a background thread.
  275.   
  276.           logger = null;
  277. >         project = null;
  278.   
  279.           if (ctxt.isPrototypeMode()) {

java/org/apache/jasper/compiler/AntCompiler.java:241: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AntCompiler.generateClass(Map)` reads without synchronization from `this.logger`. Potentially races with write in method `AntCompiler.getProject()`.
 Reporting because this access may occur on a background thread.
  239.           }
  240.   
  241. >         errorReport.append(logger.getReport());
  242.   
  243.           // Stop capturing the System.err output for this thread

java/org/apache/jasper/compiler/AntCompiler.java:276: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AntCompiler.generateClass(Map)` writes to field `this.logger` outside of synchronization.
 Reporting because this access may occur on a background thread.
  274.           }
  275.   
  276. >         logger = null;
  277.           project = null;
  278.   

java/org/apache/catalina/authenticator/DigestAuthenticator.java:313: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestAuthenticator.generateNonce(Request)` reads without synchronization from `this.nonces`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because this access may occur on a background thread.
  311.   
  312.           NonceInfo info = new NonceInfo(currentTime, getNonceCountWindowSize());
  313. >         synchronized (nonces) {
  314.               nonces.put(nonce, info);
  315.           }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:312: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestAuthenticator.generateNonce(Request)` indirectly reads without synchronization from `this.nonceCountWindowSize`. Potentially races with write in method `DigestAuthenticator.setNonceCountWindowSize(...)`.
 Reporting because this access may occur on a background thread.
  310.           String nonce = currentTime + ":" + MD5Encoder.encode(buffer);
  311.   
  312. >         NonceInfo info = new NonceInfo(currentTime, getNonceCountWindowSize());
  313.           synchronized (nonces) {
  314.               nonces.put(nonce, info);

java/org/apache/catalina/authenticator/DigestAuthenticator.java:306: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String DigestAuthenticator.generateNonce(Request)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  304.   
  305.           String ipTimeKey =
  306. >             request.getRemoteAddr() + ":" + currentTime + ":" + getKey();
  307.   
  308.           byte[] buffer = ConcurrentMessageDigest.digestMD5(

java/org/apache/catalina/session/ManagerBase.java:860: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.generateSessionId()` reads without synchronization from container `this.sessions` via call to `containsKey`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  858.               result = sessionIdGenerator.generateSessionId();
  859.   
  860. >         } while (sessions.containsKey(result));
  861.   
  862.           return result;

java/org/apache/jasper/JspC.java:1158: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JspC.generateWebMapping(String,JspCompilationContext)` indirectly writes to field `clctxt.className` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1156.           }
  1157.   
  1158. >         String className = clctxt.getServletClassName();
  1159.           String packageName = clctxt.getServletPackageName();
  1160.   

java/org/apache/jasper/JspC.java:1168: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspC.generateWebMapping(String,JspCompilationContext)` reads without synchronization from `this.servletout`. Potentially races with write in method `JspC.execute()`.
 Reporting because this access may occur on a background thread.
  1166.           }
  1167.   
  1168. >         if (servletout != null) {
  1169.               synchronized(servletout) {
  1170.                   servletout.write("\n    <servlet>\n        <servlet-name>");

java/org/apache/jasper/JspC.java:1177: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspC.generateWebMapping(String,JspCompilationContext)` reads without synchronization from `this.mappingout`. Potentially races with write in method `JspC.execute()`.
 Reporting because this access may occur on a background thread.
  1175.               }
  1176.           }
  1177. >         if (mappingout != null) {
  1178.               synchronized(mappingout) {
  1179.                   mappingout.write("\n    <servlet-mapping>\n        <servlet-name>");

java/org/apache/jasper/runtime/TagHandlerPool.java:112: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Tag TagHandlerPool.get(Class)` reads without synchronization from `this.instanceManager`. Potentially races with write in method `TagHandlerPool.init(...)`.
 Reporting because this access may occur on a background thread.
  110.           try {
  111.               if (Constants.USE_INSTANCE_MANAGER_FOR_TAGS) {
  112. >                 return (Tag) instanceManager.newInstance(
  113.                           handlerClass.getName(), handlerClass.getClassLoader());
  114.               } else {

java/javax/el/BeanELResolver.java:349: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object BeanELResolver$ConcurrentCache.get(Object)` reads without synchronization from container `this.eden` via call to `get`. Potentially races with write in method `BeanELResolver$ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  347.   
  348.           public V get(K key) {
  349. >             V value = this.eden.get(key);
  350.               if (value == null) {
  351.                   synchronized (longterm) {

java/javax/el/BeanELResolver.java:355: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object BeanELResolver$ConcurrentCache.get(Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  353.                   }
  354.                   if (value != null) {
  355. >                     this.eden.put(key, value);
  356.                   }
  357.               }

java/org/apache/el/util/ConcurrentCache.java:44: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object ConcurrentCache.get(Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  42.               }
  43.               if (v != null) {
  44. >                 this.eden.put(k, v);
  45.               }
  46.           }

java/org/apache/el/util/ConcurrentCache.java:38: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object ConcurrentCache.get(Object)` reads without synchronization from container `this.eden` via call to `get`. Potentially races with write in method `ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  36.   
  37.       public V get(K k) {
  38. >         V v = this.eden.get(k);
  39.           if (v == null) {
  40.               synchronized (longterm) {

java/org/apache/tomcat/util/collections/ConcurrentCache.java:44: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object ConcurrentCache.get(Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  42.               }
  43.               if (v != null) {
  44. >                 this.eden.put(k, v);
  45.               }
  46.           }

java/org/apache/tomcat/util/collections/ConcurrentCache.java:38: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object ConcurrentCache.get(Object)` reads without synchronization from container `this.eden` via call to `get`. Potentially races with write in method `ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  36.   
  37.       public V get(K k) {
  38. >         V v = this.eden.get(k);
  39.           if (v == null) {
  40.               synchronized (longterm) {

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:529: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.security.cert.X509Certificate[] OpenSSLContext.getAcceptedIssuers()` reads without synchronization from `this.x509TrustManager`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  527.       public X509Certificate[] getAcceptedIssuers() {
  528.           X509Certificate[] acceptedCerts = null;
  529. >         if (x509TrustManager != null) {
  530.               acceptedCerts = x509TrustManager.getAcceptedIssuers();
  531.           }

java/org/apache/tomcat/util/buf/StringCache.java:187: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int StringCache.getAccessCount()` reads without synchronization from `buf.StringCache.accessCount`. Potentially races with write in method `StringCache.reset()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  185.        */
  186.       public int getAccessCount() {
  187. >         return accessCount;
  188.       }
  189.   

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:304: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int MessageDispatchInterceptor.getActiveCount()` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  302.       @Override
  303.       public int getActiveCount() {
  304. >         if (executor instanceof ThreadPoolExecutor) {
  305.               return ((ThreadPoolExecutor) executor).getActiveCount();
  306.           } else {

java/org/apache/catalina/session/ManagerBase.java:928: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int ManagerBase.getActiveSessions()` reads without synchronization from container `this.sessions` via call to `size`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  926.       @Override
  927.       public int getActiveSessions() {
  928. >         return sessions.size();
  929.       }
  930.   

java/org/apache/catalina/ha/session/BackupManager.java:265: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int BackupManager.getActiveSessionsFull()` reads without synchronization from `this.sessions`. Potentially races with write in method `BackupManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  263.       @Override
  264.       public int getActiveSessionsFull() {
  265. >         LazyReplicatedMap<String,Session> map =
  266.                   (LazyReplicatedMap<String,Session>)sessions;
  267.           return map.sizeFull();

java/org/apache/catalina/session/PersistentManagerBase.java:637: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PersistentManagerBase.getActiveSessionsFull()` indirectly reads without synchronization from container `this.sessions` via call to `size`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  635.       public int getActiveSessionsFull() {
  636.           // In memory session count
  637. >         int result = getActiveSessions();
  638.           try {
  639.               // Store session count

java/org/apache/catalina/tribes/transport/ReceiverBase.java:291: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String ReceiverBase.getAddress()` indirectly writes to field `this.bind` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  289.   
  290.       public String getAddress() {
  291. >         getBind();
  292.           return this.host;
  293.       }

java/org/apache/catalina/core/StandardContext.java:1313: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.lang.Object[] StandardContext.getApplicationEventListeners()` reads without synchronization from container `this.applicationEventListenersList` via call to `toArray`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1311.       @Override
  1312.       public Object[] getApplicationEventListeners() {
  1313. >         return applicationEventListenersList.toArray();
  1314.       }
  1315.   

java/org/apache/catalina/core/StandardContext.java:1346: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.lang.Object[] StandardContext.getApplicationLifecycleListeners()` reads without synchronization from `this.applicationLifecycleListenersObjects`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1344.       @Override
  1345.       public Object[] getApplicationLifecycleListeners() {
  1346. >         return applicationLifecycleListenersObjects;
  1347.       }
  1348.   

java/org/apache/catalina/authenticator/SingleSignOnEntry.java:129: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String SingleSignOnEntry.getAuthType()` reads without synchronization from `this.authType`. Potentially races with write in method `SingleSignOnEntry.updateCredentials(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  127.        */
  128.       public String getAuthType() {
  129. >         return this.authType;
  130.       }
  131.   

java/org/apache/catalina/core/StandardWrapper.java:296: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long StandardWrapper.getAvailable()` reads without synchronization from `this.available`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  294.       @Override
  295.       public long getAvailable() {
  296. >         return this.available;
  297.       }
  298.   

java/org/apache/catalina/tribes/transport/ReceiverBase.java:174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InetAddress ReceiverBase.getBind()` reads without synchronization from `this.host`. Potentially races with write in method `ReceiverBase.bind(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  172.           if (bind == null) {
  173.               try {
  174. >                 if ("auto".equals(host)) {
  175.                       host = java.net.InetAddress.getLocalHost().getHostAddress();
  176.                   }

java/org/apache/catalina/tribes/transport/ReceiverBase.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InetAddress ReceiverBase.getBind()` reads without synchronization from `this.bind`. Potentially races with write in method `ReceiverBase.bind(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.        */
  171.       public InetAddress getBind() {
  172. >         if (bind == null) {
  173.               try {
  174.                   if ("auto".equals(host)) {

java/org/apache/catalina/tribes/transport/ReceiverBase.java:175: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `InetAddress ReceiverBase.getBind()` writes to field `this.host` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  173.               try {
  174.                   if ("auto".equals(host)) {
  175. >                     host = java.net.InetAddress.getLocalHost().getHostAddress();
  176.                   }
  177.                   if (log.isDebugEnabled())

java/org/apache/catalina/tribes/transport/ReceiverBase.java:179: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `InetAddress ReceiverBase.getBind()` writes to field `this.bind` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  177.                   if (log.isDebugEnabled())
  178.                       log.debug("Starting replication listener on address:"+ host);
  179. >                 bind = java.net.InetAddress.getByName(host);
  180.               } catch (IOException ioe) {
  181.                   log.error(sm.getString("receiverBase.bind.failed", host), ioe);

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:511: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `java.security.cert.X509Certificate[] OpenSSLContext.getCertificateChain(String)` indirectly reads without synchronization from `this.certificate.certificateKeyManager`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  509.       public X509Certificate[] getCertificateChain(String alias) {
  510.           X509Certificate[] chain = null;
  511. >         X509KeyManager x509KeyManager = certificate.getCertificateKeyManager();
  512.           if (x509KeyManager != null) {
  513.               if (alias == null) {

java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java:130: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Channel ReplicationTransmitter.getChannel()` reads without synchronization from `this.channel`. Potentially races with write in method `ReplicationTransmitter.stop()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  128.       @Override
  129.       public Channel getChannel() {
  130. >         return channel;
  131.       }
  132.   

java/org/apache/catalina/core/StandardContext.java:1442: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StandardContext.getCharset(Locale)` indirectly writes to field `this.charsetMapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1440.       @Override
  1441.       public String getCharset(Locale locale) {
  1442. >         return getCharsetMapper().getCharset(locale);
  1443.       }
  1444.   

java/org/apache/catalina/core/StandardContext.java:1408: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CharsetMapper StandardContext.getCharsetMapper()` reads without synchronization from `this.charsetMapper`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1406.   
  1407.           // Create a mapper the first time it is requested
  1408. >         if (this.charsetMapper == null) {
  1409.               try {
  1410.                   Class<?> clazz = Class.forName(charsetMapperClass);

java/org/apache/catalina/core/StandardContext.java:1410: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CharsetMapper StandardContext.getCharsetMapper()` reads without synchronization from `this.charsetMapperClass`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1408.           if (this.charsetMapper == null) {
  1409.               try {
  1410. >                 Class<?> clazz = Class.forName(charsetMapperClass);
  1411.                   this.charsetMapper = (CharsetMapper) clazz.getConstructor().newInstance();
  1412.               } catch (Throwable t) {

java/org/apache/catalina/core/StandardContext.java:1411: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `CharsetMapper StandardContext.getCharsetMapper()` writes to field `this.charsetMapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1409.               try {
  1410.                   Class<?> clazz = Class.forName(charsetMapperClass);
  1411. >                 this.charsetMapper = (CharsetMapper) clazz.getConstructor().newInstance();
  1412.               } catch (Throwable t) {
  1413.                   ExceptionUtils.handleThrowable(t);

java/org/apache/catalina/core/StandardContext.java:2547: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardContext.getCharsetMapperClass()` reads without synchronization from `this.charsetMapperClass`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2545.        */
  2546.       public String getCharsetMapperClass() {
  2547. >         return this.charsetMapperClass;
  2548.       }
  2549.   

java/org/apache/catalina/core/ContainerBase.java:1254: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `javax.management.ObjectName[] ContainerBase.getChildren()` reads without synchronization from container `this.children` via call to `values`. Potentially races with write in method `ContainerBase.removeChild(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1252.       public ObjectName[] getChildren() {
  1253.           List<ObjectName> names = new ArrayList<>(children.size());
  1254. >         for (Container next : children.values()) {
  1255.               if (next instanceof ContainerBase) {
  1256.                   names.add(next.getObjectName());

java/org/apache/tomcat/util/net/openssl/OpenSSLEngine.java:1370: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String OpenSSLEngine$OpenSSLSession.getCipherSuite()` indirectly writes to field `ciphers.OpenSSLCipherConfigurationParser.initialized` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1368.                       ciphers = SSL.getCipherForSSL(ssl);
  1369.                   }
  1370. >                 String c = OpenSSLCipherConfigurationParser.openSSLToJsse(ciphers);
  1371.                   if (c != null) {
  1372.                       cipher = c;

java/org/apache/catalina/core/StandardWrapper.java:1465: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int StandardWrapper.getClassLoadTime()` reads without synchronization from `this.classLoadTime`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1463.   
  1464.       public int getClassLoadTime() {
  1465. >         return classLoadTime;
  1466.       }
  1467.   

java/org/apache/tomcat/util/modeler/ManagedBean.java:114: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.getClassName()` reads without synchronization from `this.className`. Potentially races with write in method `ManagedBean.setClassName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  112.        */
  113.       public String getClassName() {
  114. >         return this.className;
  115.       }
  116.   

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:63: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CatalinaCluster ClusterSingleSignOn.getCluster()` reads without synchronization from `this.cluster`. Potentially races with write in method `ClusterSingleSignOn.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  61.       private CatalinaCluster cluster = null;
  62.       @Override
  63. >     public CatalinaCluster getCluster() { return cluster; }
  64.       @Override
  65.       public void setCluster(CatalinaCluster cluster) {

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:248: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CatalinaCluster JvmRouteBinderValve.getCluster()` reads without synchronization from `this.cluster`. Potentially races with write in method `JvmRouteBinderValve.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  246.       @Override
  247.       public CatalinaCluster getCluster() {
  248. >         return cluster;
  249.       }
  250.   

java/org/apache/catalina/ha/tcp/ReplicationValve.java:133: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CatalinaCluster ReplicationValve.getCluster()` reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  131.       @Override
  132.       public CatalinaCluster getCluster() {
  133. >         return cluster;
  134.       }
  135.   

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:330: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long MessageDispatchInterceptor.getCompletedTaskCount()` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.       @Override
  329.       public long getCompletedTaskCount() {
  330. >         if (executor instanceof ThreadPoolExecutor) {
  331.               return ((ThreadPoolExecutor) executor).getCompletedTaskCount();
  332.           } else {

java/org/apache/catalina/realm/JAASRealm.java:635: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Configuration JAASRealm.getConfig()` reads without synchronization from `this.configFile`. Potentially races with write in method `JAASRealm.setConfigFile(...)`.
 Reporting because this access may occur on a background thread.
  633.       protected Configuration getConfig() {
  634.           // Local copy to avoid possible NPE due to concurrent change
  635. >         String configFile = this.configFile;
  636.           try {
  637.               if (jaasConfigurationLoaded) {

java/org/apache/catalina/valves/rewrite/RewriteValve.java:203: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RewriteValve.getConfiguration()` reads without synchronization from `this.rules`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  201.               buffer.append("\r\n");
  202.           }
  203. >         for (int i = 0; i < rules.length; i++) {
  204.               for (int j = 0; j < rules[i].getConditions().length; j++) {
  205.                   buffer.append(rules[i].getConditions()[j].toString()).append("\r\n");

java/org/apache/catalina/valves/rewrite/RewriteValve.java:207: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RewriteValve.getConfiguration()` indirectly reads without synchronization from `this.rules.[_].patternString`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  205.                   buffer.append(rules[i].getConditions()[j].toString()).append("\r\n");
  206.               }
  207. >             buffer.append(rules[i].toString()).append("\r\n").append("\r\n");
  208.           }
  209.           return buffer.toString();

java/org/apache/catalina/valves/rewrite/RewriteValve.java:200: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String RewriteValve.getConfiguration()` reads without synchronization from container `this.mapsConfiguration` via call to `size`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  198.               buffer.append(mapConfiguration).append("\r\n");
  199.           }
  200. >         if (mapsConfiguration.size() > 0) {
  201.               buffer.append("\r\n");
  202.           }

java/org/apache/catalina/core/StandardContext.java:1460: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.getConfigured()` reads without synchronization from `this.configured`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1458.       @Override
  1459.       public boolean getConfigured() {
  1460. >         return this.configured;
  1461.       }
  1462.   

java/org/apache/catalina/session/JDBCStore.java:862: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCStore.getConnection()` indirectly writes to field `this.dataSource` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  860.           Connection conn = null;
  861.           try {
  862. >             conn = open();
  863.               if (conn == null || conn.isClosed()) {
  864.                   manager.getContext().getLogger().info(sm.getString(getStoreName() + ".checkConnectionDBClosed"));

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:753: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection BasicDataSource.getConnection()` indirectly reads without synchronization from `this.closed`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  751.               }
  752.           }
  753. >         return createDataSource().getConnection();
  754.       }
  755.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:137: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PooledConnectionManager PerUserPoolDataSource.getConnectionManager(UserPassKey)` reads without synchronization from container `this.managers` via call to `get`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  135.       @Override
  136.       protected PooledConnectionManager getConnectionManager(final UserPassKey upKey) {
  137. >         return managers.get(getPoolKey(upKey.getUsername()));
  138.       }
  139.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java:154: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PooledConnectionManager SharedPoolDataSource.getConnectionManager(UserPassKey)` reads without synchronization from `this.factory`. Potentially races with write in method `SharedPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  152.       @Override
  153.       protected PooledConnectionManager getConnectionManager(final UserPassKey upkey) {
  154. >         return factory;
  155.       }
  156.   

java/org/apache/catalina/core/StandardService.java:240: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `javax.management.ObjectName[] StandardService.getConnectorNames()` reads without synchronization from `this.connectors`. Potentially races with write in method `StandardService.addConnector(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  238.   
  239.       public ObjectName[] getConnectorNames() {
  240. >         ObjectName results[] = new ObjectName[connectors.length];
  241.           for (int i=0; i<results.length; i++) {
  242.               results[i] = connectors[i].getObjectName();

java/org/apache/catalina/startup/HostConfig.java:173: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String HostConfig.getContextClass()` reads without synchronization from `this.contextClass`. Potentially races with write in method `HostConfig.setContextClass(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  171.        */
  172.       public String getContextClass() {
  173. >         return this.contextClass;
  174.       }
  175.   

java/org/apache/catalina/core/StandardContext.java:1001: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CookieProcessor StandardContext.getCookieProcessor()` reads without synchronization from `this.cookieProcessor`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  999.       @Override
  1000.       public CookieProcessor getCookieProcessor() {
  1001. >         return cookieProcessor;
  1002.       }
  1003.   

java/org/apache/catalina/ha/session/DeltaManager.java:271: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int DeltaManager.getCounterNoStateTransfered()` reads without synchronization from `this.counterNoStateTransfered`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  269.        */
  270.       public int getCounterNoStateTransfered() {
  271. >         return counterNoStateTransfered;
  272.       }
  273.   

java/org/apache/catalina/ha/session/DeltaManager.java:192: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_ALL_SESSION_DATA()` reads without synchronization from `this.counterReceive_EVT_ALL_SESSION_DATA`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  190.        */
  191.       public long getCounterReceive_EVT_ALL_SESSION_DATA() {
  192. >         return counterReceive_EVT_ALL_SESSION_DATA;
  193.       }
  194.   

java/org/apache/catalina/ha/session/DeltaManager.java:249: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER()` reads without synchronization from `this.counterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  247.        */
  248.       public long getCounterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER() {
  249. >         return counterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER;
  250.       }
  251.   

java/org/apache/catalina/ha/session/DeltaManager.java:235: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int DeltaManager.getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE()` reads without synchronization from `this.counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  233.        */
  234.       public int getCounterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
  235. >         return counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE;
  236.       }
  237.   

java/org/apache/catalina/ha/session/DeltaManager.java:242: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_CHANGE_SESSION_ID()` reads without synchronization from `this.counterReceive_EVT_CHANGE_SESSION_ID`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  240.        */
  241.       public long getCounterReceive_EVT_CHANGE_SESSION_ID() {
  242. >         return counterReceive_EVT_CHANGE_SESSION_ID;
  243.       }
  244.   

java/org/apache/catalina/ha/session/DeltaManager.java:199: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_GET_ALL_SESSIONS()` reads without synchronization from `this.counterReceive_EVT_GET_ALL_SESSIONS`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  197.        */
  198.       public long getCounterReceive_EVT_GET_ALL_SESSIONS() {
  199. >         return counterReceive_EVT_GET_ALL_SESSIONS;
  200.       }
  201.   

java/org/apache/catalina/ha/session/DeltaManager.java:206: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_SESSION_ACCESSED()` reads without synchronization from `this.counterReceive_EVT_SESSION_ACCESSED`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  204.        */
  205.       public long getCounterReceive_EVT_SESSION_ACCESSED() {
  206. >         return counterReceive_EVT_SESSION_ACCESSED;
  207.       }
  208.   

java/org/apache/catalina/ha/session/DeltaManager.java:213: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_SESSION_CREATED()` reads without synchronization from `this.counterReceive_EVT_SESSION_CREATED`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  211.        */
  212.       public long getCounterReceive_EVT_SESSION_CREATED() {
  213. >         return counterReceive_EVT_SESSION_CREATED;
  214.       }
  215.   

java/org/apache/catalina/ha/session/DeltaManager.java:220: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_SESSION_DELTA()` reads without synchronization from `this.counterReceive_EVT_SESSION_DELTA`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  218.        */
  219.       public long getCounterReceive_EVT_SESSION_DELTA() {
  220. >         return counterReceive_EVT_SESSION_DELTA;
  221.       }
  222.   

java/org/apache/catalina/ha/session/DeltaManager.java:227: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterReceive_EVT_SESSION_EXPIRED()` reads without synchronization from `this.counterReceive_EVT_SESSION_EXPIRED`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  225.        */
  226.       public long getCounterReceive_EVT_SESSION_EXPIRED() {
  227. >         return counterReceive_EVT_SESSION_EXPIRED;
  228.       }
  229.   

java/org/apache/catalina/ha/session/DeltaManager.java:171: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_ALL_SESSION_DATA()` reads without synchronization from `this.counterSend_EVT_ALL_SESSION_DATA`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  169.        */
  170.       public long getCounterSend_EVT_ALL_SESSION_DATA() {
  171. >         return counterSend_EVT_ALL_SESSION_DATA;
  172.       }
  173.   

java/org/apache/catalina/ha/session/DeltaManager.java:178: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int DeltaManager.getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE()` reads without synchronization from `this.counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  176.        */
  177.       public int getCounterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE() {
  178. >         return counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE;
  179.       }
  180.   

java/org/apache/catalina/ha/session/DeltaManager.java:185: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_CHANGE_SESSION_ID()` reads without synchronization from `this.counterSend_EVT_CHANGE_SESSION_ID`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  183.        */
  184.       public long getCounterSend_EVT_CHANGE_SESSION_ID() {
  185. >         return counterSend_EVT_CHANGE_SESSION_ID;
  186.       }
  187.   

java/org/apache/catalina/ha/session/DeltaManager.java:136: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_GET_ALL_SESSIONS()` reads without synchronization from `this.counterSend_EVT_GET_ALL_SESSIONS`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  134.        */
  135.       public long getCounterSend_EVT_GET_ALL_SESSIONS() {
  136. >         return counterSend_EVT_GET_ALL_SESSIONS;
  137.       }
  138.   

java/org/apache/catalina/ha/session/DeltaManager.java:143: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_SESSION_ACCESSED()` reads without synchronization from `this.counterSend_EVT_SESSION_ACCESSED`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  141.        */
  142.       public long getCounterSend_EVT_SESSION_ACCESSED() {
  143. >         return counterSend_EVT_SESSION_ACCESSED;
  144.       }
  145.   

java/org/apache/catalina/ha/session/DeltaManager.java:150: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_SESSION_CREATED()` reads without synchronization from `this.counterSend_EVT_SESSION_CREATED`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  148.        */
  149.       public long getCounterSend_EVT_SESSION_CREATED() {
  150. >         return counterSend_EVT_SESSION_CREATED;
  151.       }
  152.   

java/org/apache/catalina/ha/session/DeltaManager.java:157: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_SESSION_DELTA()` reads without synchronization from `this.counterSend_EVT_SESSION_DELTA`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  155.        */
  156.       public long getCounterSend_EVT_SESSION_DELTA() {
  157. >         return counterSend_EVT_SESSION_DELTA;
  158.       }
  159.   

java/org/apache/catalina/ha/session/DeltaManager.java:164: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getCounterSend_EVT_SESSION_EXPIRED()` reads without synchronization from `this.counterSend_EVT_SESSION_EXPIRED`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.        */
  163.       public long getCounterSend_EVT_SESSION_EXPIRED() {
  164. >         return counterSend_EVT_SESSION_EXPIRED;
  165.       }
  166.   

java/org/apache/catalina/session/ManagerBase.java:1229: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.getCreationTime(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1227.   
  1228.       public String getCreationTime( String sessionId ) {
  1229. >         Session s = sessions.get(sessionId);
  1230.           if (s == null) {
  1231.               if (log.isInfoEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:1240: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long ManagerBase.getCreationTimestamp(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1238.   
  1239.       public long getCreationTimestamp( String sessionId ) {
  1240. >         Session s = sessions.get(sessionId);
  1241.           if (s == null) {
  1242.               if (log.isInfoEnabled()) {

java/org/apache/catalina/valves/JDBCAccessLogValve.java:678: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long JDBCAccessLogValve.getCurrentTimeMillis()` reads without synchronization from `this.currentTimeMillis`. Potentially races with write in method `JDBCAccessLogValve.log(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  676.       public long getCurrentTimeMillis() {
  677.           long systime  =  System.currentTimeMillis();
  678. >         if ((systime - currentTimeMillis) > 1000) {
  679.               currentTimeMillis  =  new java.util.Date(systime).getTime();
  680.           }

java/org/apache/catalina/valves/JDBCAccessLogValve.java:679: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `long JDBCAccessLogValve.getCurrentTimeMillis()` writes to field `this.currentTimeMillis` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  677.           long systime  =  System.currentTimeMillis();
  678.           if ((systime - currentTimeMillis) > 1000) {
  679. >             currentTimeMillis  =  new java.util.Date(systime).getTime();
  680.           }
  681.           return currentTimeMillis;

java/org/apache/catalina/startup/ContextConfig.java:250: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ContextConfig.getDefaultWebXml()` reads without synchronization from `this.defaultWebXml`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  248.        */
  249.       public String getDefaultWebXml() {
  250. >         if (defaultWebXml == null) {
  251.               defaultWebXml = Constants.DefaultWebXml;
  252.           }

java/org/apache/catalina/startup/ContextConfig.java:251: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String ContextConfig.getDefaultWebXml()` writes to field `this.defaultWebXml` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  249.       public String getDefaultWebXml() {
  250.           if (defaultWebXml == null) {
  251. >             defaultWebXml = Constants.DefaultWebXml;
  252.           }
  253.           return defaultWebXml;

java/org/apache/catalina/startup/HostConfig.java:351: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long HostConfig.getDeploymentTime(String)` reads without synchronization from container `this.deployed` via call to `get`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  349.        */
  350.       public long getDeploymentTime(String name) {
  351. >         DeployedApplication app = deployed.get(name);
  352.           if (app == null) {
  353.               return 0L;

java/org/apache/tomcat/util/modeler/ManagedBean.java:132: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.getDescription()` reads without synchronization from `this.description`. Potentially races with write in method `ManagedBean.setDescription(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  130.        */
  131.       public String getDescription() {
  132. >         return this.description;
  133.       }
  134.   

java/org/apache/catalina/core/StandardContext.java:1770: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.getDistributable()` reads without synchronization from `this.distributable`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1768.       @Override
  1769.       public boolean getDistributable() {
  1770. >         return this.distributable;
  1771.       }
  1772.   

java/org/apache/catalina/core/StandardServer.java:1126: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardServer.getDomainInternal()` indirectly reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1124.           String domain = null;
  1125.   
  1126. >         Service[] services = findServices();
  1127.           if (services.length > 0) {
  1128.               Service service = services[0];

java/org/apache/catalina/valves/AccessLogValve.java:319: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String AccessLogValve.getFileDateFormat()` reads without synchronization from `this.fileDateFormat`. Potentially races with write in method `AccessLogValve.setFileDateFormat(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  317.        */
  318.       public String getFileDateFormat() {
  319. >         return fileDateFormat;
  320.       }
  321.   

java/org/apache/catalina/tribes/group/GroupChannel.java:539: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ChannelInterceptor GroupChannel.getFirstInterceptor()` reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  537.        */
  538.       public ChannelInterceptor getFirstInterceptor() {
  539. >         if (interceptors != null) return interceptors;
  540.           else return coordinator;
  541.       }

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:81: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FragmentationInterceptor$FragCollection FragmentationInterceptor.getFragCollection(FragmentationInterceptor$FragKey,ChannelMessage)` reads without synchronization from container `this.fragpieces` via call to `get`. Potentially races with write in method `FragmentationInterceptor.getFragCollection(...)`.
 Reporting because this access may occur on a background thread.
  79.   
  80.       public FragCollection getFragCollection(FragKey key, ChannelMessage msg) {
  81. >         FragCollection coll = fragpieces.get(key);
  82.           if ( coll == null ) {
  83.               synchronized (fragpieces) {

java/org/apache/catalina/startup/ContextConfig.java:1777: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `InputSource ContextConfig.getGlobalWebXmlSource()` writes to field `this.defaultWebXml` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1775.           // Is a default web.xml specified for the Context?
  1776.           if (defaultWebXml == null && context instanceof StandardContext) {
  1777. >             defaultWebXml = ((StandardContext) context).getDefaultWebXml();
  1778.           }
  1779.           // Set the default if we don't have any overrides

java/org/apache/catalina/startup/ContextConfig.java:1776: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputSource ContextConfig.getGlobalWebXmlSource()` reads without synchronization from `this.defaultWebXml`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1774.       protected InputSource getGlobalWebXmlSource() {
  1775.           // Is a default web.xml specified for the Context?
  1776. >         if (defaultWebXml == null && context instanceof StandardContext) {
  1777.               defaultWebXml = ((StandardContext) context).getDefaultWebXml();
  1778.           }

java/org/apache/tomcat/util/http/fileupload/util/FileItemHeadersImpl.java:56: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String FileItemHeadersImpl.getHeader(String)` reads without synchronization from container `this.headerNameToValueListMap` via call to `get`. Potentially races with write in method `FileItemHeadersImpl.addHeader(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  54.       public String getHeader(String name) {
  55.           String nameLower = name.toLowerCase(Locale.ENGLISH);
  56. >         List<String> headerValueList = headerNameToValueListMap.get(nameLower);
  57.           if (null == headerValueList) {
  58.               return null;

java/org/apache/tomcat/util/http/fileupload/util/FileItemHeadersImpl.java:68: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator FileItemHeadersImpl.getHeaderNames()` reads without synchronization from container `this.headerNameToValueListMap` via call to `keySet`. Potentially races with write in method `FileItemHeadersImpl.addHeader(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  66.       @Override
  67.       public Iterator<String> getHeaderNames() {
  68. >         return headerNameToValueListMap.keySet().iterator();
  69.       }
  70.   

java/org/apache/tomcat/util/http/fileupload/util/FileItemHeadersImpl.java:77: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Iterator FileItemHeadersImpl.getHeaders(String)` reads without synchronization from container `this.headerNameToValueListMap` via call to `get`. Potentially races with write in method `FileItemHeadersImpl.addHeader(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  75.       public Iterator<String> getHeaders(String name) {
  76.           String nameLower = name.toLowerCase(Locale.ENGLISH);
  77. >         List<String> headerValueList = headerNameToValueListMap.get(nameLower);
  78.           if (null == headerValueList) {
  79.               headerValueList = Collections.emptyList();

java/org/apache/tomcat/util/buf/StringCache.java:195: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int StringCache.getHitCount()` reads without synchronization from `buf.StringCache.hitCount`. Potentially races with write in method `StringCache.reset()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  193.        */
  194.       public int getHitCount() {
  195. >         return hitCount;
  196.       }
  197.   

java/org/apache/catalina/tribes/transport/ReceiverBase.java:297: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String ReceiverBase.getHost()` indirectly writes to field `this.bind` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  295.       @Override
  296.       public String getHost() {
  297. >         return getAddress();
  298.       }
  299.   

java/org/apache/coyote/http2/Http2UpgradeHandler.java:730: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `HpackEncoder Http2UpgradeHandler.getHpackEncoder()` reads without synchronization from `this.hpackEncoder`. Potentially races with write in method `Http2UpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  728.   
  729.       protected HpackEncoder getHpackEncoder() {
  730. >         if (hpackEncoder == null) {
  731.               hpackEncoder = new HpackEncoder();
  732.           }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:731: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `HpackEncoder Http2UpgradeHandler.getHpackEncoder()` writes to field `this.hpackEncoder` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  729.       protected HpackEncoder getHpackEncoder() {
  730.           if (hpackEncoder == null) {
  731. >             hpackEncoder = new HpackEncoder();
  732.           }
  733.           // Ensure latest agreed table size is used

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:198: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `OrderInterceptor$Counter OrderInterceptor.getInCounter(Member)` reads without synchronization from container `this.incounter` via call to `get`. Potentially races with write in method `OrderInterceptor.messageReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  196.   
  197.       protected Counter getInCounter(Member mbr) {
  198. >         Counter cnt = incounter.get(mbr);
  199.           if ( cnt == null ) {
  200.               cnt = new Counter();

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:202: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `OrderInterceptor$Counter OrderInterceptor.getInCounter(Member)` mutates container `this.incounter` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  200.               cnt = new Counter();
  201.               cnt.inc(); //always start at 1 for incoming
  202. >             incounter.put(mbr,cnt);
  203.           }
  204.           return cnt;

java/org/apache/catalina/tribes/transport/PooledSender.java:66: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PooledSender.getInPoolSize()` indirectly reads without synchronization from container `this.queue.notinuse` via call to `size`. Potentially races with write in method `PooledSender.disconnect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  64.   
  65.       public int getInPoolSize() {
  66. >         return queue.getInPoolSize();
  67.       }
  68.   

java/org/apache/catalina/tribes/transport/PooledSender.java:147: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PooledSender$SenderQueue.getInPoolSize()` reads without synchronization from container `this.notinuse` via call to `size`. Potentially races with write in method `PooledSender$SenderQueue.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  145.   
  146.           public int getInPoolSize() {
  147. >             return notinuse.size();
  148.           }
  149.   

java/org/apache/catalina/tribes/transport/PooledSender.java:70: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PooledSender.getInUsePoolSize()` indirectly reads without synchronization from container `this.queue.inuse` via call to `size`. Potentially races with write in method `PooledSender.disconnect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  68.   
  69.       public int getInUsePoolSize() {
  70. >         return queue.getInUsePoolSize();
  71.       }
  72.   

java/org/apache/catalina/tribes/transport/PooledSender.java:143: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PooledSender$SenderQueue.getInUsePoolSize()` reads without synchronization from container `this.inuse` via call to `size`. Potentially races with write in method `PooledSender$SenderQueue.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  141.   
  142.           public int getInUsePoolSize() {
  143. >             return inuse.size();
  144.           }
  145.   

java/org/apache/catalina/core/StandardContext.java:1184: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InstanceManager StandardContext.getInstanceManager()` reads without synchronization from `this.instanceManager`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1182.       @Override
  1183.       public InstanceManager getInstanceManager() {
  1184. >        return instanceManager;
  1185.       }
  1186.   

java/org/apache/catalina/core/StandardContext.java:1170: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JarScanner StandardContext.getJarScanner()` writes to field `this.jarScanner` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1168.       public JarScanner getJarScanner() {
  1169.           if (jarScanner == null) {
  1170. >             jarScanner = new StandardJarScanner();
  1171.           }
  1172.           return jarScanner;

java/org/apache/catalina/core/StandardContext.java:1169: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JarScanner StandardContext.getJarScanner()` reads without synchronization from `this.jarScanner`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1167.       @Override
  1168.       public JarScanner getJarScanner() {
  1169. >         if (jarScanner == null) {
  1170.               jarScanner = new StandardJarScanner();
  1171.           }

java/org/apache/catalina/core/StandardContext.java:2501: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JspConfigDescriptor StandardContext.getJspConfigDescriptor()` reads without synchronization from `this.jspConfigDescriptor`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2499.       @Override
  2500.       public JspConfigDescriptor getJspConfigDescriptor() {
  2501. >         return jspConfigDescriptor;
  2502.       }
  2503.   

java/org/apache/jasper/compiler/JspRuntimeContext.java:264: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int JspRuntimeContext.getJspCount()` reads without synchronization from container `this.jsps` via call to `size`. Potentially races with write in method `JspRuntimeContext.checkUnload()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  262.        */
  263.       public int getJspCount() {
  264. >         return jsps.size();
  265.       }
  266.   

java/org/apache/catalina/authenticator/DigestAuthenticator.java:144: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestAuthenticator.getKey()` reads without synchronization from `this.key`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.   
  143.       public String getKey() {
  144. >         return key;
  145.       }
  146.   

java/org/apache/catalina/session/ManagerBase.java:1218: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.getLastAccessedTime(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1216.   
  1217.       public String getLastAccessedTime( String sessionId ) {
  1218. >         Session s = sessions.get(sessionId);
  1219.           if (s == null) {
  1220.               if (log.isInfoEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:1207: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long ManagerBase.getLastAccessedTimestamp(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1205.   
  1206.       public long getLastAccessedTimestamp( String sessionId ) {
  1207. >         Session s = sessions.get(sessionId);
  1208.           if (s == null) {
  1209.               if (log.isInfoEnabled()) {

java/org/apache/jasper/servlet/JspServletWrapper.java:559: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long JspServletWrapper.getLastUsageTime()` reads without synchronization from `this.lastUsageTime`. Potentially races with write in method `JspServletWrapper.service(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  557.        */
  558.       public long getLastUsageTime() {
  559. >         return lastUsageTime;
  560.       }
  561.   

java/org/apache/catalina/core/StandardWrapper.java:1461: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long StandardWrapper.getLoadTime()` reads without synchronization from `this.loadTime`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1459.   
  1460.       public long getLoadTime() {
  1461. >         return loadTime;
  1462.       }
  1463.   

java/org/apache/catalina/core/ContainerBase.java:341: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ContainerBase.getLogName()` reads without synchronization from `this.logName`. Potentially races with write in method `ContainerBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  339.       public String getLogName() {
  340.   
  341. >         if (logName != null) {
  342.               return logName;
  343.           }

java/org/apache/catalina/core/ContainerBase.java:357: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String ContainerBase.getLogName()` writes to field `this.logName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  355.               current = current.getParent();
  356.           }
  357. >         logName = ContainerBase.class.getName() + "." + loggerName;
  358.           return logName;
  359.   

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:1077: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PrintWriter BasicDataSource.getLogWriter()` indirectly reads without synchronization from `this.closed`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1075.       @Override
  1076.       public PrintWriter getLogWriter() throws SQLException {
  1077. >         return createDataSource().getLogWriter();
  1078.       }
  1079.   

java/org/apache/catalina/core/ContainerBase.java:330: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Log ContainerBase.getLogger()` indirectly writes to field `this.logName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  328.           if (logger != null)
  329.               return logger;
  330. >         logger = LogFactory.getLog(getLogName());
  331.           return logger;
  332.       }

java/org/apache/catalina/core/ContainerBase.java:328: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Log ContainerBase.getLogger()` reads without synchronization from `this.logger`. Potentially races with write in method `ContainerBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  326.       @Override
  327.       public Log getLogger() {
  328. >         if (logger != null)
  329.               return logger;
  330.           logger = LogFactory.getLog(getLogName());

java/org/apache/catalina/ha/session/BackupManager.java:161: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String BackupManager.getMapName()` reads without synchronization from `this.cluster`. Potentially races with write in method `BackupManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  159.   
  160.       public String getMapName() {
  161. >         String name = cluster.getManagerName(getName(),this)+"-"+"map";
  162.           if ( log.isDebugEnabled() ) log.debug("Backup manager, Setting map name to:"+name);
  163.           return name;

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:609: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Member NonBlockingCoordinator.getMember(Member)` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  607.       public Member getMember(Member mbr) {
  608.   
  609. >         return membership.getMember(mbr);
  610.       }
  611.   

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:135: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Member StaticMembershipInterceptor.getMember(Member)` reads without synchronization from container `this.members` via call to `indexOf`. Potentially races with write in method `StaticMembershipInterceptor.addStaticMember(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  133.       @Override
  134.       public Member getMember(Member mbr) {
  135. >         if ( members.contains(mbr) ) return members.get(members.indexOf(mbr));
  136.           else return super.getMember(mbr);
  137.       }

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:210: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Member TcpFailureDetector.getMember(Member)` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  208.       @Override
  209.       public Member getMember(Member mbr) {
  210. >         if ( membership == null ) setupMembership();
  211.           return membership.getMember(mbr);
  212.       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:598: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.tribes.Member[] NonBlockingCoordinator.getMembers()` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  596.       public Member[] getMembers() {
  597.   
  598. >         return membership.getMembers();
  599.       }
  600.   

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:115: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.tribes.Member[] StaticMembershipInterceptor.getMembers()` reads without synchronization from container `this.members` via call to `size`. Potentially races with write in method `StaticMembershipInterceptor.addStaticMember(...)`.
 Reporting because this access may occur on a background thread.
  113.       @Override
  114.       public Member[] getMembers() {
  115. >         if ( members.size() == 0 ) return super.getMembers();
  116.           else {
  117.               synchronized (members) {

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:204: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.tribes.Member[] TcpFailureDetector.getMembers()` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  202.       @Override
  203.       public Member[] getMembers() {
  204. >         if ( membership == null ) setupMembership();
  205.           return membership.getMembers();
  206.       }

java/org/apache/catalina/core/StandardWrapper.java:1470: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `MultipartConfigElement StandardWrapper.getMultipartConfigElement()` reads without synchronization from `this.multipartConfigElement`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1468.       @Override
  1469.       public MultipartConfigElement getMultipartConfigElement() {
  1470. >         return multipartConfigElement;
  1471.       }
  1472.   

java/org/apache/catalina/session/JDBCStore.java:209: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String JDBCStore.getName()` writes to field `this.name` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  207.                   }
  208.               }
  209. >             name = "/" + engineName + "/" + hostName + contextName;
  210.           }
  211.           return name;

java/org/apache/catalina/session/JDBCStore.java:193: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String JDBCStore.getName()` reads without synchronization from `this.name`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  191.        */
  192.       public String getName() {
  193. >         if (name == null) {
  194.               Container container = manager.getContext();
  195.               String contextName = container.getName();

java/org/apache/tomcat/util/modeler/ManagedBean.java:176: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.getName()` reads without synchronization from `this.name`. Potentially races with write in method `ManagedBean.setName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  174.        */
  175.       public String getName() {
  176. >         return this.name;
  177.       }
  178.   

java/org/apache/catalina/core/StandardContext.java:5861: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NamingContextListener StandardContext.getNamingContextListener()` reads without synchronization from `this.namingContextListener`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5859.        */
  5860.       public NamingContextListener getNamingContextListener() {
  5861. >         return namingContextListener;
  5862.       }
  5863.   

java/org/apache/catalina/core/StandardContext.java:2013: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `NamingResourcesImpl StandardContext.getNamingResources()` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2011.       public NamingResourcesImpl getNamingResources() {
  2012.           if (namingResources == null) {
  2013. >             setNamingResources(new NamingResourcesImpl());
  2014.           }
  2015.           return namingResources;

java/org/apache/catalina/core/StandardContext.java:2012: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `NamingResourcesImpl StandardContext.getNamingResources()` reads without synchronization from `this.namingResources`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2010.       @Override
  2011.       public NamingResourcesImpl getNamingResources() {
  2012. >         if (namingResources == null) {
  2013.               setNamingResources(new NamingResourcesImpl());
  2014.           }

java/org/apache/tomcat/util/net/openssl/OpenSSLEngine.java:215: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String OpenSSLEngine.getNegotiatedProtocol()` reads without synchronization from `this.selectedProtocol`. Potentially races with write in method `OpenSSLEngine.getHandshakeStatus()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.       @Override
  214.       public String getNegotiatedProtocol() {
  215. >         return selectedProtocol;
  216.       }
  217.   

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:915: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int AbstractReplicatedMap.getNextBackupIndex()` reads without synchronization from container `this.mapMembers` via call to `size`. Potentially races with write in method `AbstractReplicatedMap.replyRequest(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  913.   
  914.       public int getNextBackupIndex() {
  915. >         int size = mapMembers.size();
  916.           if (mapMembers.size() == 0)return -1;
  917.           int node = currentNode++;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:926: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Member AbstractReplicatedMap.getNextBackupNode()` indirectly reads without synchronization from container `this.mapMembers` via call to `size`. Potentially races with write in method `AbstractReplicatedMap.replyRequest(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  924.       public Member getNextBackupNode() {
  925.           Member[] members = getMapMembers();
  926. >         int node = getNextBackupIndex();
  927.           if ( members.length == 0 || node==-1) return null;
  928.           if ( node >= members.length ) node = 0;

java/org/apache/tomcat/util/modeler/ManagedBean.java:194: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.tomcat.util.modeler.NotificationInfo[] ManagedBean.getNotifications()` reads without synchronization from `this.notifications`. Potentially races with write in method `ManagedBean.addNotification(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  192.        */
  193.       public NotificationInfo[] getNotifications() {
  194. >         return this.notifications;
  195.       }
  196.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:150: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PerUserPoolDataSource.getNumActive()` indirectly reads without synchronization from container `this.managers` via call to `get`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  148.        */
  149.       public int getNumActive() {
  150. >         return getNumActive(null);
  151.       }
  152.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java:111: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int SharedPoolDataSource.getNumActive()` reads without synchronization from `this.pool`. Potentially races with write in method `SharedPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  109.        */
  110.       public int getNumActive() {
  111. >         return pool == null ? 0 : pool.getNumActive();
  112.       }
  113.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:645: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericKeyedObjectPool.getNumActive()` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  643.       @Override
  644.       public int getNumActive() {
  645. >         return numTotal.get() - getNumIdle();
  646.       }
  647.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:669: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericObjectPool.getNumActive()` reads without synchronization from container `this.allObjects` via call to `size`. Potentially races with write in method `GenericObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  667.       @Override
  668.       public int getNumActive() {
  669. >         return allObjects.size() - idleObjects.size();
  670.       }
  671.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:664: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericKeyedObjectPool.getNumActive(Object)` reads without synchronization from container `this.poolMap` via call to `get`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  662.       @Override
  663.       public int getNumActive(final K key) {
  664. >         final ObjectDeque<T> objectDeque = poolMap.get(key);
  665.           if (objectDeque != null) {
  666.               return objectDeque.getAllObjects().size() -

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:162: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PerUserPoolDataSource.getNumActive(String)` indirectly reads without synchronization from container `this.managers` via call to `get`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  160.       @SuppressWarnings("resource")
  161.       public int getNumActive(final String userName) {
  162. >         final ObjectPool<PooledConnectionAndInfo> pool = getPool(getPoolKey(userName));
  163.           return pool == null ? 0 : pool.getNumActive();
  164.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1362: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Map GenericKeyedObjectPool.getNumActivePerKey()` reads without synchronization from container `this.poolMap` via call to `entrySet`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1360.           final HashMap<String,Integer> result = new HashMap<>();
  1361.   
  1362. >         final Iterator<Entry<K,ObjectDeque<T>>> iter = poolMap.entrySet().iterator();
  1363.           while (iter.hasNext()) {
  1364.               final Entry<K,ObjectDeque<T>> entry = iter.next();

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PerUserPoolDataSource.getNumIdle()` indirectly reads without synchronization from container `this.managers` via call to `get`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.        */
  171.       public int getNumIdle() {
  172. >         return getNumIdle(null);
  173.       }
  174.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java:120: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int SharedPoolDataSource.getNumIdle()` reads without synchronization from `this.pool`. Potentially races with write in method `SharedPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  118.        */
  119.       public int getNumIdle() {
  120. >         return pool == null ? 0 : pool.getNumIdle();
  121.       }
  122.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:651: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericKeyedObjectPool.getNumIdle()` reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  649.       @Override
  650.       public int getNumIdle() {
  651. >         final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
  652.           int result = 0;
  653.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:675: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericKeyedObjectPool.getNumIdle(Object)` reads without synchronization from container `this.poolMap` via call to `get`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  673.       @Override
  674.       public int getNumIdle(final K key) {
  675. >         final ObjectDeque<T> objectDeque = poolMap.get(key);
  676.           return objectDeque != null ? objectDeque.getIdleObjects().size() : 0;
  677.       }

java/org/apache/tomcat/dbcp/dbcp2/datasources/PerUserPoolDataSource.java:184: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int PerUserPoolDataSource.getNumIdle(String)` indirectly reads without synchronization from container `this.managers` via call to `get`. Potentially races with write in method `PerUserPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  182.       @SuppressWarnings("resource")
  183.       public int getNumIdle(final String userName) {
  184. >         final ObjectPool<PooledConnectionAndInfo> pool = getPool(getPoolKey(userName));
  185.           return pool == null ? 0 : pool.getNumIdle();
  186.       }

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1391: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int GenericKeyedObjectPool.getNumWaiters()` reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1389.   
  1390.           if (getBlockWhenExhausted()) {
  1391. >             final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();
  1392.   
  1393.               while (iter.hasNext()) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1414: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Map GenericKeyedObjectPool.getNumWaitersByKey()` reads without synchronization from container `this.poolMap` via call to `entrySet`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1412.           final Map<String,Integer> result = new HashMap<>();
  1413.   
  1414. >         for (final Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
  1415.               final K k = entry.getKey();
  1416.               final ObjectDeque<T> deque = entry.getValue();

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:130: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long JvmRouteBinderValve.getNumberOfSessions()` reads without synchronization from `this.numberOfSessions`. Potentially races with write in method `JvmRouteBinderValve.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  128.        */
  129.       public long getNumberOfSessions() {
  130. >         return numberOfSessions;
  131.       }
  132.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java:132: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object InstanceKeyDataSourceFactory.getObjectInstance(Object,Name,Context,Hashtable)` reads without synchronization from container `datasources.InstanceKeyDataSourceFactory.instanceMap` via call to `get`. Potentially races with write in method `InstanceKeyDataSourceFactory.registerNewInstance(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  130.                       if (name != null) {
  131.                           key = name.toString();
  132. >                         obj = instanceMap.get(key);
  133.                       }
  134.                       if (obj == null) {

java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java:139: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object InstanceKeyDataSourceFactory.getObjectInstance(Object,Name,Context,Hashtable)` mutates container `datasources.InstanceKeyDataSourceFactory.instanceMap` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  137.                           obj = ds;
  138.                           if (key != null) {
  139. >                             instanceMap.put(key, ds);
  140.                           }
  141.                       }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:164: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestAuthenticator.getOpaque()` reads without synchronization from `this.opaque`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  162.   
  163.       public String getOpaque() {
  164. >         return opaque;
  165.       }
  166.   

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:208: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `OrderInterceptor$Counter OrderInterceptor.getOutCounter(Member)` reads without synchronization from container `this.outcounter` via call to `get`. Potentially races with write in method `OrderInterceptor.sendMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  206.   
  207.       protected Counter getOutCounter(Member mbr) {
  208. >         Counter cnt = outcounter.get(mbr);
  209.           if ( cnt == null ) {
  210.               cnt = new Counter();

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:211: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `OrderInterceptor$Counter OrderInterceptor.getOutCounter(Member)` mutates container `this.outcounter` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  209.           if ( cnt == null ) {
  210.               cnt = new Counter();
  211. >             outcounter.put(mbr,cnt);
  212.           }
  213.           return cnt;

java/org/apache/catalina/authenticator/SingleSignOnEntry.java:151: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String SingleSignOnEntry.getPassword()` reads without synchronization from `this.password`. Potentially races with write in method `SingleSignOnEntry.updateCredentials(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  149.        */
  150.       public String getPassword() {
  151. >         return this.password;
  152.       }
  153.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:131: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `char[] CPDSConnectionFactory.getPasswordCharArray()` reads without synchronization from `this.userPassword`. Potentially races with write in method `CPDSConnectionFactory.setPassword(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  129.        */
  130.       char[] getPasswordCharArray() {
  131. >         return userPassword;
  132.       }
  133.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:171: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardJarScanFilter.getPluggabilityScan()` reads without synchronization from `this.pluggabilityScan`. Potentially races with write in method `StandardJarScanFilter.setPluggabilityScan(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  169.   
  170.       public String getPluggabilityScan() {
  171. >         return pluggabilityScan;
  172.       }
  173.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:154: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardJarScanFilter.getPluggabilitySkip()` reads without synchronization from `this.pluggabilitySkip`. Potentially races with write in method `StandardJarScanFilter.setPluggabilitySkip(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  152.   
  153.       public String getPluggabilitySkip() {
  154. >         return pluggabilitySkip;
  155.       }
  156.   

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:291: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int MessageDispatchInterceptor.getPoolSize()` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  289.       @Override
  290.       public int getPoolSize() {
  291. >         if (executor instanceof ThreadPoolExecutor) {
  292.               return ((ThreadPoolExecutor) executor).getPoolSize();
  293.           } else {

java/org/apache/tomcat/dbcp/dbcp2/datasources/SharedPoolDataSource.java:145: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PooledConnectionAndInfo SharedPoolDataSource.getPooledConnectionAndInfo(String,String)` reads without synchronization from `this.pool`. Potentially races with write in method `SharedPoolDataSource.getPooledConnectionAndInfo(...)`.
 Reporting because this access may occur on a background thread.
  143.   
  144.           try {
  145. >             info = pool.borrowObject(key);
  146.           } catch (final Exception e) {
  147.               throw new SQLException("Could not retrieve connection info from pool", e);

java/org/apache/catalina/tribes/transport/ReceiverBase.java:139: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int ReceiverBase.getPort()` reads without synchronization from `this.port`. Potentially races with write in method `ReceiverBase.bind(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  137.       @Override
  138.       public int getPort() {
  139. >         return port;
  140.       }
  141.   

java/org/apache/catalina/authenticator/SingleSignOnEntry.java:161: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Principal SingleSignOnEntry.getPrincipal()` reads without synchronization from `this.principal`. Potentially races with write in method `SingleSignOnEntry.updateCredentials(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  159.        */
  160.       public Principal getPrincipal() {
  161. >         return this.principal;
  162.       }
  163.   

java/org/apache/catalina/ha/session/DeltaManager.java:257: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getProcessingTime()` reads without synchronization from `this.processingTime`. Potentially races with write in method `DeltaManager.resetStatistics()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  255.       @Override
  256.       public long getProcessingTime() {
  257. >         return processingTime;
  258.       }
  259.   

java/org/apache/jasper/compiler/AntCompiler.java:74: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Project AntCompiler.getProject()` reads without synchronization from `this.logger`. Potentially races with write in method `AntCompiler.generateClass(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  72.           project = new Project();
  73.           logger = new JasperAntLogger();
  74. >         logger.setOutputPrintStream(System.out);
  75.           logger.setErrorPrintStream(System.err);
  76.           logger.setMessageOutputLevel(Project.MSG_INFO);

java/org/apache/jasper/compiler/AntCompiler.java:68: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Project AntCompiler.getProject()` reads without synchronization from `this.project`. Potentially races with write in method `AntCompiler.generateClass(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  66.       protected Project getProject() {
  67.   
  68. >         if (project != null)
  69.               return project;
  70.   

java/org/apache/jasper/compiler/AntCompiler.java:73: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Project AntCompiler.getProject()` writes to field `this.logger` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.           // Initializing project
  72.           project = new Project();
  73. >         logger = new JasperAntLogger();
  74.           logger.setOutputPrintStream(System.out);
  75.           logger.setErrorPrintStream(System.err);

java/org/apache/jasper/compiler/AntCompiler.java:72: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Project AntCompiler.getProject()` writes to field `this.project` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  70.   
  71.           // Initializing project
  72. >         project = new Project();
  73.           logger = new JasperAntLogger();
  74.           logger.setOutputPrintStream(System.out);

java/org/apache/catalina/core/StandardContext.java:4374: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardContext.getRealPath(String)` reads without synchronization from `this.resources`. Potentially races with write in method `StandardContext.setResources(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4372.               path = "/";
  4373.           }
  4374. >         if (resources != null) {
  4375.               try {
  4376.                   WebResource resource = resources.getResource(path);

java/org/apache/catalina/ha/session/DeltaManager.java:275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int DeltaManager.getReceivedQueueSize()` reads without synchronization from container `this.receivedMessageQueue` via call to `size`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  273.   
  274.       public int getReceivedQueueSize() {
  275. >         return receivedMessageQueue.size() ;
  276.       }
  277.   

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:1222: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ObjectName BasicDataSource.getRegisteredJmxName()` reads without synchronization from `this.registeredJmxObjectName`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1220.   
  1221.       protected ObjectName getRegisteredJmxName() {
  1222. >         return ObjectNameWrapper.unwrap(registeredJmxObjectName);
  1223.       }
  1224.   

java/org/apache/catalina/storeconfig/StoreLoader.java:87: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `StoreRegistry StoreLoader.getRegistry()` reads without synchronization from `this.registry`. Potentially races with write in method `StoreLoader.load(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  85.        */
  86.       public StoreRegistry getRegistry() {
  87. >         return registry;
  88.       }
  89.   

java/org/apache/catalina/storeconfig/StoreLoader.java:170: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `URL StoreLoader.getRegistryResource()` reads without synchronization from `this.registryResource`. Potentially races with write in method `StoreLoader.load(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  168.        */
  169.       public URL getRegistryResource() {
  170. >         return registryResource;
  171.       }
  172.   }

java/org/apache/catalina/session/ManagerBase.java:497: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int ManagerBase.getRejectedSessions()` reads without synchronization from `this.rejectedSessions`. Potentially races with write in method `ManagerBase.createSession(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  495.       @Override
  496.       public int getRejectedSessions() {
  497. >         return rejectedSessions;
  498.       }
  499.   

java/org/apache/catalina/loader/WebappClassLoaderBase.java:1057: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `URL WebappClassLoaderBase.getResource(String)` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1055.   
  1056.           // (2) Search local repositories
  1057. >         url = findResource(name);
  1058.           if (url != null) {
  1059.               if (log.isDebugEnabled())

java/org/apache/catalina/loader/WebappClassLoaderBase.java:1140: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `InputStream WebappClassLoaderBase.getResourceAsStream(String)` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1138.           if (resource.exists()) {
  1139.               stream = resource.getInputStream();
  1140. >             trackLastModified(path, resource);
  1141.           }
  1142.           try {

java/org/apache/catalina/realm/JDBCRealm.java:591: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ArrayList JDBCRealm.getRoles(String)` indirectly writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  589.               try {
  590.                   // Ensure that we have an open database connection
  591. >                 open();
  592.   
  593.                   PreparedStatement stmt = roles(dbConnection, username);

java/org/apache/catalina/tribes/transport/RxTaskPool.java:68: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `AbstractRxTask RxTaskPool.getRxTask()` reads with synchronization from `this.running`. Potentially races with unsynchronized write in method `RxTaskPool.stop()`.
 Reporting because this access may occur on a background thread.
  66.           AbstractRxTask worker = null;
  67.           synchronized (mutex) {
  68. >             while ( worker == null && running ) {
  69.                   if (idle.size() > 0) {
  70.                       try {

java/org/apache/tomcat/util/net/AprEndpoint.java:1607: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int AprEndpoint$Sendfile.getSendfileCount()` reads without synchronization from `this.sendfileCount`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1605.   
  1606.           protected int sendfileCount;
  1607. >         public int getSendfileCount() { return sendfileCount; }
  1608.   
  1609.           protected ArrayList<SendfileData> addS;

java/org/apache/tomcat/util/net/openssl/OpenSSLContext.java:487: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SSLSessionContext OpenSSLContext.getServerSessionContext()` reads without synchronization from `this.sessionContext`. Potentially races with write in method `OpenSSLContext.init(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  485.       @Override
  486.       public SSLSessionContext getServerSessionContext() {
  487. >         return sessionContext;
  488.       }
  489.   

java/org/apache/catalina/core/StandardServer.java:722: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `javax.management.ObjectName[] StandardServer.getServiceNames()` reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  720.        */
  721.       public ObjectName[] getServiceNames() {
  722. >         ObjectName onames[]=new ObjectName[ services.length ];
  723.           for( int i=0; i<services.length; i++ ) {
  724.               onames[i]=((StandardService)services[i]).getObjectName();

java/org/apache/catalina/tribes/membership/McastServiceImpl.java:511: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long McastServiceImpl.getServiceStartTime()` indirectly reads without synchronization from `this.member.serviceStartTime`. Potentially races with write in method `McastServiceImpl.stop(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  509.   
  510.       public long getServiceStartTime() {
  511. >         return (member!=null) ? member.getServiceStartTime() : -1l;
  512.       }
  513.   

java/org/apache/catalina/core/StandardContext.java:2280: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ServletContext StandardContext.getServletContext()` reads without synchronization from `this.context`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2278.       @Override
  2279.       public ServletContext getServletContext() {
  2280. >         if (context == null) {
  2281.               context = new ApplicationContext(this);
  2282.               if (altDDName != null)

java/org/apache/catalina/core/StandardContext.java:2281: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ServletContext StandardContext.getServletContext()` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2279.       public ServletContext getServletContext() {
  2280.           if (context == null) {
  2281. >             context = new ApplicationContext(this);
  2282.               if (altDDName != null)
  2283.                   context.setAttribute(Globals.ALT_DD_ATTR,altDDName);

java/org/apache/catalina/ha/context/ReplicatedContext.java:120: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ServletContext ReplicatedContext.getServletContext()` reads without synchronization from `this.context`. Potentially races with write in method `ReplicatedContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  118.       @Override
  119.       public ServletContext getServletContext() {
  120. >         if (context == null) {
  121.               context = new ReplApplContext(this);
  122.               if (getAltDDName() != null)

java/org/apache/catalina/ha/context/ReplicatedContext.java:121: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ServletContext ReplicatedContext.getServletContext()` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  119.       public ServletContext getServletContext() {
  120.           if (context == null) {
  121. >             context = new ReplApplContext(this);
  122.               if (getAltDDName() != null)
  123.                   context.setAttribute(Globals.ALT_DD_ATTR,getAltDDName());

java/org/apache/catalina/session/StandardSession.java:627: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `HttpSession StandardSession.getSession()` reads without synchronization from `this.facade`. Potentially races with write in method `StandardSession.expire(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  625.       @Override
  626.       public HttpSession getSession() {
  627. >         if (facade == null) {
  628.               if (SecurityUtil.isPackageProtectionEnabled()) {
  629.                   facade = AccessController.doPrivileged(new PrivilegedNewSessionFacade(this));

java/org/apache/catalina/session/StandardSession.java:629: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `HttpSession StandardSession.getSession()` writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  627.           if (facade == null) {
  628.               if (SecurityUtil.isPackageProtectionEnabled()) {
  629. >                 facade = AccessController.doPrivileged(new PrivilegedNewSessionFacade(this));
  630.               } else {
  631.                   facade = new StandardSessionFacade(this);

java/org/apache/catalina/session/ManagerBase.java:1150: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `HashMap ManagerBase.getSession(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1148.        */
  1149.       public HashMap<String, String> getSession(String sessionId) {
  1150. >         Session s = sessions.get(sessionId);
  1151.           if (s == null) {
  1152.               if (log.isInfoEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:1124: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.getSessionAttribute(String,String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1122.        */
  1123.       public String getSessionAttribute( String sessionId, String key ) {
  1124. >         Session s = sessions.get(sessionId);
  1125.           if (s == null) {
  1126.               if (log.isInfoEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:906: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long ManagerBase.getSessionCounter()` reads without synchronization from `this.sessionCounter`. Potentially races with write in method `ManagerBase.createSession(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  904.       @Override
  905.       public long getSessionCounter() {
  906. >         return sessionCounter;
  907.       }
  908.   

java/org/apache/catalina/ha/session/BackupManager.java:273: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set BackupManager.getSessionIdsFull()` reads without synchronization from `this.sessions`. Potentially races with write in method `BackupManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  271.       public Set<String> getSessionIdsFull() {
  272.           Set<String> sessionIds = new HashSet<>();
  273. >         LazyReplicatedMap<String,Session> map =
  274.                   (LazyReplicatedMap<String,Session>)sessions;
  275.           for (String id : map.keySetFull()) {

java/org/apache/catalina/session/PersistentManagerBase.java:652: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set PersistentManagerBase.getSessionIdsFull()` reads without synchronization from container `this.sessions` via call to `keySet`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  650.           Set<String> sessionIds = new HashSet<>();
  651.           // In memory session ID list
  652. >         sessionIds.addAll(sessions.keySet());
  653.           // Store session ID list
  654.           String[] storeKeys;

java/org/apache/catalina/ha/session/DeltaManager.java:264: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long DeltaManager.getSessionReplaceCounter()` reads without synchronization from `this.sessionReplaceCounter`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  262.        */
  263.       public long getSessionReplaceCounter() {
  264. >         return sessionReplaceCounter;
  265.       }
  266.   

java/org/apache/tomcat/util/net/NioSelectorPool.java:49: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Selector NioSelectorPool.getSharedSelector()` reads without synchronization from `this.shared`. Potentially races with write in method `NioSelectorPool.setShared(...)`.
 Reporting because this access may occur on a background thread.
  47.   
  48.       protected Selector getSharedSelector() throws IOException {
  49. >         if (shared && sharedSelector == null) {
  50.               synchronized (NioSelectorPool.class) {
  51.                   if (sharedSelector == null) {

java/org/apache/catalina/core/StandardContext.java:6378: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long StandardContext.getStartTime()` reads without synchronization from `this.startTime`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  6376.        */
  6377.       public long getStartTime() {
  6378. >         return startTime;
  6379.       }
  6380.   

java/org/apache/catalina/core/StandardContext.java:1690: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long StandardContext.getStartupTime()` reads without synchronization from `this.startupTime`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1688.        */
  1689.       public long getStartupTime() {
  1690. >         return startupTime;
  1691.       }
  1692.   

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:317: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long MessageDispatchInterceptor.getTaskCount()` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  315.       @Override
  316.       public long getTaskCount() {
  317. >         if (executor instanceof ThreadPoolExecutor) {
  318.               return ((ThreadPoolExecutor) executor).getTaskCount();
  319.           } else {

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:660: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `File FarmWarDeployer.getTempDirFile()` reads without synchronization from `this.tempDirFile`. Potentially races with write in method `FarmWarDeployer.getFactory(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  658.   
  659.       public File getTempDirFile() {
  660. >         if (tempDirFile != null) return tempDirFile;
  661.   
  662.           File dir = getAbsolutePath(getTempDir());

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:663: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `File FarmWarDeployer.getTempDirFile()` writes to field `this.tempDirFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  661.   
  662.           File dir = getAbsolutePath(getTempDir());
  663. >         this.tempDirFile = dir;
  664.           return dir;
  665.       }

java/org/apache/catalina/session/ManagerBase.java:1196: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.getThisAccessedTime(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1194.   
  1195.       public String getThisAccessedTime( String sessionId ) {
  1196. >         Session s = sessions.get(sessionId);
  1197.           if (s == null) {
  1198.               if (log.isInfoEnabled()) {

java/org/apache/catalina/session/ManagerBase.java:1185: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long ManagerBase.getThisAccessedTimestamp(String)` reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1183.   
  1184.       public long getThisAccessedTimestamp( String sessionId ) {
  1185. >         Session s = sessions.get(sessionId);
  1186.           if (s == null) {
  1187.               if (log.isInfoEnabled()) {

java/org/apache/catalina/ha/session/SessionMessageImpl.java:130: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long SessionMessageImpl.getTimestamp()` reads without synchronization from `this.serializationTimestamp`. Potentially races with write in method `SessionMessageImpl.setTimestamp(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  128.   
  129.       @Override
  130. >     public long getTimestamp() { return serializationTimestamp;}
  131.   
  132.       /**

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:121: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardJarScanFilter.getTldScan()` reads without synchronization from `this.tldScan`. Potentially races with write in method `StandardJarScanFilter.setTldScan(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  119.   
  120.       public String getTldScan() {
  121. >         return tldScan;
  122.       }
  123.   

java/org/apache/catalina/core/StandardContext.java:1698: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `long StandardContext.getTldScanTime()` reads without synchronization from `this.tldScanTime`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1696.   
  1697.       public long getTldScanTime() {
  1698. >         return tldScanTime;
  1699.       }
  1700.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:104: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StandardJarScanFilter.getTldSkip()` reads without synchronization from `this.tldSkip`. Potentially races with write in method `StandardJarScanFilter.setTldSkip(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  102.   
  103.       public String getTldSkip() {
  104. >         return tldSkip;
  105.       }
  106.   

java/org/apache/tomcat/dbcp/dbcp2/AbandonedTrace.java:98: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `List AbandonedTrace.getTrace()` reads without synchronization from container `this.traceList` via call to `size`. Potentially races with write in method `AbandonedTrace.addTrace(...)`.
 Reporting because this access may occur on a background thread.
  96.        */
  97.       protected List<AbandonedTrace> getTrace() {
  98. >         final int size = traceList.size();
  99.           if (size == 0) {
  100.               return Collections.emptyList();

java/org/apache/tomcat/util/modeler/ManagedBean.java:214: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.getType()` reads without synchronization from `this.type`. Potentially races with write in method `ManagedBean.setType(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  212.        */
  213.       public String getType() {
  214. >         return this.type;
  215.       }
  216.   

java/org/apache/jasper/servlet/JspServletWrapper.java:364: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FastRemovalDequeue$Entry JspServletWrapper.getUnloadHandle()` reads without synchronization from `this.unloadHandle`. Potentially races with write in method `JspServletWrapper.service(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  362.   
  363.       public FastRemovalDequeue<JspServletWrapper>.Entry getUnloadHandle() {
  364. >         return unloadHandle;
  365.       }
  366.   

java/org/apache/catalina/authenticator/SingleSignOnEntry.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String SingleSignOnEntry.getUsername()` reads without synchronization from `this.username`. Potentially races with write in method `SingleSignOnEntry.updateCredentials(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.        */
  171.       public String getUsername() {
  172. >         return this.username;
  173.       }
  174.   

java/org/apache/catalina/tribes/group/GroupChannel.java:545: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ScheduledExecutorService GroupChannel.getUtilityExecutor()` reads without synchronization from `this.utilityExecutor`. Potentially races with write in method `GroupChannel.stop(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  543.       @Override
  544.       public ScheduledExecutorService getUtilityExecutor() {
  545. >         return utilityExecutor;
  546.       }
  547.   

java/org/apache/jasper/el/JasperELResolver.java:107: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object JasperELResolver.getValue(ELContext,Object,Object)` reads without synchronization from `this.resolvers.[_]`. Potentially races with write in method `JasperELResolver.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  105.               int index = 1 /* implicit */ + appResolversSize;
  106.               for (int i = 0; i < index; i++) {
  107. >                 result = resolvers[i].getValue(context, base, property);
  108.                   if (context.isPropertyResolved()) {
  109.                       return result;

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:436: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `UniqueId NonBlockingCoordinator.getViewId()` reads without synchronization from `this.viewId`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  434.   
  435.       public UniqueId getViewId() {
  436. >         return viewId;
  437.       }
  438.   

java/org/apache/jasper/compiler/JspRuntimeContext.java:206: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JspServletWrapper JspRuntimeContext.getWrapper(String)` reads without synchronization from container `this.jsps` via call to `get`. Potentially races with write in method `JspRuntimeContext.checkUnload()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  204.        */
  205.       public JspServletWrapper getWrapper(String jspUri) {
  206. >         return jsps.get(jspUri);
  207.       }
  208.   

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:39: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.goaway(int,long,String)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  37.   import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
  38.   
  39. > public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
  40.   
  41.       private static final ByteBuffer[] BYTEBUFFER_ARRAY = new ByteBuffer[0];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1623: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.goaway(int,long,String)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2UpgradeHandler.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1621.                       Integer.toString(lastStreamId), Long.toHexString(errorCode), debugData));
  1622.           }
  1623. >         close();
  1624.       }
  1625.   

java/org/apache/catalina/ha/session/DeltaManager.java:1318: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleALL_SESSION_DATA(SessionMessage,Member)` writes to field `this.counterReceive_EVT_ALL_SESSION_DATA` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1316.       protected void handleALL_SESSION_DATA(SessionMessage msg,Member sender)
  1317.               throws ClassNotFoundException, IOException {
  1318. >         counterReceive_EVT_ALL_SESSION_DATA++;
  1319.           if (log.isDebugEnabled()) {
  1320.               log.debug(sm.getString("deltaManager.receiveMessage.allSessionDataBegin", getName()));

java/org/apache/catalina/ha/session/DeltaManager.java:1406: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleALL_SESSION_NOCONTEXTMANAGER(SessionMessage,Member)` writes to field `this.counterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1404.        */
  1405.       protected void handleALL_SESSION_NOCONTEXTMANAGER(SessionMessage msg, Member sender) {
  1406. >         counterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER++ ;
  1407.           if (log.isDebugEnabled())
  1408.               log.debug(sm.getString("deltaManager.receiveMessage.noContextManager",

java/org/apache/catalina/ha/session/DeltaManager.java:1211: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage,Member)` writes to field `this.counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1209.        */
  1210.       protected void handleALL_SESSION_TRANSFERCOMPLETE(SessionMessage msg, Member sender) {
  1211. >         counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE++ ;
  1212.           if (log.isDebugEnabled()) {
  1213.               log.debug(sm.getString("deltaManager.receiveMessage.transfercomplete",

java/org/apache/coyote/http2/Http2UpgradeHandler.java:788: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.handleAppInitiatedIOException(IOException)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2UpgradeHandler.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  786.        */
  787.       protected void handleAppInitiatedIOException(IOException ioe) throws IOException {
  788. >         close();
  789.           throw ioe;
  790.       }

java/org/apache/catalina/ha/session/DeltaManager.java:1389: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleCHANGE_SESSION_ID(SessionMessage,Member)` writes to field `this.counterReceive_EVT_CHANGE_SESSION_ID` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1387.        */
  1388.       protected void handleCHANGE_SESSION_ID(SessionMessage msg,Member sender) throws IOException {
  1389. >         counterReceive_EVT_CHANGE_SESSION_ID++;
  1390.           DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1391.           if (session != null) {

java/org/apache/catalina/ha/session/DeltaManager.java:1393: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleCHANGE_SESSION_ID(SessionMessage,Member)` indirectly writes to field `session.isPrimarySession` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1391.           if (session != null) {
  1392.               String newSessionID = deserializeSessionId(msg.getSession());
  1393. >             session.setPrimarySession(false);
  1394.               // change session id
  1395.               changeSessionId(session, newSessionID, notifySessionListenersOnReplication,

java/org/apache/catalina/ha/session/DeltaManager.java:1390: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleCHANGE_SESSION_ID(SessionMessage,Member)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1388.       protected void handleCHANGE_SESSION_ID(SessionMessage msg,Member sender) throws IOException {
  1389.           counterReceive_EVT_CHANGE_SESSION_ID++;
  1390. >         DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1391.           if (session != null) {
  1392.               String newSessionID = deserializeSessionId(msg.getSession());

java/org/apache/catalina/ha/session/DeltaManager.java:1378: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleGET_ALL_SESSIONS(SessionMessage,Member)` writes to field `this.counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1376.               log.debug(sm.getString("deltaManager.createMessage.allSessionTransfered",getName()));
  1377.           }
  1378. >         counterSend_EVT_ALL_SESSION_TRANSFERCOMPLETE++;
  1379.           cluster.send(newmsg, sender);
  1380.       }

java/org/apache/catalina/ha/session/DeltaManager.java:1340: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleGET_ALL_SESSIONS(SessionMessage,Member)` writes to field `this.counterReceive_EVT_GET_ALL_SESSIONS` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1338.        */
  1339.       protected void handleGET_ALL_SESSIONS(SessionMessage msg, Member sender) throws IOException {
  1340. >         counterReceive_EVT_GET_ALL_SESSIONS++;
  1341.           //get a list of all the session from this manager
  1342.           if (log.isDebugEnabled()) {

java/org/apache/catalina/ha/session/DeltaManager.java:1347: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleGET_ALL_SESSIONS(SessionMessage,Member)` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1345.           // Write the number of active sessions, followed by the details
  1346.           // get all sessions and serialize without sync
  1347. >         Session[] currentSessions = findSessions();
  1348.           long findSessionTimestamp = System.currentTimeMillis() ;
  1349.           if (isSendAllSessions()) {

java/org/apache/catalina/ha/session/DeltaManager.java:1350: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleGET_ALL_SESSIONS(SessionMessage,Member)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1348.           long findSessionTimestamp = System.currentTimeMillis() ;
  1349.           if (isSendAllSessions()) {
  1350. >             sendSessions(sender, currentSessions, findSessionTimestamp);
  1351.           } else {
  1352.               // send session at blocks

java/org/apache/jasper/servlet/JspServletWrapper.java:619: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `JasperException JspServletWrapper.handleJspException(Exception)` indirectly writes to field `this.ctxt.className` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  617.   
  618.               JavacErrorDetail detail = new JavacErrorDetail(jspFrame.getMethodName(), javaLineNumber,
  619. >                     source.getFileName(), source.getLineNumber(), null, ctxt);
  620.   
  621.               if (options.getDisplaySourceFragment()) {

java/org/apache/jasper/servlet/JspServletWrapper.java:598: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `JasperException JspServletWrapper.handleJspException(Exception)` indirectly reads without synchronization from `this.ctxt.jspCompiler`. Potentially races with write in method `JspServletWrapper.loadTagFile()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  596.   
  597.               if (jspFrame != null) {
  598. >                 smap = ctxt.getCompiler().getSmap(jspFrame.getClassName());
  599.               }
  600.   

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:296: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JvmRouteBinderValve.handleJvmRoute(Request,String,String)` writes to field `this.numberOfSessions` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  294.                   changeSessionID(request, sessionId, newSessionID,
  295.                           catalinaSession);
  296. >                 numberOfSessions++;
  297.               } else {
  298.                   try {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:358: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleMyToken(Member,NonBlockingCoordinator$CoordinationMessage,Membership)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  356.                   msg.type = COORD_CONF;
  357.                   super.sendMessage(Arrays.remove(msg.getMembers(),local),createData(msg,local),null);
  358. >                 handleViewConf(msg, merged);
  359.               } else {
  360.                   //membership change

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:382: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleOtherToken(Member,NonBlockingCoordinator$CoordinationMessage,Membership)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  380.           } else {
  381.               msg.view = merged.getMembers();
  382. >             sendElectionMsgToNextInline(local,msg);
  383.           }
  384.       }

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:202: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JvmRouteBinderValve.handlePossibleTurnover(Request)` indirectly writes to field `this.numberOfSessions` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  200.                   return;
  201.               }
  202. >             handleJvmRoute( request, sessionID, jvmRoute);
  203.               if (log.isDebugEnabled()) {
  204.                   long t2 = System.currentTimeMillis();

java/org/apache/catalina/ha/session/DeltaManager.java:1255: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleSESSION_ACCESSED(SessionMessage,Member)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1253.       protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
  1254.           counterReceive_EVT_SESSION_ACCESSED++;
  1255. >         DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1256.           if (session != null) {
  1257.               if (log.isDebugEnabled()) {

java/org/apache/catalina/ha/session/DeltaManager.java:1262: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleSESSION_ACCESSED(SessionMessage,Member)` indirectly writes to field `session.isPrimarySession` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1260.               }
  1261.               session.access();
  1262. >             session.setPrimarySession(false);
  1263.               session.endAccess();
  1264.           }

java/org/apache/catalina/ha/session/DeltaManager.java:1254: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleSESSION_ACCESSED(SessionMessage,Member)` writes to field `this.counterReceive_EVT_SESSION_ACCESSED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1252.        */
  1253.       protected void handleSESSION_ACCESSED(SessionMessage msg,Member sender) throws IOException {
  1254. >         counterReceive_EVT_SESSION_ACCESSED++;
  1255.           DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1256.           if (session != null) {

java/org/apache/catalina/ha/session/DeltaManager.java:1291: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleSESSION_CREATED(SessionMessage,Member)` writes to field `this.counterReceive_EVT_SESSION_CREATED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1289.        */
  1290.       protected void handleSESSION_CREATED(SessionMessage msg,Member sender) {
  1291. >         counterReceive_EVT_SESSION_CREATED++;
  1292.           if (log.isDebugEnabled()) {
  1293.               log.debug(sm.getString("deltaManager.receiveMessage.createNewSession",

java/org/apache/catalina/ha/session/DeltaManager.java:1231: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleSESSION_DELTA(SessionMessage,Member)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1229.           counterReceive_EVT_SESSION_DELTA++;
  1230.           byte[] delta = msg.getSession();
  1231. >         DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1232.           if (session == null) {
  1233.               if (log.isDebugEnabled()) {

java/org/apache/catalina/ha/session/DeltaManager.java:1229: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleSESSION_DELTA(SessionMessage,Member)` writes to field `this.counterReceive_EVT_SESSION_DELTA` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1227.       protected void handleSESSION_DELTA(SessionMessage msg, Member sender)
  1228.               throws IOException, ClassNotFoundException {
  1229. >         counterReceive_EVT_SESSION_DELTA++;
  1230.           byte[] delta = msg.getSession();
  1231.           DeltaSession session = (DeltaSession) findSession(msg.getSessionID());

java/org/apache/catalina/ha/session/DeltaManager.java:1274: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.handleSESSION_EXPIRED(SessionMessage,Member)` writes to field `this.counterReceive_EVT_SESSION_EXPIRED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1272.        */
  1273.       protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
  1274. >         counterReceive_EVT_SESSION_EXPIRED++;
  1275.           DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1276.           if (session != null) {

java/org/apache/catalina/ha/session/DeltaManager.java:1275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.handleSESSION_EXPIRED(SessionMessage,Member)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1273.       protected void handleSESSION_EXPIRED(SessionMessage msg,Member sender) throws IOException {
  1274.           counterReceive_EVT_SESSION_EXPIRED++;
  1275. >         DeltaSession session = (DeltaSession) findSession(msg.getSessionID());
  1276.           if (session != null) {
  1277.               if (log.isDebugEnabled()) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:346: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleToken(NonBlockingCoordinator$CoordinationMessage,Membership)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  344.           if ( local.equals(msg.getSource()) ) {
  345.               //my message msg.src=local
  346. >             handleMyToken(local, msg, merged);
  347.           } else {
  348.               handleOtherToken(local, msg, merged);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:392: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleViewConf(NonBlockingCoordinator$CoordinationMessage,Membership)` reads without synchronization from `this.suggestedviewId`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  390.           viewId = msg.getId();
  391.   
  392. >         if ( viewId.equals(suggestedviewId) ) {
  393.               suggestedView = null;
  394.               suggestedviewId = null;

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:402: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleViewConf(NonBlockingCoordinator$CoordinationMessage,Membership)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  400.           }
  401.   
  402. >         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_CONF_RX,this,"Accepted View"));
  403.   
  404.           if ( suggestedviewId == null && hasHigherPriority(merged.getMembers(),membership.getMembers()) ) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:390: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NonBlockingCoordinator.handleViewConf(NonBlockingCoordinator$CoordinationMessage,Membership)` writes to field `this.viewId` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  388.           view = new Membership(getLocalMember(false),AbsoluteOrder.comp,true);
  389.           Arrays.fill(view,msg.getMembers());
  390. >         viewId = msg.getId();
  391.   
  392.           if ( viewId.equals(suggestedviewId) ) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:394: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NonBlockingCoordinator.handleViewConf(NonBlockingCoordinator$CoordinationMessage,Membership)` writes to field `this.suggestedviewId` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  392.           if ( viewId.equals(suggestedviewId) ) {
  393.               suggestedView = null;
  394. >             suggestedviewId = null;
  395.           }
  396.   

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:387: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.handleViewConf(NonBlockingCoordinator$CoordinationMessage,Membership)` reads without synchronization from `this.viewId`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  385.   
  386.       protected void handleViewConf(CoordinationMessage msg, Membership merged) throws ChannelException {
  387. >         if ( viewId != null && msg.getId().equals(viewId) ) return;//we already have this view
  388.           view = new Membership(getLocalMember(false),AbsoluteOrder.comp,true);
  389.           Arrays.fill(view,msg.getMembers());

java/org/apache/tomcat/util/net/Nio2Endpoint.java:1303: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean Nio2Endpoint$Nio2SocketWrapper.hasDataToRead()` reads with synchronization from `this.readNotify`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  1301.           public boolean hasDataToRead() {
  1302.               synchronized (readCompletionHandler) {
  1303. >                 return !socketBufferHandler.isReadBufferEmpty()
  1304.                           || readNotify || getError() != null;
  1305.               }

java/org/apache/catalina/loader/WebappClassLoaderBase.java:2658: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean WebappClassLoaderBase.hasLoggingConfig()` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2656.               return result.booleanValue();
  2657.           } else {
  2658. >             return findResource("logging.properties") != null;
  2659.           }
  2660.       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:588: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NonBlockingCoordinator.hasMembers()` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  586.       public boolean hasMembers() {
  587.   
  588. >         return membership.hasMembers();
  589.       }
  590.   

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:106: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StaticMembershipInterceptor.hasMembers()` reads without synchronization from container `this.members` via call to `size`. Potentially races with write in method `StaticMembershipInterceptor.addStaticMember(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  104.       @Override
  105.       public boolean hasMembers() {
  106. >         return super.hasMembers() || (members.size()>0);
  107.       }
  108.   

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:198: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean TcpFailureDetector.hasMembers()` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  196.       @Override
  197.       public boolean hasMembers() {
  198. >         if ( membership == null ) setupMembership();
  199.           return membership.hasMembers();
  200.       }

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:1288: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean LinkedBlockingDeque$AbstractItr.hasNext()` reads without synchronization from `this.next`. Potentially races with write in method `LinkedBlockingDeque$AbstractItr.advance()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1286.           @Override
  1287.           public boolean hasNext() {
  1288. >             return next != null;
  1289.           }
  1290.   

java/org/apache/catalina/core/AsyncContextImpl.java:354: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AsyncContextImpl.hasOriginalRequestAndResponse()` reads without synchronization from `this.hasOriginalRequestAndResponse`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  352.       public boolean hasOriginalRequestAndResponse() {
  353.           check();
  354. >         return hasOriginalRequestAndResponse;
  355.       }
  356.   

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1532: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.headersEnd(int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1530.       @Override
  1531.       public void headersEnd(int streamId) throws ConnectionException {
  1532. >         Stream stream = getStream(streamId, connectionState.get().isNewStreamAllowed());
  1533.           if (stream != null) {
  1534.               setMaxProcessedStream(streamId);

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:39: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `HpackDecoder$HeaderEmitter Http2AsyncUpgradeHandler.headersStart(int,boolean)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  37.   import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
  38.   
  39. > public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
  40.   
  41.       private static final ByteBuffer[] BYTEBUFFER_ARRAY = new ByteBuffer[0];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1444: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `HpackDecoder$HeaderEmitter Http2UpgradeHandler.headersStart(int,boolean)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1442.               Stream stream = getStream(streamId, false);
  1443.               if (stream == null) {
  1444. >                 stream = createRemoteStream(streamId);
  1445.               }
  1446.               if (streamId < maxActiveRemoteStreamId) {

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1442: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `HpackDecoder$HeaderEmitter Http2UpgradeHandler.headersStart(int,boolean)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1440.   
  1441.           if (connectionState.get().isNewStreamAllowed()) {
  1442. >             Stream stream = getStream(streamId, false);
  1443.               if (stream == null) {
  1444.                   stream = createRemoteStream(streamId);

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:145: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FragmentationInterceptor.heartbeat()` reads without synchronization from container `this.fragpieces` via call to `keySet`. Potentially races with write in method `FragmentationInterceptor.getFragCollection(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  143.       public void heartbeat() {
  144.           try {
  145. >             Set<FragKey> set = fragpieces.keySet();
  146.               Object[] keys = set.toArray();
  147.               for ( int i=0; i<keys.length; i++ ) {

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:150: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FragmentationInterceptor.heartbeat()` indirectly mutates container `this.fragpieces` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  148.                   FragKey key = (FragKey)keys[i];
  149.                   if ( key != null && key.expired(getExpire()) )
  150. >                     removeFragCollection(key);
  151.               }
  152.           }catch ( Exception x ) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:572: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.heartbeat()` indirectly reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  570.                       fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,
  571.                               sm.getString("nonBlockingCoordinator.heartbeat.inconsistency")));
  572. >                     startElection(true);
  573.                   }
  574.               }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:568: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.heartbeat()` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  566.           try {
  567.               Member local = getLocalMember(false);
  568. >             if ( view != null && (Arrays.diff(view,membership,local).length != 0 ||  Arrays.diff(membership,view,local).length != 0) ) {
  569.                   if ( isHighest() ) {
  570.                       fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START_ELECT, this,

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:222: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.heartbeat()` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  220.       public void heartbeat() {
  221.           super.heartbeat();
  222. >         checkMembers(false);
  223.       }
  224.   

java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java:103: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpPingInterceptor.heartbeat()` indirectly reads without synchronization from `this.failureDetector`. Potentially races with write in method `TcpPingInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  101.       public void heartbeat() {
  102.           super.heartbeat();
  103. >         if (!getUseThread()) sendPing();
  104.       }
  105.   

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:937: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.heartbeat()` indirectly reads with synchronization from `entry.backup`. Potentially races with unsynchronized write in method `AbstractReplicatedMap.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  935.       public void heartbeat() {
  936.           try {
  937. >             if (this.state.isAvailable()) ping(accessTimeout);
  938.           }catch ( Exception x ) {
  939.               log.error(sm.getString("abstractReplicatedMap.heartbeat.failed"),x);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:193: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int OrderInterceptor.incCounter(Member)` indirectly mutates container `this.outcounter` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  191.   
  192.       protected int incCounter(Member mbr) {
  193. >         Counter cnt = getOutCounter(mbr);
  194.           return cnt.inc();
  195.       }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:956: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.incrementWindowSize(int)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2UpgradeHandler.incrementWindowSize(...)`.
 Reporting because this access may occur on a background thread.
  954.                       continue;
  955.                   }
  956. >                 ((Stream) stream).notifyConnection();
  957.               }
  958.           }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1658: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.incrementWindowSize(int,int)` reads without synchronization from container `this.backLogStreams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1656.                   // For Streams, client might only release the minimum so check
  1657.                   // against current demand
  1658. >                 BacklogTracker tracker = backLogStreams.get(stream);
  1659.                   if (tracker == null || increment < tracker.getRemainingReservation()) {
  1660.                       // The smaller the increment, the larger the overhead

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1650: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.incrementWindowSize(int,int)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2UpgradeHandler.incrementWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1648.               }
  1649.   
  1650. >             incrementWindowSize(increment);
  1651.           } else {
  1652.               Stream stream = getStream(streamId, true);

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1652: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.incrementWindowSize(int,int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1650.               incrementWindowSize(increment);
  1651.           } else {
  1652. >             Stream stream = getStream(streamId, true);
  1653.   
  1654.               // Check for small increments which are inefficient

java/org/apache/tomcat/util/net/AprEndpoint.java:1618: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.init()` writes to field `this.pool` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1616.            */
  1617.           protected void init() {
  1618. >             pool = Pool.create(serverSockPool);
  1619.               int size = sendfileSize;
  1620.               if (size <= 0) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1625: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.init()` writes to field `this.sendfileData` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1623.               sendfilePollset = allocatePoller(size, pool, getConnectionTimeout());
  1624.               desc = new long[size * 2];
  1625. >             sendfileData = new HashMap<>(size);
  1626.               addS = new ArrayList<>();
  1627.           }

java/org/apache/tomcat/util/net/AprEndpoint.java:1623: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.init()` reads without synchronization from `this.pool`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1621.                   size = 16 * 1024;
  1622.               }
  1623. >             sendfilePollset = allocatePoller(size, pool, getConnectionTimeout());
  1624.               desc = new long[size * 2];
  1625.               sendfileData = new HashMap<>(size);

java/org/apache/tomcat/util/net/AprEndpoint.java:1624: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.init()` writes to field `this.desc` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1622.               }
  1623.               sendfilePollset = allocatePoller(size, pool, getConnectionTimeout());
  1624. >             desc = new long[size * 2];
  1625.               sendfileData = new HashMap<>(size);
  1626.               addS = new ArrayList<>();

java/org/apache/tomcat/util/net/AprEndpoint.java:1626: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.init()` writes to field `this.addS` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1624.               desc = new long[size * 2];
  1625.               sendfileData = new HashMap<>(size);
  1626. >             addS = new ArrayList<>();
  1627.           }
  1628.   

java/org/apache/jasper/runtime/TagHandlerPool.java:77: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void TagHandlerPool.init(ServletConfig)` writes to field `this.current` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  75.           }
  76.           this.handlers = new Tag[maxSize];
  77. >         this.current = -1;
  78.           instanceManager = InstanceManagerFactory.getInstanceManager(config);
  79.       }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:216: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2UpgradeHandler.init(WebConnection)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  214.                   // Process the initial settings frame
  215.                   stream = getStream(1, true);
  216. >                 String base64Settings = stream.getCoyoteRequest().getHeader(HTTP2_SETTINGS_HEADER);
  217.                   byte[] settings = Base64.decodeBase64URLSafe(base64Settings);
  218.   

java/org/apache/coyote/http2/Http2UpgradeHandler.java:215: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.init(WebConnection)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.               try {
  214.                   // Process the initial settings frame
  215. >                 stream = getStream(1, true);
  216.                   String base64Settings = stream.getCoyoteRequest().getHeader(HTTP2_SETTINGS_HEADER);
  217.                   byte[] settings = Base64.decodeBase64URLSafe(base64Settings);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:239: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.init(AbstractReplicatedMap$MapOwner,Channel,String,long,int,java.lang.ClassLoader[],boolean)` indirectly reads with synchronization from `entry.backup`. Potentially races with unsynchronized write in method `AbstractReplicatedMap.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  237.               broadcast(MapMessage.MSG_INIT, true);
  238.               //transfer state from another map
  239. >             transferState();
  240.               //state is transferred, we are ready for messaging
  241.               broadcast(MapMessage.MSG_START, true);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:237: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.init(AbstractReplicatedMap$MapOwner,Channel,String,long,int,java.lang.ClassLoader[],boolean)` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  235.           try {
  236.               //broadcast our map, this just notifies other members of our existence
  237. >             broadcast(MapMessage.MSG_INIT, true);
  238.               //transfer state from another map
  239.               transferState();

java/org/apache/catalina/core/StandardContext.java:6191: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.initInternal()` reads without synchronization from `this.namingResources`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  6189.   
  6190.           // Register the naming resources
  6191. >         if (namingResources != null) {
  6192.               namingResources.init();
  6193.           }

java/org/apache/catalina/core/StandardContext.java:6188: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.initInternal()` indirectly reads without synchronization from `managed.name`. Potentially races with write in method `StandardContext.filterStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  6186.       @Override
  6187.       protected void initInternal() throws LifecycleException {
  6188. >         super.initInternal();
  6189.   
  6190.           // Register the naming resources

java/org/apache/catalina/core/StandardServer.java:1056: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.initInternal()` reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1054.           }
  1055.           // Initialize our defined Services
  1056. >         for (int i = 0; i < services.length; i++) {
  1057.               services[i].init();
  1058.           }

java/org/apache/catalina/core/StandardService.java:515: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.initInternal()` reads without synchronization from `this.engine`. Potentially races with write in method `StandardService.setContainer(...)`.
 Reporting because this access may occur on a background thread.
  513.           super.initInternal();
  514.   
  515. >         if (engine != null) {
  516.               engine.init();
  517.           }

java/org/apache/catalina/core/StandardService.java:513: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.initInternal()` indirectly reads without synchronization from `managed.name`. Potentially races with write in method `StandardService.initInternal()`.
 Reporting because this access may occur on a background thread.
  511.       protected void initInternal() throws LifecycleException {
  512.   
  513. >         super.initInternal();
  514.   
  515.           if (engine != null) {

java/org/apache/catalina/deploy/NamingResourcesImpl.java:974: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.initInternal()` reads without synchronization from container `this.envs` via call to `values`. Potentially races with write in method `NamingResourcesImpl.removeEnvironment(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  972.           }
  973.   
  974. >         for (ContextEnvironment ce : envs.values()) {
  975.               try {
  976.                   MBeanUtils.createMBean(ce);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:965: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.initInternal()` reads without synchronization from container `this.resources` via call to `values`. Potentially races with write in method `NamingResourcesImpl.removeResource(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  963.           resourceRequireExplicitRegistration = true;
  964.   
  965. >         for (ContextResource cr : resources.values()) {
  966.               try {
  967.                   MBeanUtils.createMBean(cr);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:983: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.initInternal()` reads without synchronization from container `this.resourceLinks` via call to `values`. Potentially races with write in method `NamingResourcesImpl.addEnvironment(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  981.           }
  982.   
  983. >         for (ContextResourceLink crl : resourceLinks.values()) {
  984.               try {
  985.                   MBeanUtils.createMBean(crl);

java/org/apache/catalina/webresources/JarWarResourceSet.java:246: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JarWarResourceSet.initInternal()` indirectly writes to field `this.manifest` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  244.   
  245.               try (JarInputStream jarIs = new JarInputStream(jarFileIs)) {
  246. >                 setManifest(jarIs.getManifest());
  247.               }
  248.           } catch (IOException ioe) {

java/org/apache/tomcat/dbcp/dbcp2/datasources/CPDSConnectionFactory.java:329: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void CPDSConnectionFactory.invalidate(PooledConnection)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `CPDSConnectionFactory.makeObject()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  327.       @Override
  328.       public void invalidate(final PooledConnection pc) throws SQLException {
  329. >         final PooledConnectionAndInfo pci = pcMap.get(pc);
  330.           if (pci == null) {
  331.               throw new IllegalStateException(NO_KEY_MESSAGE);

java/org/apache/tomcat/dbcp/dbcp2/datasources/KeyedCPDSConnectionFactory.java:297: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void KeyedCPDSConnectionFactory.invalidate(PooledConnection)` reads without synchronization from container `this.pcMap` via call to `get`. Potentially races with write in method `KeyedCPDSConnectionFactory.makeObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  295.       @Override
  296.       public void invalidate(final PooledConnection pc) throws SQLException {
  297. >         final PooledConnectionAndInfo info = pcMap.get(pc);
  298.           if (info == null) {
  299.               throw new IllegalStateException(NO_KEY_MESSAGE);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:1466: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BasicDataSource.invalidateConnection(Connection)` indirectly mutates container `this.connectionPool.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1464.   
  1465.           try {
  1466. >             connectionPool.invalidateObject(poolableConnection);
  1467.           } catch (final Exception e) {
  1468.               throw new IllegalStateException("Invalidating connection threw unexpected exception", e);

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:618: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericObjectPool.invalidateObject(Object)` reads without synchronization from container `this.allObjects` via call to `get`. Potentially races with write in method `GenericObjectPool.ensureMinIdle()`.
 Reporting because this access may occur on a background thread.
  616.       @Override
  617.       public void invalidateObject(final T obj) throws Exception {
  618. >         final PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
  619.           if (p == null) {
  620.               if (isAbandonedConfig()) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:631: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.invalidateObject(Object)` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  629.               }
  630.           }
  631. >         ensureIdle(1, false);
  632.       }
  633.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:576: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.invalidateObject(Object,Object)` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.borrowObject(...)`.
 Reporting because this access may occur on a background thread.
  574.           }
  575.           if (objectDeque.idleObjects.hasTakeWaiters()) {
  576. >             addObject(key);
  577.           }
  578.       }

java/org/apache/jasper/el/JasperELResolver.java:151: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object JasperELResolver.invoke(ELContext,Object,Object,java.lang.Class[],java.lang.Object[])` reads without synchronization from `this.resolvers.[_]`. Potentially races with write in method `JasperELResolver.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  149.                   2 /* stream + static */;
  150.           for (int i = 1; i < index; i++) {
  151. >             result = resolvers[i].invoke(
  152.                       context, base, targetMethod, paramTypes, params);
  153.               if (context.isPropertyResolved()) {

java/org/apache/catalina/authenticator/AuthenticatorBase.java:633: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.invoke(Request,Response)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  631.               if (jaspicProvider == null && !doAuthenticate(request, response) ||
  632.                       jaspicProvider != null &&
  633. >                             !authenticateJaspic(request, response, jaspicState, false)) {
  634.                   if (log.isDebugEnabled()) {
  635.                       log.debug("Failed authenticate() test");

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JvmRouteBinderValve.invoke(Request,Response)` indirectly writes to field `this.numberOfSessions` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  176.                        ||
  177.                        (manager instanceof PersistentManager))) {
  178. >                 handlePossibleTurnover(request);
  179.               }
  180.           }

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:174: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JvmRouteBinderValve.invoke(Request,Response)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `JvmRouteBinderValve.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  172.                if (manager != null && (
  173.                        (manager instanceof ClusterManager
  174. >                        && getCluster() != null
  175.                          && getCluster().getManager(((ClusterManager)manager).getName()) != null)
  176.                        ||

java/org/apache/catalina/ha/tcp/ReplicationValve.java:331: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.invoke(Request,Response)` reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  329.               }
  330.               getNext().invoke(request, response);
  331. >             if(context != null && cluster != null
  332.                       && context.getManager() instanceof ClusterManager) {
  333.                   ClusterManager clusterManager = (ClusterManager) context.getManager();

java/org/apache/catalina/valves/SemaphoreValve.java:144: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SemaphoreValve.invoke(Request,Response)` reads without synchronization from `this.semaphore`. Potentially races with write in method `SemaphoreValve.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  142.                       if (interruptible) {
  143.                           try {
  144. >                             semaphore.acquire();
  145.                           } catch (InterruptedException e) {
  146.                               shouldRelease = false;

java/org/apache/catalina/valves/rewrite/RewriteValve.java:288: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RewriteValve.invoke(Request,Response)` reads without synchronization from `this.rules`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  286.           throws IOException, ServletException {
  287.   
  288. >         if (!getEnabled() || rules == null || rules.length == 0) {
  289.               getNext().invoke(request, response);
  290.               return;

java/org/apache/catalina/valves/rewrite/RewriteValve.java:312: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RewriteValve.invoke(Request,Response)` reads without synchronization from `this.context`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  310.               Charset uriCharset = request.getConnector().getURICharset();
  311.               String originalQueryStringEncoded = request.getQueryString();
  312. >             MessageBytes urlMB =
  313.                       context ? request.getRequestPathMB() : request.getDecodedRequestURIMB();
  314.               urlMB.toChars();

webapps/examples/WEB-INF/classes/websocket/drawboard/Room.java:356: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Room.invokeAndWait(Runnable)` writes to field `this.cachedRunnables` outside of synchronization.
 Reporting because this access may occur on a background thread.
  354.   
  355.               if (cachedRunnables == null) {
  356. >                 cachedRunnables = new ArrayList<>();
  357.               }
  358.               cachedRunnables.add(task);

webapps/examples/WEB-INF/classes/websocket/drawboard/Room.java:373: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Room.invokeAndWait(Runnable)` reads with synchronization from `this.cachedRunnables`. Potentially races with unsynchronized write in method `Room.invokeAndWait(...)`.
 Reporting because this access may occur on a background thread.
  371.   
  372.                   // Run the cached runnables.
  373. >                 if (cachedRunnables != null) {
  374.                       for (int i = 0; i < cachedRunnables.size(); i++) {
  375.                           if (!closed) {

java/org/apache/catalina/core/AprLifecycleListener.java:110: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AprLifecycleListener.isAprAvailable()` reads without synchronization from `core.AprLifecycleListener.aprAvailable`. Potentially races with write in method `AprLifecycleListener.lifecycleEvent(...)`.
 Reporting because this access may occur on a background thread.
  108.               }
  109.           }
  110. >         return aprAvailable;
  111.       }
  112.   

java/org/apache/catalina/core/AprLifecycleListener.java:105: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AprLifecycleListener.isAprAvailable()` reads without synchronization from `core.AprLifecycleListener.instanceCreated`. Potentially races with write in method `AprLifecycleListener()`.
 Reporting because this access may occur on a background thread.
  103.       public static boolean isAprAvailable() {
  104.           //https://bz.apache.org/bugzilla/show_bug.cgi?id=48613
  105. >         if (instanceCreated) {
  106.               synchronized (lock) {
  107.                   init();

java/org/apache/catalina/core/AsyncContextImpl.java:400: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AsyncContextImpl.isAvailable()` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  398.       @Override
  399.       public boolean isAvailable() {
  400. >         Context context = this.context;
  401.           if (context == null) {
  402.               return false;

java/org/apache/catalina/realm/JDBCRealm.java:413: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean JDBCRealm.isAvailable()` reads without synchronization from `this.dbConnection`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  411.       @Override
  412.       public boolean isAvailable() {
  413. >         return (dbConnection != null);
  414.       }
  415.   

java/org/apache/catalina/startup/HostConfig.java:369: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean HostConfig.isDeployed(String)` reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  367.        */
  368.       public boolean isDeployed(String name) {
  369. >         return deployed.containsKey(name);
  370.       }
  371.   

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java:369: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean FairBlockingQueue.isEmpty()` indirectly reads without synchronization from container `this.items` via call to `size`. Potentially races with write in method `FairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  367.       @Override
  368.       public boolean isEmpty() {
  369. >         return size() == 0;
  370.       }
  371.   

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java:366: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean MultiLockFairBlockingQueue.isEmpty()` indirectly reads without synchronization from container `this.items.[_]` via call to `size`. Potentially races with write in method `MultiLockFairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  364.       @Override
  365.       public boolean isEmpty() {
  366. >         return size() == 0;
  367.       }
  368.   

java/org/apache/catalina/core/AprLifecycleListener.java:401: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AprLifecycleListener.isFIPSModeActive()` reads without synchronization from `core.AprLifecycleListener.fipsModeActive`. Potentially races with write in method `AprLifecycleListener.lifecycleEvent(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  399.   
  400.       public boolean isFIPSModeActive() {
  401. >         return fipsModeActive;
  402.       }
  403.   

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:555: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NonBlockingCoordinator.isHighest()` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  553.       public boolean isHighest() {
  554.           Member local = getLocalMember(false);
  555. >         if ( membership.getMembers().length == 0 ) return true;
  556.           else return AbsoluteOrder.comp.compare(local,membership.getMembers()[0])<=0;
  557.       }

java/org/apache/catalina/session/PersistentManagerBase.java:314: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean PersistentManagerBase.isLoaded(String)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  312.       public boolean isLoaded(String id){
  313.           try {
  314. >             if (super.findSession(id) != null) {
  315.                   return true;
  316.               }

java/org/apache/catalina/realm/LockOutRealm.java:271: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean LockOutRealm.isLocked(String)` reads without synchronization from `this.lockOutTime`. Potentially races with write in method `LockOutRealm.setLockOutTime(...)`.
 Reporting because this access may occur on a background thread.
  269.           if (lockRecord.getFailures() >= failureCount &&
  270.                   (System.currentTimeMillis() -
  271. >                         lockRecord.getLastFailureTime())/1000 < lockOutTime) {
  272.               return true;
  273.           }

java/org/apache/catalina/realm/LockOutRealm.java:269: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean LockOutRealm.isLocked(String)` reads without synchronization from `this.failureCount`. Potentially races with write in method `LockOutRealm.setFailureCount(...)`.
 Reporting because this access may occur on a background thread.
  267.   
  268.           // Check to see if user is locked
  269. >         if (lockRecord.getFailures() >= failureCount &&
  270.                   (System.currentTimeMillis() -
  271.                           lockRecord.getLastFailureTime())/1000 < lockOutTime) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:602: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator$DigestInfo.isNonceStale()` reads without synchronization from `this.nonceStale`. Potentially races with write in method `DigestAuthenticator$DigestInfo.validate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  600.   
  601.           public boolean isNonceStale() {
  602. >             return nonceStale;
  603.           }
  604.   

java/org/apache/tomcat/util/net/Nio2Endpoint.java:746: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean Nio2Endpoint$Nio2SocketWrapper.isReadyForRead()` reads with synchronization from `this.readNotify`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  744.               synchronized (readCompletionHandler) {
  745.                   // A notification has been sent, it is possible to read at least once
  746. >                 if (readNotify) {
  747.                       return true;
  748.                   }

java/org/apache/tomcat/util/net/NioEndpoint.java:1104: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioEndpoint$NioSocketWrapper.isReadyForRead()` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `NioEndpoint$NioSocketWrapper.doWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1102.               }
  1103.   
  1104. >             fillReadBuffer(false);
  1105.   
  1106.               boolean isReady = socketBufferHandler.getReadBuffer().position() > 0;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:1591: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AbstractReplicatedMap.isStateTransferred()` reads without synchronization from `this.stateTransferred`. Potentially races with write in method `AbstractReplicatedMap.transferState()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1589.   
  1590.       public boolean isStateTransferred() {
  1591. >         return stateTransferred;
  1592.       }
  1593.   

java/org/apache/catalina/core/StandardWrapper.java:536: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardWrapper.isUnavailable()` reads without synchronization from `this.available`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  534.           if (!isEnabled())
  535.               return true;
  536. >         else if (available == 0L)
  537.               return false;
  538.           else if (available <= System.currentTimeMillis()) {

java/org/apache/catalina/core/StandardWrapper.java:539: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardWrapper.isUnavailable()` writes to field `this.available` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  537.               return false;
  538.           else if (available <= System.currentTimeMillis()) {
  539. >             available = 0L;
  540.               return false;
  541.           } else

java/org/apache/catalina/core/StandardContext.java:1297: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.isUseNaming()` reads without synchronization from `this.useNaming`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1295.        */
  1296.       public boolean isUseNaming() {
  1297. >         return useNaming;
  1298.       }
  1299.   

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:386: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean FileMessageFactory.isValid()` indirectly writes to field `this.closed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  384.               int timeIdle = (int) ((timeNow - creationTime) / 1000L);
  385.               if (timeIdle > maxValidTime) {
  386. >                 cleanup();
  387.                   if (file.exists() && !file.delete()) {
  388.                       log.warn(sm.getString("fileMessageFactory.deleteFail", file));

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:146: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean MultipointBioSender.keepalive()` reads without synchronization from container `this.bioSenders` via call to `size`. Potentially races with write in method `MultipointBioSender.sendMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  144.           boolean result = false;
  145.           @SuppressWarnings("unchecked")
  146. >         Map.Entry<Member,BioSender>[] entries = bioSenders.entrySet().toArray(new Map.Entry[bioSenders.size()]);
  147.           for ( int i=0; i<entries.length; i++ ) {
  148.               BioSender sender = entries[i].getValue();

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:150: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean MultipointBioSender.keepalive()` mutates container `this.bioSenders` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  148.               BioSender sender = entries[i].getValue();
  149.               if ( sender.keepalive() ) {
  150. >                 bioSenders.remove(entries[i].getKey());
  151.               }
  152.           }

java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java:358: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean ParallelNioSender.keepalive()` indirectly writes to field `xbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  356.               } else {
  357.                   try {
  358. >                     sender.read();
  359.                   }catch ( IOException x ) {
  360.                       sender.disconnect();

java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java:349: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ParallelNioSender.keepalive()` reads without synchronization from container `this.nioSenders` via call to `entrySet`. Potentially races with write in method `ParallelNioSender.disconnect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  347.       public boolean keepalive() {
  348.           boolean result = false;
  349. >         for (Iterator<Entry<Member,NioSender>> i = nioSenders.entrySet().iterator(); i.hasNext();) {
  350.               Map.Entry<Member, NioSender> entry = i.next();
  351.               NioSender sender = entry.getValue();

java/org/apache/catalina/startup/ContextConfig.java:306: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.lifecycleEvent(LifecycleEvent)` reads without synchronization from `this.originalDocBase`. Potentially races with write in method `ContextConfig.beforeStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  304.           } else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) {
  305.               // Restore docBase for management tools
  306. >             if (originalDocBase != null) {
  307.                   context.setDocBase(originalDocBase);
  308.               }

java/org/apache/catalina/startup/HostConfig.java:305: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.lifecycleEvent(LifecycleEvent)` indirectly reads without synchronization from container `this.deployed` via call to `values`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  303.           // Process the event that has occurred
  304.           if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {
  305. >             check();
  306.           } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {
  307.               beforeStart();

java/org/apache/catalina/startup/HostConfig.java:296: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.lifecycleEvent(LifecycleEvent)` indirectly writes to field `this.contextClass` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  294.                   setDeployXML(((StandardHost) host).isDeployXML());
  295.                   setUnpackWARs(((StandardHost) host).isUnpackWARs());
  296. >                 setContextClass(((StandardHost) host).getContextClass());
  297.               }
  298.           } catch (ClassCastException e) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1445: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Map GenericKeyedObjectPool.listAllObjects()` reads without synchronization from container `this.poolMap` via call to `entrySet`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1443.                   new HashMap<>();
  1444.   
  1445. >         for (final Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {
  1446.               final K k = entry.getKey();
  1447.               final ObjectDeque<T> deque = entry.getValue();

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:1153: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Set GenericObjectPool.listAllObjects()` reads without synchronization from container `this.allObjects` via call to `values`. Potentially races with write in method `GenericObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1151.           final Set<DefaultPooledObjectInfo> result =
  1152.                   new HashSet<>(allObjects.size());
  1153. >         for (final PooledObject<T> p : allObjects.values()) {
  1154.               result.add(new DefaultPooledObjectInfo(p));
  1155.           }

java/org/apache/catalina/session/ManagerBase.java:1107: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.listSessionIds()` reads without synchronization from container `this.sessions` via call to `keySet`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1105.       public String listSessionIds() {
  1106.           StringBuilder sb = new StringBuilder();
  1107. >         for (String s : sessions.keySet()) {
  1108.               sb.append(s).append(" ");
  1109.           }

java/org/apache/catalina/core/StandardContext.java:4607: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStart()` indirectly reads without synchronization from `this.instanceManager`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4605.               try {
  4606.                   String listener = listeners[i];
  4607. >                 results[i] = getInstanceManager().newInstance(listener);
  4608.               } catch (Throwable t) {
  4609.                   t = ExceptionUtils.unwrapInvocationTargetException(t);

java/org/apache/catalina/core/StandardContext.java:4662: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` indirectly writes to field `this.context.newServletContextListenerAllowed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4660.           // Ensure context is not null
  4661.           getServletContext();
  4662. >         context.setNewServletContextListenerAllowed(false);
  4663.   
  4664.           Object instances[] = getApplicationLifecycleListeners();

java/org/apache/catalina/core/StandardContext.java:4661: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4659.   
  4660.           // Ensure context is not null
  4661. >         getServletContext();
  4662.           context.setNewServletContextListenerAllowed(false);
  4663.   

java/org/apache/catalina/core/StandardContext.java:4643: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStart()` indirectly reads without synchronization from container `this.applicationEventListenersList` via call to `toArray`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4641.           // annotations then overwrite the list of instances with the new, full
  4642.           // list.
  4643. >         for (Object eventListener: getApplicationEventListeners()) {
  4644.               eventListeners.add(eventListener);
  4645.           }

java/org/apache/catalina/core/StandardContext.java:4647: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStart()` indirectly reads without synchronization from `this.applicationLifecycleListenersObjects`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4645.           }
  4646.           setApplicationEventListeners(eventListeners.toArray());
  4647. >         for (Object lifecycleListener: getApplicationLifecycleListeners()) {
  4648.               lifecycleListeners.add(lifecycleListener);
  4649.               if (lifecycleListener instanceof ServletContextListener) {

java/org/apache/catalina/core/StandardContext.java:4602: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` indirectly writes to field `this.logName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4600.           boolean ok = true;
  4601.           for (int i = 0; i < results.length; i++) {
  4602. >             if (getLogger().isDebugEnabled())
  4603.                   getLogger().debug(" Configuring event listener class '" +
  4604.                       listeners[i] + "'");

java/org/apache/catalina/core/StandardContext.java:4598: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStart()` indirectly reads without synchronization from `this.applicationListeners`. Potentially races with write in method `StandardContext.addApplicationListener(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4596.   
  4597.           // Instantiate the required listeners
  4598. >         String listeners[] = findApplicationListeners();
  4599.           Object results[] = new Object[listeners.length];
  4600.           boolean ok = true;

java/org/apache/catalina/core/StandardContext.java:4653: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` indirectly writes to field `this.applicationLifecycleListenersObjects` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4651.               }
  4652.           }
  4653. >         setApplicationLifecycleListeners(lifecycleListeners.toArray());
  4654.   
  4655.           // Send application start events

java/org/apache/catalina/core/StandardContext.java:4672: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` writes to field `this.noPluggabilityServletContext` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4670.           ServletContextEvent tldEvent = null;
  4671.           if (noPluggabilityListeners.size() > 0) {
  4672. >             noPluggabilityServletContext = new NoPluggabilityServletContext(getServletContext());
  4673.               tldEvent = new ServletContextEvent(noPluggabilityServletContext);
  4674.           }

java/org/apache/catalina/core/StandardContext.java:4646: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStart()` indirectly mutates container `this.applicationEventListenersList` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4644.               eventListeners.add(eventListener);
  4645.           }
  4646. >         setApplicationEventListeners(eventListeners.toArray());
  4647.           for (Object lifecycleListener: getApplicationLifecycleListeners()) {
  4648.               lifecycleListeners.add(lifecycleListener);

java/org/apache/catalina/core/StandardContext.java:4673: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStart()` reads without synchronization from `this.noPluggabilityServletContext`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4671.           if (noPluggabilityListeners.size() > 0) {
  4672.               noPluggabilityServletContext = new NoPluggabilityServletContext(getServletContext());
  4673. >             tldEvent = new ServletContextEvent(noPluggabilityServletContext);
  4674.           }
  4675.           for (int i = 0; i < instances.length; i++) {

java/org/apache/catalina/core/StandardContext.java:4717: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStop()` reads without synchronization from `this.noPluggabilityServletContext`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4715.               ServletContextEvent event = new ServletContextEvent(getServletContext());
  4716.               ServletContextEvent tldEvent = null;
  4717. >             if (noPluggabilityServletContext != null) {
  4718.                   tldEvent = new ServletContextEvent(noPluggabilityServletContext);
  4719.               }

java/org/apache/catalina/core/StandardContext.java:4782: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStop()` indirectly writes to field `this.applicationLifecycleListenersObjects` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4780.   
  4781.           setApplicationEventListeners(null);
  4782. >         setApplicationLifecycleListeners(null);
  4783.   
  4784.           noPluggabilityServletContext = null;

java/org/apache/catalina/core/StandardContext.java:4713: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStop()` indirectly reads without synchronization from `this.applicationLifecycleListenersObjects`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4711.   
  4712.           boolean ok = true;
  4713. >         Object listeners[] = getApplicationLifecycleListeners();
  4714.           if (listeners != null && listeners.length > 0) {
  4715.               ServletContextEvent event = new ServletContextEvent(getServletContext());

java/org/apache/catalina/core/StandardContext.java:4784: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStop()` writes to field `this.noPluggabilityServletContext` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4782.           setApplicationLifecycleListeners(null);
  4783.   
  4784. >         noPluggabilityServletContext = null;
  4785.           noPluggabilityListeners.clear();
  4786.   

java/org/apache/catalina/core/StandardContext.java:4745: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStop()` indirectly reads without synchronization from `this.instanceManager`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4743.                   }
  4744.                   try {
  4745. >                     if (getInstanceManager() != null) {
  4746.                           getInstanceManager().destroyInstance(listeners[j]);
  4747.                       }

java/org/apache/catalina/core/StandardContext.java:4715: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStop()` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4713.           Object listeners[] = getApplicationLifecycleListeners();
  4714.           if (listeners != null && listeners.length > 0) {
  4715. >             ServletContextEvent event = new ServletContextEvent(getServletContext());
  4716.               ServletContextEvent tldEvent = null;
  4717.               if (noPluggabilityServletContext != null) {

java/org/apache/catalina/core/StandardContext.java:4781: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.listenerStop()` indirectly mutates container `this.applicationEventListenersList` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4779.           }
  4780.   
  4781. >         setApplicationEventListeners(null);
  4782.           setApplicationLifecycleListeners(null);
  4783.   

java/org/apache/catalina/core/StandardContext.java:4760: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.listenerStop()` indirectly reads without synchronization from container `this.applicationEventListenersList` via call to `toArray`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4758.   
  4759.           // Annotation processing
  4760. >         listeners = getApplicationEventListeners();
  4761.           if (listeners != null) {
  4762.               for (int i = 0; i < listeners.length; i++) {

java/org/apache/catalina/session/PersistentManagerBase.java:522: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PersistentManagerBase.load()` mutates container `this.sessions` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  520.   
  521.           // Initialize our internal data structures
  522. >         sessions.clear();
  523.   
  524.           if (store == null)

java/org/apache/catalina/session/StandardManager.java:162: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardManager.load()` indirectly mutates container `this.sessions` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  160.               }
  161.           } else {
  162. >             doLoad();
  163.           }
  164.       }

java/org/apache/catalina/storeconfig/StoreLoader.java:145: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StoreLoader.load(String)` writes to field `this.registryResource` outside of synchronization.
 Reporting because this access may occur on a background thread.
  143.                   : ConfigFileLoader.getSource().getResource(path);
  144.                   InputStream is = resource.getInputStream()) {
  145. >             registryResource = resource.getURI().toURL();
  146.               synchronized (digester) {
  147.                   registry = (StoreRegistry) digester.parse(is);

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:148: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `List MbeansDescriptorsDigesterSource.loadDescriptors(Registry,String,Object)` indirectly writes to field `this.registry` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  146.           setRegistry(registry);
  147.           setSource(source);
  148. >         execute();
  149.           return mbeans;
  150.       }

java/org/apache/catalina/core/StandardContext.java:4869: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean StandardContext.loadOnStartup(org.apache.catalina.Container[])` reads without synchronization from container `list` via call to `iterator`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4867.           // Load the collected "load on startup" servlets
  4868.           for (ArrayList<Wrapper> list : map.values()) {
  4869. >             for (Wrapper wrapper : list) {
  4870.                   try {
  4871.                       wrapper.load();

java/org/apache/catalina/core/StandardContext.java:4864: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean StandardContext.loadOnStartup(org.apache.catalina.Container[])` mutates container `list` via call to `add` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4862.                   map.put(key, list);
  4863.               }
  4864. >             list.add(wrapper);
  4865.           }
  4866.   

java/org/apache/jasper/servlet/JspServletWrapper.java:275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Class JspServletWrapper.loadTagFile()` reads without synchronization from `this.compileException`. Potentially races with write in method `JspServletWrapper.setCompilationException(...)`.
 Reporting because this access may occur on a background thread.
  273.                   }
  274.               } else {
  275. >                 if (compileException != null) {
  276.                       throw compileException;
  277.                   }

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java:742: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PooledConnection.lock()` reads without synchronization from `this.poolProperties`. Potentially races with write in method `PooledConnection.setPoolProperties(...)`.
 Reporting because this access may occur on a background thread.
  740.        */
  741.       public void lock() {
  742. >         if (poolProperties.getUseLock() || this.poolProperties.isPoolSweeperEnabled()) {
  743.               //optimized, only use a lock when there is concurrency
  744.               lock.writeLock().lock();

java/org/apache/catalina/valves/AccessLogValve.java:589: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AccessLogValve.log(CharArrayWriter)` indirectly reads without synchronization from `this.rotatable`. Potentially races with write in method `AccessLogValve.setRotatable(...)`.
 Reporting because this access may occur on a background thread.
  587.       public void log(CharArrayWriter message) {
  588.   
  589. >         rotate();
  590.   
  591.           /* In case something external rotated the file instead */

java/org/apache/catalina/valves/AccessLogValve.java:592: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AccessLogValve.log(CharArrayWriter)` reads without synchronization from `this.checkExists`. Potentially races with write in method `AccessLogValve.setCheckExists(...)`.
 Reporting because this access may occur on a background thread.
  590.   
  591.           /* In case something external rotated the file instead */
  592. >         if (checkExists) {
  593.               synchronized (this) {
  594.                   if (currentLogFile != null && !currentLogFile.exists()) {

java/org/apache/catalina/valves/JDBCAccessLogValve.java:494: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` indirectly writes to field `response.outputBuffer.conv.bb` outside of synchronization.
 Reporting because this access may occur on a background thread.
  492.           String query=request.getRequestURI();
  493.   
  494. >         long bytes = response.getBytesWritten(true);
  495.           if(bytes < 0) {
  496.               bytes = 0;

java/org/apache/catalina/valves/JDBCAccessLogValve.java:468: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` reads without synchronization from `this.resolveHosts`. Potentially races with write in method `JDBCAccessLogValve.setResolveHosts(...)`.
 Reporting because this access may occur on a background thread.
  466.   
  467.           String remoteHost;
  468. >         if(resolveHosts) {
  469.               if (requestAttributesEnabled) {
  470.                   Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);

java/org/apache/catalina/valves/JDBCAccessLogValve.java:472: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  470.                   Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);
  471.                   if (host == null) {
  472. >                     remoteHost = request.getRemoteHost();
  473.                   } else {
  474.                       remoteHost = (String) host;

java/org/apache/catalina/valves/JDBCAccessLogValve.java:503: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` reads without synchronization from `this.pattern`. Potentially races with write in method `JDBCAccessLogValve.setPattern(...)`.
 Reporting because this access may occur on a background thread.
  501.           String referer = EMPTY;
  502.           String userAgent = EMPTY;
  503. >         String logPattern = pattern;
  504.           if (logPattern.equals("combined")) {
  505.               virtualHost = request.getServerName();

java/org/apache/catalina/valves/JDBCAccessLogValve.java:507: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` indirectly writes to field `mh.byteC.charset` outside of synchronization.
 Reporting because this access may occur on a background thread.
  505.               virtualHost = request.getServerName();
  506.               method = request.getMethod();
  507. >             referer = request.getHeader("referer");
  508.               userAgent = request.getHeader("user-agent");
  509.           }

java/org/apache/catalina/valves/JDBCAccessLogValve.java:469: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` reads without synchronization from `this.requestAttributesEnabled`. Potentially races with write in method `JDBCAccessLogValve.setRequestAttributesEnabled(...)`.
 Reporting because this access may occur on a background thread.
  467.           String remoteHost;
  468.           if(resolveHosts) {
  469. >             if (requestAttributesEnabled) {
  470.                   Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);
  471.                   if (host == null) {

java/org/apache/catalina/valves/JDBCAccessLogValve.java:470: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.log(Request,Response,long)` indirectly writes to field `request.sslAttributesParsed` outside of synchronization.
 Reporting because this access may occur on a background thread.
  468.           if(resolveHosts) {
  469.               if (requestAttributesEnabled) {
  470. >                 Object host = request.getAttribute(REMOTE_HOST_ATTRIBUTE);
  471.                   if (host == null) {
  472.                       remoteHost = request.getRemoteHost();

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1249: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.login(String,String,Request)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1247.       public void login(String username, String password, Request request) throws ServletException {
  1248.           Principal principal = doLogin(request, username, password);
  1249. >         register(request, request.getResponse(), principal, getAuthMethod(), username, password);
  1250.       }
  1251.   

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1306: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.logout(Request)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1304.           }
  1305.   
  1306. >         register(request, request.getResponse(), null, null, null, null);
  1307.       }
  1308.   

java/org/apache/catalina/startup/Bootstrap.java:466: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Bootstrap.main(java.lang.String[])` indirectly reads without synchronization from `startup.Bootstrap.daemon.catalinaDaemon`. Potentially races with write in method `Bootstrap.main(...)`.
 Reporting because this access may occur on a background thread.
  464.               if (command.equals("startd")) {
  465.                   args[args.length - 1] = "start";
  466. >                 daemon.load(args);
  467.                   daemon.start();
  468.               } else if (command.equals("stopd")) {

java/org/apache/catalina/startup/Bootstrap.java:461: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Bootstrap.main(java.lang.String[])` reads without synchronization from `args.[_]`. Potentially races with write in method `Bootstrap.main(...)`.
 Reporting because this access may occur on a background thread.
  459.               String command = "start";
  460.               if (args.length > 0) {
  461. >                 command = args[args.length - 1];
  462.               }
  463.   

java/org/apache/catalina/startup/Bootstrap.java:454: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Bootstrap.main(java.lang.String[])` reads with synchronization from `startup.Bootstrap.daemon.catalinaLoader`. Potentially races with unsynchronized write in method `Bootstrap.main(...)`.
 Reporting because this access may occur on a background thread.
  452.                   // thread so make sure the correct class loader is used to
  453.                   // prevent a range of class not found exceptions.
  454. >                 Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
  455.               }
  456.           }

java/org/apache/catalina/startup/Bootstrap.java:465: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Bootstrap.main(java.lang.String[])` writes to field `args.[_]` outside of synchronization.
 Reporting because this access may occur on a background thread.
  463.   
  464.               if (command.equals("startd")) {
  465. >                 args[args.length - 1] = "start";
  466.                   daemon.load(args);
  467.                   daemon.start();

java/org/apache/catalina/startup/Bootstrap.java:467: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Bootstrap.main(java.lang.String[])` indirectly writes to field `startup.Bootstrap.daemon.catalinaDaemon` outside of synchronization.
 Reporting because this access may occur on a background thread.
  465.                   args[args.length - 1] = "start";
  466.                   daemon.load(args);
  467. >                 daemon.start();
  468.               } else if (command.equals("stopd")) {
  469.                   args[args.length - 1] = "stop";

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:43: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PooledObject PoolingConnection.makeObject(Object)` indirectly reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  41.    * @since 2.0
  42.    */
  43. > public class PoolingConnection extends DelegatingConnection<Connection>
  44.           implements KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement> {
  45.   

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:307: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PooledObject PoolingConnection.makeObject(PStmtKey)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  305.               final PreparedStatement statement = (PreparedStatement) key.createStatement(getDelegate());
  306.               @SuppressWarnings({"rawtypes", "unchecked" }) // Unable to find way to avoid this
  307. >             final PoolablePreparedStatement pps = new PoolablePreparedStatement(statement, key, pstmtPool, this);
  308.               return new DefaultPooledObject<>(pps);
  309.           }

java/org/apache/catalina/startup/HostConfig.java:1709: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.manageApp(Context)` reads without synchronization from container `this.deployed` via call to `containsKey`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1707.           String contextName = context.getName();
  1708.   
  1709. >         if (deployed.containsKey(contextName))
  1710.               return;
  1711.   

java/org/apache/catalina/startup/HostConfig.java:1743: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.manageApp(Context)` mutates container `this.deployed` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1741.               addWatchedResources(deployedApp, null, context);
  1742.           }
  1743. >         deployed.put(contextName, deployedApp);
  1744.       }
  1745.   

java/org/apache/catalina/mapper/Mapper.java:721: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Mapper.map(Context,MessageBytes,MappingData)` reads without synchronization from container `this.contextObjectToContextVersionMap` via call to `get`. Potentially races with write in method `Mapper.removeContextVersion(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.   
  720.           ContextVersion contextVersion =
  721. >                 contextObjectToContextVersionMap.get(context);
  722.           uri.toChars();
  723.           CharChunk uricc = uri.getCharChunk();

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:789: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.mapMemberAdded(Member)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `AbstractReplicatedMap.breakdown()`.
 Reporting because this access may occur on a background thread.
  787.   
  788.       public void mapMemberAdded(Member member) {
  789. >         if ( member.equals(getChannel().getLocalMember(false)) ) return;
  790.           boolean memberAdded = false;
  791.           //select a backup node if we don't have one

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:526: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.memberAdded(Member)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  524.       @Override
  525.       public void memberAdded(Member member) {
  526. >         memberAdded(member,true);
  527.       }
  528.   

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:124: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.memberAdded(Member)` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  122.       @Override
  123.       public void memberAdded(Member member) {
  124. >         if ( membership == null ) setupMembership();
  125.           boolean notify = false;
  126.           synchronized (membership) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:534: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.memberAdded(Member,boolean)` indirectly reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  532.           try {
  533.               fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_ADD,this,"Member add("+member.getName()+")"));
  534. >             if (started && elect) startElection(false);
  535.           } catch (ChannelException x) {
  536.               log.error(sm.getString("nonBlockingCoordinator.memberAdded.failed"),x);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:530: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.memberAdded(Member,boolean)` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  528.   
  529.       public void memberAdded(Member member,boolean elect) {
  530. >         if (membership == null) setupMembership();
  531.           if (membership.memberAlive(member)) super.memberAdded(member);
  532.           try {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:333: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.memberAlive(Member)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `AbstractReplicatedMap.breakdown()`.
 Reporting because this access may occur on a background thread.
  331.        */
  332.       protected void memberAlive(Member member) {
  333. >         mapMemberAdded(member);
  334.           synchronized (mapMembers) {
  335.               mapMembers.put(member, Long.valueOf(System.currentTimeMillis()));

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:542: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.memberDisappeared(Member)` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  540.       @Override
  541.       public void memberDisappeared(Member member) {
  542. >         membership.removeMember(member);
  543.           super.memberDisappeared(member);
  544.           try {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:547: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.memberDisappeared(Member)` indirectly reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  545.               fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MBR_DEL,this,"Member remove("+member.getName()+")"));
  546.               if (started && (isCoordinator() || isHighest()))
  547. >                 startElection(true); //to do, if a member disappears, only the coordinator can start
  548.           } catch (ChannelException x) {
  549.               log.error(sm.getString("nonBlockingCoordinator.memberDisappeared.failed"),x);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:185: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void OrderInterceptor.memberDisappeared(Member)` mutates container `this.outcounter` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  183.           //reset counters - lock free
  184.           incounter.remove(member);
  185. >         outcounter.remove(member);
  186.           //clear the remaining queue
  187.           processLeftOvers(member,true);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:187: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void OrderInterceptor.memberDisappeared(Member)` indirectly writes to field `tmp.msg` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  185.           outcounter.remove(member);
  186.           //clear the remaining queue
  187. >         processLeftOvers(member,true);
  188.           //notify upwards
  189.           super.memberDisappeared(member);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:184: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void OrderInterceptor.memberDisappeared(Member)` mutates container `this.incounter` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  182.       public void memberDisappeared(Member member) {
  183.           //reset counters - lock free
  184. >         incounter.remove(member);
  185.           outcounter.remove(member);
  186.           //clear the remaining queue

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:149: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.memberDisappeared(Member)` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  147.       @Override
  148.       public void memberDisappeared(Member member) {
  149. >         if ( membership == null ) setupMembership();
  150.           boolean shutdown = Arrays.equals(member.getCommand(),Member.SHUTDOWN_PAYLOAD);
  151.           if (shutdown) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:898: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.copy` outside of synchronization.
 Reporting because this access may occur on a background thread.
  896.                       entry.setBackup(false);
  897.                       entry.setProxy(false);
  898. >                     entry.setCopy(false);
  899.                       Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
  900.                       entry.setBackupNodes(backup);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:870: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.backupNodes` outside of synchronization.
 Reporting because this access may occur on a background thread.
  868.                   try {
  869.                       Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
  870. >                     entry.setBackupNodes(backup);
  871.                       entry.setPrimary(channel.getLocalMember(false));
  872.                   } catch (ChannelException x) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:866: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly reads without synchronization from `entry.backup`. Potentially races with write in method `AbstractReplicatedMap.transferState()`.
 Reporting because this access may occur on a background thread.
  864.               MapEntry<K,V> entry = innerMap.get(e.getKey());
  865.               if (entry==null) continue;
  866. >             if (entry.isPrimary() && inSet(member,entry.getBackupNodes())) {
  867.                   if (log.isDebugEnabled()) log.debug("[1] Primary choosing a new backup");
  868.                   try {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:896: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.backup` outside of synchronization.
 Reporting because this access may occur on a background thread.
  894.                       if (log.isDebugEnabled()) log.debug("[4] Backup becoming primary");
  895.                       entry.setPrimary(channel.getLocalMember(false));
  896. >                     entry.setBackup(false);
  897.                       entry.setProxy(false);
  898.                       entry.setCopy(false);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:871: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.primary` outside of synchronization.
 Reporting because this access may occur on a background thread.
  869.                       Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
  870.                       entry.setBackupNodes(backup);
  871. >                     entry.setPrimary(channel.getLocalMember(false));
  872.                   } catch (ChannelException x) {
  873.                       log.error(sm.getString("abstractReplicatedMap.unable.relocate", entry.getKey()), x);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:901: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` reads without synchronization from `this.mapOwner`. Potentially races with write in method `AbstractReplicatedMap.setMapOwner(...)`.
 Reporting because this access may occur on a background thread.
  899.                       Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
  900.                       entry.setBackupNodes(backup);
  901. >                     if ( mapOwner!=null ) mapOwner.objectMadePrimary(entry.getKey(),entry.getValue());
  902.   
  903.                   } catch (ChannelException x) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:875: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly reads without synchronization from `entry.primary`. Potentially races with write in method `AbstractReplicatedMap.transferState()`.
 Reporting because this access may occur on a background thread.
  873.                       log.error(sm.getString("abstractReplicatedMap.unable.relocate", entry.getKey()), x);
  874.                   }
  875. >             } else if (member.equals(entry.getPrimary())) {
  876.                   if (log.isDebugEnabled()) log.debug("[2] Primary disappeared");
  877.                   entry.setPrimary(null);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:897: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.proxy` outside of synchronization.
 Reporting because this access may occur on a background thread.
  895.                       entry.setPrimary(channel.getLocalMember(false));
  896.                       entry.setBackup(false);
  897. >                     entry.setProxy(false);
  898.                       entry.setCopy(false);
  899.                       Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:203: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.backupNodes` outside of synchronization.
 Reporting because this access may occur on a background thread.
  201.                           getChannel().send(backup, msg, getChannelSendOptions());
  202.                       }
  203. >                     entry.setBackupNodes(backup);
  204.                       entry.setPrimary(channel.getLocalMember(false));
  205.                   } catch (ChannelException x) {

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:208: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly reads without synchronization from `entry.primary`. Potentially races with write in method `ReplicatedMap.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  206.                       log.error(sm.getString("replicatedMap.unable.relocate", entry.getKey()), x);
  207.                   }
  208. >             } else if (member.equals(entry.getPrimary())) {
  209.                   entry.setPrimary(null);
  210.               }

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:221: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.copy` outside of synchronization.
 Reporting because this access may occur on a background thread.
  219.                       entry.setBackup(false);
  220.                       entry.setProxy(false);
  221. >                     entry.setCopy(false);
  222.                       Member[] backup = getMapMembers();
  223.                       if (backup.length > 0) {

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:220: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.proxy` outside of synchronization.
 Reporting because this access may occur on a background thread.
  218.                       entry.setPrimary(channel.getLocalMember(false));
  219.                       entry.setBackup(false);
  220. >                     entry.setProxy(false);
  221.                       entry.setCopy(false);
  222.                       Member[] backup = getMapMembers();

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:204: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.primary` outside of synchronization.
 Reporting because this access may occur on a background thread.
  202.                       }
  203.                       entry.setBackupNodes(backup);
  204. >                     entry.setPrimary(channel.getLocalMember(false));
  205.                   } catch (ChannelException x) {
  206.                       log.error(sm.getString("replicatedMap.unable.relocate", entry.getKey()), x);

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:214: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly reads without synchronization from `entry.backupNodes`. Potentially races with write in method `ReplicatedMap.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  212.               if ( entry.getPrimary() == null &&
  213.                           entry.isCopy() &&
  214. >                         entry.getBackupNodes()!=null &&
  215.                           entry.getBackupNodes().length > 0 &&
  216.                           entry.getBackupNodes()[0].equals(channel.getLocalMember(false)) ) {

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:195: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly reads without synchronization from `entry.backup`. Potentially races with write in method `ReplicatedMap.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  193.               MapEntry<K,V> entry = innerMap.get(e.getKey());
  194.               if (entry==null) continue;
  195. >             if (entry.isPrimary()) {
  196.                   try {
  197.                       Member[] backup = getMapMembers();

java/org/apache/catalina/tribes/tipis/ReplicatedMap.java:219: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicatedMap.memberDisappeared(Member)` indirectly writes to field `entry.backup` outside of synchronization.
 Reporting because this access may occur on a background thread.
  217.                   try {
  218.                       entry.setPrimary(channel.getLocalMember(false));
  219. >                     entry.setBackup(false);
  220.                       entry.setProxy(false);
  221.                       entry.setCopy(false);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:326: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Membership NonBlockingCoordinator.mergeOnArrive(NonBlockingCoordinator$CoordinationMessage)` indirectly reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  324.           for ( int i=0; i<diff.length; i++ ) {
  325.               if (!alive(diff[i])) merged.removeMember(diff[i]);
  326. >             else memberAdded(diff[i],false);
  327.           }
  328.           fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_POST_MERGE,this,"Post merge"));

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:318: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Membership NonBlockingCoordinator.mergeOnArrive(NonBlockingCoordinator$CoordinationMessage)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.   
  317.       protected Membership mergeOnArrive(CoordinationMessage msg) {
  318. >         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_PRE_MERGE,this,"Pre merge"));
  319.           Member local = getLocalMember(false);
  320.           Membership merged = new Membership(local,AbsoluteOrder.comp,true);

java/org/apache/catalina/tribes/group/RpcChannel.java:155: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` writes to field `rmsg.message` outside of synchronization.
 Reporting because this access may occur on a background thread.
  153.               }
  154.               rmsg.reply = true;
  155. >             rmsg.message = reply;
  156.               try {
  157.                   if (handler!=null) {

java/org/apache/catalina/tribes/group/RpcChannel.java:135: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` reads without synchronization from `this.callback`. Potentially races with write in method `RpcChannel.setCallback(...)`.
 Reporting because this access may occur on a background thread.
  133.           } else {
  134.               boolean finished = false;
  135. >             final ExtendedRpcCallback excallback = (callback instanceof ExtendedRpcCallback)?((ExtendedRpcCallback)callback) : null;
  136.               boolean asyncReply = ((replyMessageOptions & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS);
  137.               Serializable reply = callback.replyRequest(rmsg.message,sender);

java/org/apache/catalina/tribes/group/RpcChannel.java:154: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` writes to field `rmsg.reply` outside of synchronization.
 Reporting because this access may occur on a background thread.
  152.                   };
  153.               }
  154. >             rmsg.reply = true;
  155.               rmsg.message = reply;
  156.               try {

java/org/apache/catalina/tribes/group/RpcChannel.java:113: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` reads without synchronization from `rmsg.reply`. Potentially races with write in method `RpcChannel.messageReceived(...)`.
 Reporting because this access may occur on a background thread.
  111.           RpcMessage rmsg = (RpcMessage)msg;
  112.           RpcCollectorKey key = new RpcCollectorKey(rmsg.uuid);
  113. >         if ( rmsg.reply ) {
  114.               RpcCollector collector = responseMap.get(key);
  115.               if (collector == null) {

java/org/apache/catalina/tribes/group/RpcChannel.java:158: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` reads without synchronization from `this.channel`. Potentially races with write in method `RpcChannel.setChannel(...)`.
 Reporting because this access may occur on a background thread.
  156.               try {
  157.                   if (handler!=null) {
  158. >                     channel.send(new Member[] {sender}, rmsg,replyMessageOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK, handler);
  159.                   } else {
  160.                       channel.send(new Member[] {sender}, rmsg,replyMessageOptions & ~Channel.SEND_OPTIONS_SYNCHRONIZED_ACK);

java/org/apache/catalina/tribes/group/RpcChannel.java:136: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` reads without synchronization from `this.replyMessageOptions`. Potentially races with write in method `RpcChannel.setReplyMessageOptions(...)`.
 Reporting because this access may occur on a background thread.
  134.               boolean finished = false;
  135.               final ExtendedRpcCallback excallback = (callback instanceof ExtendedRpcCallback)?((ExtendedRpcCallback)callback) : null;
  136. >             boolean asyncReply = ((replyMessageOptions & Channel.SEND_OPTIONS_ASYNCHRONOUS) == Channel.SEND_OPTIONS_ASYNCHRONOUS);
  137.               Serializable reply = callback.replyRequest(rmsg.message,sender);
  138.               ErrorHandler handler = null;

java/org/apache/catalina/tribes/group/RpcChannel.java:125: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RpcChannel.messageReceived(Serializable,Member)` reads with synchronization from `rmsg.message`. Potentially races with unsynchronized write in method `RpcChannel.messageReceived(...)`.
 Reporting because this access may occur on a background thread.
  123.                               collector.destcnt--;
  124.                           else
  125. >                             collector.addResponse(rmsg.message, sender);
  126.                           if (collector.isComplete()) collector.notifyAll();
  127.                       } else {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:690: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.proxy` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  688.                   }
  689.               }
  690. >             entry.setProxy(true);
  691.               entry.setBackup(false);
  692.               entry.setCopy(false);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:694: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.primary` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  692.               entry.setCopy(false);
  693.               entry.setBackupNodes(mapmsg.getBackupNodes());
  694. >             entry.setPrimary(mapmsg.getPrimary());
  695.           }
  696.   

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:693: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.backupNodes` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  691.               entry.setBackup(false);
  692.               entry.setCopy(false);
  693. >             entry.setBackupNodes(mapmsg.getBackupNodes());
  694.               entry.setPrimary(mapmsg.getPrimary());
  695.           }

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:663: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  661.   
  662.           try {
  663. >             mapmsg.deserialize(getExternalLoaders());
  664.           } catch (IOException x) {
  665.               log.error(sm.getString("abstractReplicatedMap.unable.deserialize.MapMessage"), x);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:719: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly reads without synchronization from `entry.value`. Potentially races with write in method `AbstractReplicatedMap.transferState()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  717.                   entry.setBackupNodes(mapmsg.getBackupNodes());
  718.                   entry.setPrimary(mapmsg.getPrimary());
  719. >                 if (entry.getValue() instanceof ReplicatedMapEntry) {
  720.                       ReplicatedMapEntry diff = (ReplicatedMapEntry) entry.getValue();
  721.                       if (mapmsg.isDiff()) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:678: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.backup` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  676.   
  677.           if (mapmsg.getMsgType() == MapMessage.MSG_STOP) {
  678. >             memberDisappeared(mapmsg.getPrimary());
  679.           }
  680.   

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:691: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.backup` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  689.               }
  690.               entry.setProxy(true);
  691. >             entry.setBackup(false);
  692.               entry.setCopy(false);
  693.               entry.setBackupNodes(mapmsg.getBackupNodes());

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:735: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.value` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  733.                                   ReplicatedMapEntry re = (ReplicatedMapEntry)mapmsg.getValue();
  734.                                   re.setOwner(getMapOwner());
  735. >                                 entry.setValue((V) re);
  736.                               } else {
  737.                                   entry.setValue((V) mapmsg.getValue());

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:692: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.messageReceived(Serializable,Member)` indirectly writes to field `entry.copy` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  690.               entry.setProxy(true);
  691.               entry.setBackup(false);
  692. >             entry.setCopy(false);
  693.               entry.setBackupNodes(mapmsg.getBackupNodes());
  694.               entry.setPrimary(mapmsg.getPrimary());

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:255: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FarmWarDeployer.messageReceived(ClusterMessage)` indirectly mutates container `this.fileFactories` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  253.                           log.error(sm.getString("farmWarDeployer.fileMessageError"), ex);
  254.                       } finally {
  255. >                         removeFactory(fmsg);
  256.                       }
  257.                   }

java/org/apache/catalina/ha/session/DeltaManager.java:1189: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.messageReceived(SessionMessage,Member)` indirectly writes to field `this.counterReceive_EVT_ALL_SESSION_NOCONTEXTMANAGER` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1187.                       break;
  1188.                   case SessionMessage.EVT_ALL_SESSION_NOCONTEXTMANAGER:
  1189. >                     handleALL_SESSION_NOCONTEXTMANAGER(msg,sender);
  1190.                       break;
  1191.                   default:

java/org/apache/catalina/ha/session/DeltaManager.java:1165: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.messageReceived(SessionMessage,Member)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1163.               switch (msg.getEventType()) {
  1164.                   case SessionMessage.EVT_GET_ALL_SESSIONS:
  1165. >                     handleGET_ALL_SESSIONS(msg,sender);
  1166.                       break;
  1167.                   case SessionMessage.EVT_ALL_SESSION_DATA:

java/org/apache/catalina/ha/session/DeltaManager.java:1180: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.messageReceived(SessionMessage,Member)` indirectly writes to field `this.counterReceive_EVT_SESSION_ACCESSED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1178.                       break;
  1179.                   case SessionMessage.EVT_SESSION_ACCESSED:
  1180. >                     handleSESSION_ACCESSED(msg,sender);
  1181.                       break;
  1182.                   case SessionMessage.EVT_SESSION_DELTA:

java/org/apache/catalina/ha/session/DeltaManager.java:1186: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.messageReceived(SessionMessage,Member)` indirectly writes to field `this.counterReceive_EVT_CHANGE_SESSION_ID` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1184.                      break;
  1185.                   case SessionMessage.EVT_CHANGE_SESSION_ID:
  1186. >                     handleCHANGE_SESSION_ID(msg,sender);
  1187.                       break;
  1188.                   case SessionMessage.EVT_ALL_SESSION_NOCONTEXTMANAGER:

java/org/apache/catalina/ha/session/DeltaManager.java:1171: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.messageReceived(SessionMessage,Member)` indirectly writes to field `this.counterReceive_EVT_ALL_SESSION_TRANSFERCOMPLETE` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1169.                       break;
  1170.                   case SessionMessage.EVT_ALL_SESSION_TRANSFERCOMPLETE:
  1171. >                     handleALL_SESSION_TRANSFERCOMPLETE(msg,sender);
  1172.                       break;
  1173.                   case SessionMessage.EVT_SESSION_CREATED:

java/org/apache/catalina/tribes/group/GroupChannel.java:346: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GroupChannel.messageReceived(ChannelMessage)` indirectly reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  344.                   //if we have a message that requires a response,
  345.                   //but none was given, send back an immediate one
  346. >                 sendNoRpcChannelReply((RpcMessage)fwd,source);
  347.               }
  348.               if ( Logs.MESSAGES.isTraceEnabled() ) {

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:73: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FragmentationInterceptor.messageReceived(ChannelMessage)` indirectly mutates container `this.fragpieces` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  71.           msg.getMessage().trim(1);
  72.           if ( isFrag ) {
  73. >             defrag(msg);
  74.           } else {
  75.               super.messageReceived(msg);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:515: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.messageReceived(ChannelMessage)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  513.                   Member[] cmbr = cmsg.getMembers();
  514.                   fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_MSG_ARRIVE,this,"Coord Msg Arrived("+Arrays.toNameString(cmbr)+")"));
  515. >                 processCoordMessage(cmsg);
  516.               }catch ( ChannelException x ) {
  517.                   log.error(sm.getString("nonBlockingCoordinator.processCoordinationMessage.failed"),x);

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:80: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StaticMembershipInterceptor.messageReceived(ChannelMessage)` indirectly reads without synchronization from container `this.members` via call to `indexOf`. Potentially races with write in method `StaticMembershipInterceptor.addStaticMember(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  78.                   Arrays.equals(MEMBER_START, msg.getMessage().getBytes())) {
  79.               // receive member start
  80. >             Member member = getMember(msg.getAddress());
  81.               if (member != null) {
  82.                   super.memberAdded(member);

java/org/apache/catalina/loader/WebappClassLoaderBase.java:738: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean WebappClassLoaderBase.modified()` reads without synchronization from container `this.resourceEntries` via call to `entrySet`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  736.               log.debug("modified()");
  737.   
  738. >         for (Entry<String,ResourceEntry> entry : resourceEntries.entrySet()) {
  739.               long cachedLastModified = entry.getValue().lastModified;
  740.               long lastModified = resources.getClassLoaderResource(

java/org/apache/catalina/realm/DigestCredentialHandlerBase.java:108: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestCredentialHandlerBase.mutate(String)` indirectly reads without synchronization from `this.iterations`. Potentially races with write in method `DigestCredentialHandlerBase.setIterations(...)`.
 Reporting because this access may occur on a background thread.
  106.       public String mutate(String userCredential) {
  107.           byte[] salt = null;
  108. >         int iterations = getIterations();
  109.           int saltLength = getSaltLength();
  110.           if (saltLength == 0) {

java/org/apache/catalina/realm/DigestCredentialHandlerBase.java:109: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String DigestCredentialHandlerBase.mutate(String)` indirectly reads without synchronization from `this.saltLength`. Potentially races with write in method `DigestCredentialHandlerBase.setSaltLength(...)`.
 Reporting because this access may occur on a background thread.
  107.           byte[] salt = null;
  108.           int iterations = getIterations();
  109. >         int saltLength = getSaltLength();
  110.           if (saltLength == 0) {
  111.               salt = new byte[0];

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:1293: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Object LinkedBlockingDeque$AbstractItr.next()` reads without synchronization from `this.next`. Potentially races with write in method `LinkedBlockingDeque$AbstractItr.advance()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1291.           @Override
  1292.           public E next() {
  1293. >             if (next == null) {
  1294.                   throw new NoSuchElementException();
  1295.               }

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:1296: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Object LinkedBlockingDeque$AbstractItr.next()` writes to field `this.lastRet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1294.                   throw new NoSuchElementException();
  1295.               }
  1296. >             lastRet = next;
  1297.               final E x = nextItem;
  1298.               advance();

java/org/apache/coyote/http2/Stream.java:326: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Stream.notifyConnection()` indirectly reads without synchronization from `this.allocationManager.waitingFor`. Potentially races with write in method `Stream.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  324.   
  325.       void notifyConnection() {
  326. >         allocationManager.notifyConnection();
  327.       }
  328.   

java/org/apache/coyote/http2/Http2Parser.java:592: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2Parser.onHeadersComplete(int)` indirectly reads without synchronization from `this.hpackDecoder.headerEmitter`. Potentially races with write in method `Http2Parser.readConnectionPreface(...)`.
 Reporting because this access may occur on a background thread.
  590.           // since all the headers still have to be read if a StreamException is
  591.           // going to be thrown.
  592. >         hpackDecoder.getHeaderEmitter().validateHeaders();
  593.   
  594.           synchronized (output) {

java/org/apache/catalina/realm/JDBCRealm.java:654: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCRealm.open()` writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  652.           if (connectionPassword != null)
  653.               props.put("password", connectionPassword);
  654. >         dbConnection = driver.connect(connectionURL, props);
  655.           if (dbConnection == null) {
  656.               throw new SQLException(sm.getString(

java/org/apache/catalina/realm/JDBCRealm.java:638: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection JDBCRealm.open()` reads without synchronization from `this.driver`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  636.   
  637.           // Instantiate our database driver if necessary
  638. >         if (driver == null) {
  639.               try {
  640.                   Class<?> clazz = Class.forName(driverName);

java/org/apache/catalina/realm/JDBCRealm.java:634: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection JDBCRealm.open()` reads without synchronization from `this.dbConnection`. Potentially races with write in method `JDBCRealm.authenticate(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  632.   
  633.           // Do nothing if there is a database connection already open
  634. >         if (dbConnection != null)
  635.               return dbConnection;
  636.   

java/org/apache/catalina/realm/JDBCRealm.java:641: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCRealm.open()` writes to field `this.driver` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  639.               try {
  640.                   Class<?> clazz = Class.forName(driverName);
  641. >                 driver = (Driver) clazz.getConstructor().newInstance();
  642.               } catch (Throwable e) {
  643.                   ExceptionUtils.handleThrowable(e);

java/org/apache/catalina/session/JDBCStore.java:923: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCStore.open()` writes to field `this.driver` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  921.               try {
  922.                   Class<?> clazz = Class.forName(driverName);
  923. >                 driver = (Driver) clazz.getConstructor().newInstance();
  924.               } catch (ReflectiveOperationException e) {
  925.                   manager.getContext().getLogger().error(

java/org/apache/catalina/session/JDBCStore.java:889: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection JDBCStore.open()` reads without synchronization from `this.dbConnection`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  887.   
  888.           // Do nothing if there is a database connection already open
  889. >         if (dbConnection != null)
  890.               return dbConnection;
  891.   

java/org/apache/catalina/session/JDBCStore.java:920: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection JDBCStore.open()` reads without synchronization from `this.driver`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  918.   
  919.           // Instantiate our database driver if necessary
  920. >         if (driver == null) {
  921.               try {
  922.                   Class<?> clazz = Class.forName(driverName);

java/org/apache/catalina/session/JDBCStore.java:938: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCStore.open()` writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  936.           if (connectionPassword != null)
  937.               props.put("password", connectionPassword);
  938. >         dbConnection = driver.connect(connectionURL, props);
  939.           dbConnection.setAutoCommit(true);
  940.           return dbConnection;

java/org/apache/catalina/session/JDBCStore.java:903: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Connection JDBCStore.open()` writes to field `this.dataSource` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  901.                   initCtx = new InitialContext();
  902.                   Context envCtx = (Context) initCtx.lookup("java:comp/env");
  903. >                 this.dataSource = (DataSource) envCtx.lookup(this.dataSourceName);
  904.               } catch (NamingException e) {
  905.                   context.getLogger().error(

java/org/apache/catalina/session/JDBCStore.java:892: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Connection JDBCStore.open()` reads without synchronization from `this.dataSource`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  890.               return dbConnection;
  891.   
  892. >         if (dataSourceName != null && dataSource == null) {
  893.               org.apache.catalina.Context context = getManager().getContext();
  894.               ClassLoader oldThreadContextCL = null;

java/org/apache/catalina/valves/JDBCAccessLogValve.java:571: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.open()` writes to field `this.driver` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  569.               try {
  570.                   Class<?> clazz = Class.forName(driverName);
  571. >                 driver = (Driver) clazz.getConstructor().newInstance();
  572.               } catch (Throwable e) {
  573.                   ExceptionUtils.handleThrowable(e);

java/org/apache/catalina/valves/JDBCAccessLogValve.java:586: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.open()` writes to field `this.conn` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  584.               props.put("password", connectionPassword);
  585.           }
  586. >         conn = driver.connect(connectionURL, props);
  587.           conn.setAutoCommit(true);
  588.           String logPattern = pattern;

java/org/apache/catalina/valves/JDBCAccessLogValve.java:568: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.open()` reads without synchronization from `this.driver`. Potentially races with write in method `JDBCAccessLogValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  566.   
  567.           // Instantiate our database driver if necessary
  568. >         if (driver == null) {
  569.               try {
  570.                   Class<?> clazz = Class.forName(driverName);

java/org/apache/catalina/valves/JDBCAccessLogValve.java:563: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCAccessLogValve.open()` reads without synchronization from `this.conn`. Potentially races with write in method `JDBCAccessLogValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  561.   
  562.           // Do nothing if there is a database connection already open
  563. >         if (conn != null) {
  564.               return ;
  565.           }

java/org/apache/catalina/valves/JDBCAccessLogValve.java:591: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCAccessLogValve.open()` writes to field `this.ps` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  589.           if (logPattern.equals("common")) {
  590.                   ps = conn.prepareStatement
  591. >                     ("INSERT INTO " + tableName + " ("
  592.                        + remoteHostField + ", " + userField + ", "
  593.                        + timestampField +", " + queryField + ", "

java/org/apache/catalina/valves/rewrite/RewriteValve.java:263: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.parse(BufferedReader)` writes to field `this.rules` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  261.               }
  262.           }
  263. >         this.rules = rules.toArray(new RewriteRule[0]);
  264.   
  265.           // Finish parsing the rules

java/org/apache/catalina/valves/rewrite/RewriteValve.java:251: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.parse(BufferedReader)` mutates container `this.maps` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  249.                       String mapName = (String) ((Object[]) result)[0];
  250.                       RewriteMap map = (RewriteMap) ((Object[]) result)[1];
  251. >                     maps.put(mapName, map);
  252.                       // Keep the original configuration line as it is not possible to get
  253.                       // the parameters back without an API change

java/org/apache/catalina/valves/rewrite/RewriteValve.java:266: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RewriteValve.parse(BufferedReader)` reads without synchronization from `this.rules`. Potentially races with write in method `RewriteValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  264.   
  265.           // Finish parsing the rules
  266. >         for (int i = 0; i < this.rules.length; i++) {
  267.               this.rules[i].parse(maps);
  268.           }

java/org/apache/catalina/valves/rewrite/RewriteValve.java:267: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.parse(BufferedReader)` indirectly writes to field `this.rules.[_].conditions.[_].condPattern` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  265.           // Finish parsing the rules
  266.           for (int i = 0; i < this.rules.length; i++) {
  267. >             this.rules[i].parse(maps);
  268.           }
  269.       }

java/org/apache/catalina/valves/rewrite/RewriteValve.java:254: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.parse(BufferedReader)` mutates container `this.mapsConfiguration` via call to `add` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  252.                       // Keep the original configuration line as it is not possible to get
  253.                       // the parameters back without an API change
  254. >                     mapsConfiguration.add(line);
  255.                       if (map instanceof Lifecycle) {
  256.                           ((Lifecycle) map).start();

java/org/apache/catalina/valves/rewrite/RewriteValve.java:242: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.parse(BufferedReader)` indirectly writes to field `conditions.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  240.                                       + (cond.isNocase() ? " [NC]" : ""));
  241.                           }
  242. >                         rule.addCondition(conditions.get(i));
  243.                       }
  244.                       conditions.clear();

java/org/apache/catalina/authenticator/DigestAuthenticator.java:469: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator$DigestInfo.parse(Request,String)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  467.               }
  468.   
  469. >             method = request.getMethod();
  470.               userName = directives.get("username");
  471.               realmName = directives.get("realm");

java/org/apache/coyote/AbstractProcessor.java:303: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.parseHost(MessageBytes)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  301.                       if (c < '0' || c > '9') {
  302.                           response.setStatus(400);
  303. >                         setErrorState(ErrorState.CLOSE_CLEAN, null);
  304.                           return;
  305.                       }

java/org/apache/catalina/session/StandardSession.java:882: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.passivate()` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  880.               if (attribute instanceof HttpSessionActivationListener) {
  881.                   if (event == null)
  882. >                     event = new HttpSessionEvent(getSession());
  883.                   try {
  884.                       ((HttpSessionActivationListener)attribute)

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:305: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.performBasicCheck()` reads without synchronization from container `this.addSuspects` via call to `size`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  303.           //check add suspects members if they are alive now,
  304.           //if they are, simply issue the memberAdded message
  305. >         keys = addSuspects.keySet().toArray(new Member[addSuspects.size()]);
  306.           for (int i = 0; i < keys.length; i++) {
  307.               Member m = keys[i];

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:280: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.performBasicCheck()` reads without synchronization from container `this.removeSuspects` via call to `size`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  278.           //check suspect members if they are still alive,
  279.           //if not, simply issue the memberDisappeared message
  280. >         Member[] keys = removeSuspects.keySet().toArray(new Member[removeSuspects.size()]);
  281.           for (int i = 0; i < keys.length; i++) {
  282.               Member m = keys[i];

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:289: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void TcpFailureDetector.performBasicCheck()` mutates container `this.removeSuspects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  287.                   }
  288.                   super.memberDisappeared(m);
  289. >                 removeSuspects.remove(m);
  290.                   if(log.isInfoEnabled())
  291.                       log.info(sm.getString("tcpFailureDetector.suspectMember.dead", m));

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:263: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.performBasicCheck()` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  261.           Member[] members = super.getMembers();
  262.           for (int i = 0; members != null && i < members.length; i++) {
  263. >             if (addSuspects.containsKey(members[i]) && membership.getMember(members[i]) == null) {
  264.                   // avoid temporary adding member.
  265.                   continue;

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:311: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void TcpFailureDetector.performBasicCheck()` mutates container `this.addSuspects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  309.                   membership.memberAlive(m);
  310.                   super.memberAdded(m);
  311. >                 addSuspects.remove(m);
  312.                   if(log.isInfoEnabled())
  313.                       log.info(sm.getString("tcpFailureDetector.suspectMember.alive", m));

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:248: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void TcpFailureDetector.performForcedCheck()` mutates container `this.removeSuspects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  246.                   if (membership.getMember(members[i])!=null) {
  247.                       membership.removeMember(members[i]);
  248. >                     removeSuspects.remove(members[i]);
  249.                       if (members[i] instanceof StaticMember) {
  250.                           addSuspects.put(members[i], Long.valueOf(System.currentTimeMillis()));

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:243: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpFailureDetector.performForcedCheck()` reads without synchronization from `this.membership`. Potentially races with write in method `TcpFailureDetector.memberDisappeared(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  241.           for (int i = 0; members != null && i < members.length; i++) {
  242.               if (memberAlive(members[i])) {
  243. >                 if (membership.memberAlive(members[i])) super.memberAdded(members[i]);
  244.                   addSuspects.remove(members[i]);
  245.               } else {

java/org/apache/catalina/tribes/group/interceptors/TcpFailureDetector.java:244: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void TcpFailureDetector.performForcedCheck()` mutates container `this.addSuspects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  242.               if (memberAlive(members[i])) {
  243.                   if (membership.memberAlive(members[i])) super.memberAdded(members[i]);
  244. >                 addSuspects.remove(members[i]);
  245.               } else {
  246.                   if (membership.getMember(members[i])!=null) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:286: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.ping(long)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `AbstractReplicatedMap.breakdown()`.
 Reporting because this access may occur on a background thread.
  284.                           State state = (State) mapMsg.getValue();
  285.                           if (state.isAvailable()) {
  286. >                             memberAlive(member);
  287.                           } else if (state == State.STATETRANSFERRED) {
  288.                               synchronized (mapMembers) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:270: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.ping(long)` reads without synchronization from `this.mapContextName`. Potentially races with write in method `AbstractReplicatedMap.init(...)`.
 Reporting because this access may occur on a background thread.
  268.                                           null,
  269.                                           null,
  270. >                                         channel.getLocalMember(false),
  271.                                           null);
  272.           if ( channel.getMembers().length > 0 ) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:275: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.ping(long)` reads without synchronization from `this.accessTimeout`. Potentially races with write in method `AbstractReplicatedMap.setAccessTimeout(...)`.
 Reporting because this access may occur on a background thread.
  273.               try {
  274.                   //send a ping, wait for all nodes to reply
  275. >                 Response[] resp = rpcChannel.send(channel.getMembers(),
  276.                                                     msg, RpcChannel.ALL_REPLY,
  277.                                                     (channelSendOptions),

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:282: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.ping(long)` indirectly writes to field `mapMsg.key` outside of synchronization.
 Reporting because this access may occur on a background thread.
  280.                       MapMessage mapMsg = (MapMessage)resp[i].getMessage();
  281.                       try {
  282. >                         mapMsg.deserialize(getExternalLoaders());
  283.                           Member member = resp[i].getSource();
  284.                           State state = (State) mapMsg.getValue();

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:322: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.ping(long)` indirectly reads with synchronization from `entry.backup`. Potentially races with unsynchronized write in method `AbstractReplicatedMap.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  320.                   if ( (now - access) > timeout ) {
  321.                       log.warn(sm.getString("abstractReplicatedMap.ping.timeout", member, mapname));
  322. >                     memberDisappeared(member);
  323.                   }
  324.               }

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:1574: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ObjectName BasicDataSource.preRegister(MBeanServer,ObjectName)` writes to field `this.registeredJmxObjectName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1572.           if (requestedName != null) {
  1573.               try {
  1574. >                 registeredJmxObjectName = ObjectNameWrapper.wrap(requestedName);
  1575.               } catch (final MalformedObjectNameException e) {
  1576.                   log.warn("The requested JMX name [" + requestedName + "] was not valid and will be ignored.");

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:1579: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ObjectName BasicDataSource.preRegister(MBeanServer,ObjectName)` reads without synchronization from `this.registeredJmxObjectName`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1577.               }
  1578.           }
  1579. >         if (registeredJmxObjectName == null) {
  1580.               registeredJmxObjectName = ObjectNameWrapper.wrap(objectName);
  1581.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:356: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CallableStatement PoolingConnection.prepareCall(String)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  354.       public CallableStatement prepareCall(final String sql) throws SQLException {
  355.           try {
  356. >             return (CallableStatement) pstmtPool.borrowObject(createKey(sql, StatementType.CALLABLE_STATEMENT));
  357.           } catch (final NoSuchElementException e) {
  358.               throw new SQLException("MaxOpenCallableStatements limit reached", e);

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:383: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CallableStatement PoolingConnection.prepareCall(String,int,int)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  381.               throws SQLException {
  382.           try {
  383. >             return (CallableStatement) pstmtPool.borrowObject(
  384.                       createKey(sql, resultSetType, resultSetConcurrency, StatementType.CALLABLE_STATEMENT));
  385.           } catch (final NoSuchElementException e) {

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:413: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `CallableStatement PoolingConnection.prepareCall(String,int,int,int)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  411.               final int resultSetHoldability) throws SQLException {
  412.           try {
  413. >             return (CallableStatement) pstmtPool.borrowObject(createKey(sql, resultSetType, resultSetConcurrency,
  414.                       resultSetHoldability, StatementType.CALLABLE_STATEMENT));
  415.           } catch (final NoSuchElementException e) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:830: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GenericObjectPool.preparePool()` indirectly mutates container `this.allObjects` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  828.               return;
  829.           }
  830. >         ensureMinIdle();
  831.       }
  832.   

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1298: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.preparePool(Object)` indirectly reads without synchronization from container `this.poolMap` via call to `values`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1296.               return;
  1297.           }
  1298. >         ensureMinIdle(key);
  1299.       }
  1300.   

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:433: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  431.       @Override
  432.       public PreparedStatement prepareStatement(final String sql) throws SQLException {
  433. >         if (null == pstmtPool) {
  434.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  435.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:449: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String,int)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  447.       @Override
  448.       public PreparedStatement prepareStatement(final String sql, final int autoGeneratedKeys) throws SQLException {
  449. >         if (null == pstmtPool) {
  450.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  451.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:502: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String,int,int)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  500.       public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency)
  501.               throws SQLException {
  502. >         if (null == pstmtPool) {
  503.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  504.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:532: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String,int,int,int)` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  530.       public PreparedStatement prepareStatement(final String sql, final int resultSetType, final int resultSetConcurrency,
  531.               final int resultSetHoldability) throws SQLException {
  532. >         if (null == pstmtPool) {
  533.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  534.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:474: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String,int[])` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  472.       @Override
  473.       public PreparedStatement prepareStatement(final String sql, final int columnIndexes[]) throws SQLException {
  474. >         if (null == pstmtPool) {
  475.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  476.           }

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:557: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `PreparedStatement PoolingConnection.prepareStatement(String,java.lang.String[])` reads without synchronization from `this.pstmtPool`. Potentially races with write in method `PoolingConnection.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  555.       @Override
  556.       public PreparedStatement prepareStatement(final String sql, final String columnNames[]) throws SQLException {
  557. >         if (null == pstmtPool) {
  558.               throw new SQLException("Statement pool is null - closed or invalid PoolingConnection.");
  559.           }

java/org/apache/catalina/tribes/transport/nio/NioSender.java:111: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean NioSender.process(SelectionKey,boolean)` indirectly writes to field `this.ackbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  109.                       //do a health check, we have no way of verify a disconnected
  110.                       //socket since we don't register for OP_READ on waitForAck=false
  111. >                     read();//this causes overhead
  112.                       setRequestCount(getRequestCount()+1);
  113.                       return true;

java/org/apache/catalina/tribes/transport/nio/NioSender.java:112: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.process(SelectionKey,boolean)` indirectly reads without synchronization from `this.requestCount`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  110.                       //socket since we don't register for OP_READ on waitForAck=false
  111.                       read();//this causes overhead
  112. >                     setRequestCount(getRequestCount()+1);
  113.                       return true;
  114.                   }

java/org/apache/catalina/tribes/transport/nio/NioSender.java:91: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.process(SelectionKey,boolean)` reads without synchronization from `this.socketChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  89.           if ( !key.isValid() ) throw new IOException(sm.getString("nioSender.key.inValid"));
  90.           if ( key.isConnectable() ) {
  91. >             if ( socketChannel.finishConnect() ) {
  92.                   completeConnect();
  93.                   if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);

java/org/apache/catalina/tribes/transport/nio/NioSender.java:92: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean NioSender.process(SelectionKey,boolean)` indirectly writes to field `this.connectTime` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  90.           if ( key.isConnectable() ) {
  91.               if ( socketChannel.finishConnect() ) {
  92. >                 completeConnect();
  93.                   if ( current != null ) key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
  94.                   return false;

java/org/apache/catalina/tribes/transport/nio/NioSender.java:101: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.process(SelectionKey,boolean)` indirectly reads without synchronization from `this.dataChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  99.               }//end if
  100.           } else if ( key.isWritable() ) {
  101. >             boolean writecomplete = write();
  102.               if ( writecomplete ) {
  103.                   //we are completed, should we read an ack?

java/org/apache/catalina/tribes/transport/nio/NioSender.java:88: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.process(SelectionKey,boolean)` reads without synchronization from `this.connecting`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  86.           key.interestOps(key.interestOps() & ~ops);
  87.           //in case disconnect has been called
  88. >         if ((!isConnected()) && (!connecting)) throw new IOException(sm.getString("nioSender.sender.disconnected"));
  89.           if ( !key.isValid() ) throw new IOException(sm.getString("nioSender.key.inValid"));
  90.           if ( key.isConnectable() ) {

java/org/apache/catalina/startup/ContextConfig.java:2546: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `filterDef.displayName`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2544.                   }
  2545.               } else if ("displayName".equals(name)) {
  2546. >                 if (filterDef.getDisplayName() == null) {
  2547.                       filterDef.setDisplayName(evp.getValue().stringifyValue());
  2548.                   }

java/org/apache/catalina/startup/ContextConfig.java:2547: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `filterDef.displayName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2545.               } else if ("displayName".equals(name)) {
  2546.                   if (filterDef.getDisplayName() == null) {
  2547. >                     filterDef.setDisplayName(evp.getValue().stringifyValue());
  2548.                   }
  2549.               } else if ("largeIcon".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2607: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `descMap.matchAllUrlPatterns` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2605.                       for (String urlPattern : filterMap.getURLPatterns()) {
  2606.                           // % decoded (if required) using UTF-8
  2607. >                         descMap.addURLPattern(urlPattern);
  2608.                       }
  2609.                   }

java/org/apache/catalina/startup/ContextConfig.java:2542: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `filterDef.description`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2540.                   }
  2541.               } else if ("description".equals(name)) {
  2542. >                 if (filterDef.getDescription() == null) {
  2543.                       filterDef.setDescription(evp.getValue().stringifyValue());
  2544.                   }

java/org/apache/catalina/startup/ContextConfig.java:2614: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2612.                           && (dispatcherNames == null || dispatcherNames.length == 0)) {
  2613.                       for (String dis : filterMap.getDispatcherNames()) {
  2614. >                         descMap.setDispatcher(dis);
  2615.                       }
  2616.                   }

java/org/apache/catalina/startup/ContextConfig.java:2555: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `filterDef.smallIcon` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2553.               } else if ("smallIcon".equals(name)) {
  2554.                   if (filterDef.getSmallIcon() == null) {
  2555. >                     filterDef.setSmallIcon(evp.getValue().stringifyValue());
  2556.                   }
  2557.               } else if ("asyncSupported".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2554: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `filterDef.smallIcon`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2552.                   }
  2553.               } else if ("smallIcon".equals(name)) {
  2554. >                 if (filterDef.getSmallIcon() == null) {
  2555.                       filterDef.setSmallIcon(evp.getValue().stringifyValue());
  2556.                   }

java/org/apache/catalina/startup/ContextConfig.java:2602: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `descMap.matchAllUrlPatterns`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2600.               }
  2601.               if (descMap != null) {
  2602. >                 String[] urlsPatterns = descMap.getURLPatterns();
  2603.                   if (urlPatternsSet
  2604.                           && (urlsPatterns == null || urlsPatterns.length == 0)) {

java/org/apache/catalina/startup/ContextConfig.java:2551: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `filterDef.largeIcon` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2549.               } else if ("largeIcon".equals(name)) {
  2550.                   if (filterDef.getLargeIcon() == null) {
  2551. >                     filterDef.setLargeIcon(evp.getValue().stringifyValue());
  2552.                   }
  2553.               } else if ("smallIcon".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2578: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly mutates container `filterDef.parameters` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2576.                       for (Map.Entry<String, String> entry : initParams
  2577.                               .entrySet()) {
  2578. >                         filterDef.addInitParameter(entry.getKey(), entry
  2579.                                   .getValue());
  2580.                       }

java/org/apache/catalina/startup/ContextConfig.java:2560: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `filterDef.asyncSupported` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2558.                   if (filterDef.getAsyncSupported() == null) {
  2559.                       filterDef
  2560. >                             .setAsyncSupported(evp.getValue().stringifyValue());
  2561.                   }
  2562.               } else if ("initParams".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2610: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `descMap.dispatcherMapping`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2608.                       }
  2609.                   }
  2610. >                 String[] dispatcherNames = descMap.getDispatcherNames();
  2611.                   if (dispatchTypesSet
  2612.                           && (dispatcherNames == null || dispatcherNames.length == 0)) {

java/org/apache/catalina/startup/ContextConfig.java:2550: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `filterDef.largeIcon`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2548.                   }
  2549.               } else if ("largeIcon".equals(name)) {
  2550. >                 if (filterDef.getLargeIcon() == null) {
  2551.                       filterDef.setLargeIcon(evp.getValue().stringifyValue());
  2552.                   }

java/org/apache/catalina/startup/ContextConfig.java:2543: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly writes to field `filterDef.description` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2541.               } else if ("description".equals(name)) {
  2542.                   if (filterDef.getDescription() == null) {
  2543. >                     filterDef.setDescription(evp.getValue().stringifyValue());
  2544.                   }
  2545.               } else if ("displayName".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2558: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebFilter(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `filterDef.asyncSupported`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2556.                   }
  2557.               } else if ("asyncSupported".equals(name)) {
  2558. >                 if (filterDef.getAsyncSupported() == null) {
  2559.                       filterDef
  2560.                               .setAsyncSupported(evp.getValue().stringifyValue());

java/org/apache/catalina/startup/ContextConfig.java:2425: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.smallIcon` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2423.               } else if ("smallIcon".equals(name)) {
  2424.                   if (servletDef.getSmallIcon() == null) {
  2425. >                     servletDef.setSmallIcon(evp.getValue().stringifyValue());
  2426.                   }
  2427.               } else if ("asyncSupported".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2435: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.loadOnStartup` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2433.                   if (servletDef.getLoadOnStartup() == null) {
  2434.                       servletDef
  2435. >                             .setLoadOnStartup(evp.getValue().stringifyValue());
  2436.                   }
  2437.               } else if ("initParams".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2413: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.description` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2411.               } else if ("description".equals(name)) {
  2412.                   if (servletDef.getDescription() == null) {
  2413. >                     servletDef.setDescription(evp.getValue().stringifyValue());
  2414.                   }
  2415.               } else if ("displayName".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2429: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.asyncSupported` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2427.               } else if ("asyncSupported".equals(name)) {
  2428.                   if (servletDef.getAsyncSupported() == null) {
  2429. >                     servletDef.setAsyncSupported(evp.getValue()
  2430.                               .stringifyValue());
  2431.                   }

java/org/apache/catalina/startup/ContextConfig.java:2424: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.smallIcon`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2422.                   }
  2423.               } else if ("smallIcon".equals(name)) {
  2424. >                 if (servletDef.getSmallIcon() == null) {
  2425.                       servletDef.setSmallIcon(evp.getValue().stringifyValue());
  2426.                   }

java/org/apache/catalina/startup/ContextConfig.java:2421: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.largeIcon` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2419.               } else if ("largeIcon".equals(name)) {
  2420.                   if (servletDef.getLargeIcon() == null) {
  2421. >                     servletDef.setLargeIcon(evp.getValue().stringifyValue());
  2422.                   }
  2423.               } else if ("smallIcon".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2460: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.overridable` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2458.           }
  2459.           if (!isWebXMLservletDef && urlPatterns != null) {
  2460. >             fragment.addServlet(servletDef);
  2461.           }
  2462.           if (urlPatterns != null) {

java/org/apache/catalina/startup/ContextConfig.java:2428: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.asyncSupported`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2426.                   }
  2427.               } else if ("asyncSupported".equals(name)) {
  2428. >                 if (servletDef.getAsyncSupported() == null) {
  2429.                       servletDef.setAsyncSupported(evp.getValue()
  2430.                               .stringifyValue());

java/org/apache/catalina/startup/ContextConfig.java:2420: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.largeIcon`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2418.                   }
  2419.               } else if ("largeIcon".equals(name)) {
  2420. >                 if (servletDef.getLargeIcon() == null) {
  2421.                       servletDef.setLargeIcon(evp.getValue().stringifyValue());
  2422.                   }

java/org/apache/catalina/startup/ContextConfig.java:2453: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly mutates container `servletDef.parameters` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2451.                       for (Map.Entry<String, String> entry : initParams
  2452.                               .entrySet()) {
  2453. >                         servletDef.addInitParameter(entry.getKey(), entry
  2454.                                   .getValue());
  2455.                       }

java/org/apache/catalina/startup/ContextConfig.java:2412: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.description`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2410.                   urlPatterns = processAnnotationsStringArray(evp.getValue());
  2411.               } else if ("description".equals(name)) {
  2412. >                 if (servletDef.getDescription() == null) {
  2413.                       servletDef.setDescription(evp.getValue().stringifyValue());
  2414.                   }

java/org/apache/catalina/startup/ContextConfig.java:2416: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.displayName`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2414.                   }
  2415.               } else if ("displayName".equals(name)) {
  2416. >                 if (servletDef.getDisplayName() == null) {
  2417.                       servletDef.setDisplayName(evp.getValue().stringifyValue());
  2418.                   }

java/org/apache/catalina/startup/ContextConfig.java:2417: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly writes to field `servletDef.displayName` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2415.               } else if ("displayName".equals(name)) {
  2416.                   if (servletDef.getDisplayName() == null) {
  2417. >                     servletDef.setDisplayName(evp.getValue().stringifyValue());
  2418.                   }
  2419.               } else if ("largeIcon".equals(name)) {

java/org/apache/catalina/startup/ContextConfig.java:2433: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationWebServlet(String,AnnotationEntry,WebXml)` indirectly reads without synchronization from `servletDef.loadOnStartup`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2431.                   }
  2432.               } else if ("loadOnStartup".equals(name)) {
  2433. >                 if (servletDef.getLoadOnStartup() == null) {
  2434.                       servletDef
  2435.                               .setLoadOnStartup(evp.getValue().stringifyValue());

java/org/apache/catalina/startup/ContextConfig.java:1997: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotations(Set,boolean,Map)` indirectly writes to field `fragment.denyUncoveredHttpMethods` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1995.               set.add(annotations);
  1996.               // Merge annotations into fragment - fragment takes priority
  1997. >             fragment.merge(set);
  1998.           }
  1999.       }

java/org/apache/catalina/startup/ContextConfig.java:1993: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotations(Set,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1991.               annotations.setDistributable(true);
  1992.               URL url = fragment.getURL();
  1993. >             processAnnotationsUrl(url, annotations, htOnly, javaClassCache);
  1994.               Set<WebXml> set = new HashSet<>();
  1995.               set.add(annotations);

java/org/apache/catalina/startup/ContextConfig.java:2106: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsFile(File,WebXml,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2104.           } else if (file.getName().endsWith(".class") && file.canRead()) {
  2105.               try (FileInputStream fis = new FileInputStream(file)) {
  2106. >                 processAnnotationsStream(fis, fragment, handlesTypesOnly, javaClassCache);
  2107.               } catch (IOException e) {
  2108.                   log.error(sm.getString("contextConfig.inputStreamFile",

java/org/apache/catalina/startup/ContextConfig.java:2070: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsJar(URL,WebXml,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2068.                   if (entryName.endsWith(".class")) {
  2069.                       try (InputStream is = jar.getEntryInputStream()) {
  2070. >                         processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);
  2071.                       } catch (IOException e) {
  2072.                           log.error(sm.getString("contextConfig.inputStreamJar",

java/org/apache/catalina/startup/ContextConfig.java:2130: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsStream(InputStream,WebXml,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2128.           }
  2129.   
  2130. >         processClass(fragment, clazz);
  2131.       }
  2132.   

java/org/apache/catalina/startup/ContextConfig.java:2124: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsStream(InputStream,WebXml,boolean,Map)` indirectly writes to field `entry.sciSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2122.           ClassParser parser = new ClassParser(is);
  2123.           JavaClass clazz = parser.parse();
  2124. >         checkHandlesTypes(clazz, javaClassCache);
  2125.   
  2126.           if (handlesTypesOnly) {

java/org/apache/catalina/startup/ContextConfig.java:2040: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processAnnotationsUrl(URL,WebXml,boolean,Map)` indirectly reads without synchronization from `descMap.dispatcherMapping`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2038.               return;
  2039.           } else if ("jar".equals(url.getProtocol()) || url.toString().endsWith(".jar")) {
  2040. >             processAnnotationsJar(url, fragment, handlesTypesOnly, javaClassCache);
  2041.           } else if ("file".equals(url.getProtocol())) {
  2042.               try {

java/org/apache/catalina/startup/ContextConfig.java:2043: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsUrl(URL,WebXml,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2041.           } else if ("file".equals(url.getProtocol())) {
  2042.               try {
  2043. >                 processAnnotationsFile(
  2044.                           new File(url.toURI()), fragment, handlesTypesOnly, javaClassCache);
  2045.               } catch (URISyntaxException e) {

java/org/apache/catalina/startup/ContextConfig.java:2022: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processAnnotationsWebResource(WebResource,WebXml,boolean,Map)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2020.                   webResource.getName().endsWith(".class")) {
  2021.               try (InputStream is = webResource.getInputStream()) {
  2022. >                 processAnnotationsStream(is, fragment, handlesTypesOnly, javaClassCache);
  2023.               } catch (IOException e) {
  2024.                   log.error(sm.getString("contextConfig.inputStreamWebResource",

java/org/apache/catalina/webresources/JarWarResourceSet.java:172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JarWarResourceSet.processArchivesEntriesForMultiRelease()` reads without synchronization from `this.archiveEntries`. Potentially races with write in method `JarWarResourceSet.getArchiveEntries(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.   
  171.           Map<String,VersionedJarEntry> versionedEntries = new HashMap<>();
  172. >         Iterator<Entry<String,JarEntry>> iter = archiveEntries.entrySet().iterator();
  173.           while (iter.hasNext()) {
  174.               Entry<String,JarEntry> entry = iter.next();

java/org/apache/catalina/webresources/JarWarResourceSet.java:211: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JarWarResourceSet.processArchivesEntriesForMultiRelease()` mutates container `this.archiveEntries` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  209.   
  210.           for (Entry<String,VersionedJarEntry> versionedJarEntry : versionedEntries.entrySet()) {
  211. >             archiveEntries.put(versionedJarEntry.getKey(),
  212.                       versionedJarEntry.getValue().getJarEntry());
  213.           }

java/org/apache/catalina/startup/ContextConfig.java:2141: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processClass(WebXml,JavaClass)` indirectly writes to field `servletDef.asyncSupported` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2139.                   String type = ae.getAnnotationType();
  2140.                   if ("Ljavax/servlet/annotation/WebServlet;".equals(type)) {
  2141. >                     processAnnotationWebServlet(className, ae, fragment);
  2142.                   }else if ("Ljavax/servlet/annotation/WebFilter;".equals(type)) {
  2143.                       processAnnotationWebFilter(className, ae, fragment);

java/org/apache/catalina/startup/ContextConfig.java:2143: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processClass(WebXml,JavaClass)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2141.                       processAnnotationWebServlet(className, ae, fragment);
  2142.                   }else if ("Ljavax/servlet/annotation/WebFilter;".equals(type)) {
  2143. >                     processAnnotationWebFilter(className, ae, fragment);
  2144.                   }else if ("Ljavax/servlet/annotation/WebListener;".equals(type)) {
  2145.                       fragment.addListener(className);

java/org/apache/catalina/startup/ContextConfig.java:1233: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processClasses(WebXml,Set)` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1231.                       continue;
  1232.                   }
  1233. >                 processAnnotationsWebResource(webResource, webXml,
  1234.                           webXml.isMetadataComplete(), javaClassCache);
  1235.               }

java/org/apache/catalina/startup/ContextConfig.java:1243: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processClasses(WebXml,Set)` indirectly writes to field `fragment.denyUncoveredHttpMethods` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1241.           // container fragments)
  1242.           if (ok) {
  1243. >             processAnnotations(
  1244.                       orderedFragments, webXml.isMetadataComplete(), javaClassCache);
  1245.           }

java/org/apache/catalina/startup/ContextConfig.java:1223: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processClasses(WebXml,Set)` reads without synchronization from `this.ok`. Potentially races with write in method `ContextConfig.init()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1221.           Map<String, JavaClassCacheEntry> javaClassCache = new HashMap<>();
  1222.   
  1223. >         if (ok) {
  1224.               WebResource[] webResources =
  1225.                       context.getResources().listResources("/WEB-INF/classes");

java/org/apache/catalina/startup/ContextConfig.java:534: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processContextConfig(Digester,URL,InputStream)` writes to field `this.ok` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  532.                       errorHandler.getErrors().size() > 0) {
  533.                   errorHandler.logFindings(log, contextXml.toString());
  534. >                 ok = false;
  535.               }
  536.               if (log.isDebugEnabled()) {

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:338: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NonBlockingCoordinator.processCoordMessage(NonBlockingCoordinator$CoordinationMessage)` indirectly writes to field `this.suggestedviewId` outside of synchronization.
 Reporting because this access may occur on a background thread.
  336.           }
  337.           Membership merged = mergeOnArrive(msg);
  338. >         if (isViewConf(msg)) handleViewConf(msg, merged);
  339.           else handleToken(msg, merged);
  340.       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:337: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.processCoordMessage(NonBlockingCoordinator$CoordinationMessage)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  335.               synchronized (electionMutex) { electionMutex.notifyAll();}
  336.           }
  337. >         Membership merged = mergeOnArrive(msg);
  338.           if (isViewConf(msg)) handleViewConf(msg, merged);
  339.           else handleToken(msg, merged);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:339: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NonBlockingCoordinator.processCoordMessage(NonBlockingCoordinator$CoordinationMessage)` indirectly writes to field `msg.buf.buf` outside of synchronization.
 Reporting because this access may occur on a background thread.
  337.           Membership merged = mergeOnArrive(msg);
  338.           if (isViewConf(msg)) handleViewConf(msg, merged);
  339. >         else handleToken(msg, merged);
  340.       }
  341.   

java/org/apache/catalina/session/ManagerBase.java:567: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagerBase.processExpires()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  565.   
  566.           long timeNow = System.currentTimeMillis();
  567. >         Session sessions[] = findSessions();
  568.           int expireHere = 0 ;
  569.   

java/org/apache/catalina/session/PersistentManagerBase.java:426: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processExpires()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  424.   
  425.           long timeNow = System.currentTimeMillis();
  426. >         Session sessions[] = findSessions();
  427.           int expireHere = 0 ;
  428.           if(log.isDebugEnabled())

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:161: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` indirectly writes to field `tmp.msg` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  159.                   if ( getForwardExpired() )
  160.                       super.messageReceived(tmp.getMessage());
  161. >                 tmp.setMessage(null);
  162.                   tmp = tmp.next;
  163.                   if ( prev != null ) prev.next = tmp;

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:160: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` indirectly reads without synchronization from `tmp.msg`. Potentially races with write in method `OrderInterceptor.messageReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  158.                   cnt.setCounter(tmp.getMsgNr()+1);
  159.                   if ( getForwardExpired() )
  160. >                     super.messageReceived(tmp.getMessage());
  161.                   tmp.setMessage(null);
  162.                   tmp = tmp.next;

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:134: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` reads without synchronization from container `this.incoming` via call to `get`. Potentially races with write in method `OrderInterceptor.messageReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  132.           Counter cnt = getInCounter(member);
  133.   
  134. >         MessageOrder tmp = incoming.get(member);
  135.           if ( tmp != null ) {
  136.               order = MessageOrder.add(tmp,order);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:136: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` indirectly writes to field `iter.next` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  134.           MessageOrder tmp = incoming.get(member);
  135.           if ( tmp != null ) {
  136. >             order = MessageOrder.add(tmp,order);
  137.           }
  138.   

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:132: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` indirectly mutates container `this.incounter` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  130.           boolean result = false;
  131.           Member member = order.getMessage().getAddress();
  132. >         Counter cnt = getInCounter(member);
  133.   
  134.           MessageOrder tmp = incoming.get(member);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:170: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean OrderInterceptor.processIncoming(OrderInterceptor$MessageOrder)` mutates container `this.incoming` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  168.               }
  169.           }
  170. >         if ( head == null ) incoming.remove(member);
  171.           else incoming.put(member, head);
  172.           return result;

java/org/apache/catalina/startup/ContextConfig.java:1972: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Map ContextConfig.processJarsForWebFragments(WebXml,WebXmlParser)` writes to field `this.ok` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1970.   
  1971.           if (!callback.isOk()) {
  1972. >             ok = false;
  1973.           }
  1974.           return callback.getFragments();

java/org/apache/tomcat/util/net/NioEndpoint.java:764: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.processKey(SelectionKey,NioEndpoint$NioSocketWrapper)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  762.                       if (sk.isReadable() || sk.isWritable()) {
  763.                           if (socketWrapper.getSendfileData() != null) {
  764. >                             processSendfile(sk, socketWrapper, false);
  765.                           } else {
  766.                               unreg(sk, socketWrapper, sk.readyOps());

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:117: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void OrderInterceptor.processLeftOvers(Member,boolean)` reads without synchronization from container `this.incoming` via call to `get`. Potentially races with write in method `OrderInterceptor.messageReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  115.       }
  116.       protected void processLeftOvers(Member member, boolean force) {
  117. >         MessageOrder tmp = incoming.get(member);
  118.           if ( force ) {
  119.               Counter cnt = getInCounter(member);

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:119: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void OrderInterceptor.processLeftOvers(Member,boolean)` indirectly mutates container `this.incounter` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  117.           MessageOrder tmp = incoming.get(member);
  118.           if ( force ) {
  119. >             Counter cnt = getInCounter(member);
  120.               cnt.setCounter(Integer.MAX_VALUE);
  121.           }

java/org/apache/catalina/tribes/group/interceptors/OrderInterceptor.java:122: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void OrderInterceptor.processLeftOvers(Member,boolean)` indirectly writes to field `tmp.msg` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  120.               cnt.setCounter(Integer.MAX_VALUE);
  121.           }
  122. >         if ( tmp!= null ) processIncoming(tmp);
  123.       }
  124.       /**

java/org/apache/catalina/session/PersistentManagerBase.java:965: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxActiveSwaps()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.removeSuper(...)`.
 Reporting because this access may occur on a background thread.
  963.           }
  964.   
  965. >         Session sessions[] = findSessions();
  966.   
  967.           // FIXME: Smarter algorithm (LRU)

java/org/apache/catalina/session/PersistentManagerBase.java:961: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxActiveSwaps()` reads without synchronization from `this.minIdleSwap`. Potentially races with write in method `PersistentManagerBase.setMinIdleSwap(...)`.
 Reporting because this access may occur on a background thread.
  959.       protected void processMaxActiveSwaps() {
  960.   
  961. >         if (!getState().isAvailable() || minIdleSwap < 0 || getMaxActiveSessions() < 0) {
  962.               return;
  963.           }

java/org/apache/catalina/session/PersistentManagerBase.java:1016: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxIdleBackups()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.removeSuper(...)`.
 Reporting because this access may occur on a background thread.
  1014.               return;
  1015.   
  1016. >         Session sessions[] = findSessions();
  1017.   
  1018.           // Back up all sessions idle longer than maxIdleBackup

java/org/apache/catalina/session/PersistentManagerBase.java:1013: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxIdleBackups()` reads without synchronization from `this.maxIdleBackup`. Potentially races with write in method `PersistentManagerBase.setMaxIdleBackup(...)`.
 Reporting because this access may occur on a background thread.
  1011.       protected void processMaxIdleBackups() {
  1012.   
  1013. >         if (!getState().isAvailable() || maxIdleBackup < 0)
  1014.               return;
  1015.   

java/org/apache/catalina/session/PersistentManagerBase.java:919: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxIdleSwaps()` reads without synchronization from `this.maxIdleSwap`. Potentially races with write in method `PersistentManagerBase.setMaxIdleSwap(...)`.
 Reporting because this access may occur on a background thread.
  917.       protected void processMaxIdleSwaps() {
  918.   
  919. >         if (!getState().isAvailable() || maxIdleSwap < 0)
  920.               return;
  921.   

java/org/apache/catalina/session/PersistentManagerBase.java:922: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processMaxIdleSwaps()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.removeSuper(...)`.
 Reporting because this access may occur on a background thread.
  920.               return;
  921.   
  922. >         Session sessions[] = findSessions();
  923.   
  924.           // Swap out all sessions idle longer than maxIdleSwap

java/org/apache/catalina/session/PersistentManagerBase.java:455: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.processPersistenceChecks()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  453.       public void processPersistenceChecks() {
  454.   
  455. >         processMaxIdleSwaps();
  456.           processMaxActiveSwaps();
  457.           processMaxIdleBackups();

java/org/apache/tomcat/util/net/NioEndpoint.java:902: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState NioEndpoint$Poller.processSendfile(SelectionKey,NioEndpoint$NioSocketWrapper,boolean)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  900.                       }
  901.                       if (calledByProcessor) {
  902. >                         add(socketWrapper, SelectionKey.OP_WRITE);
  903.                       } else {
  904.                           reg(sk, socketWrapper, SelectionKey.OP_WRITE);

java/org/apache/tomcat/util/net/NioEndpoint.java:844: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SendfileState NioEndpoint$Poller.processSendfile(SelectionKey,NioEndpoint$NioSocketWrapper,boolean)` reads without synchronization from `sd.length`. Potentially races with write in method `NioEndpoint$Poller.processKey(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  842.                       }
  843.                   } else {
  844. >                     long written = sd.fchannel.transferTo(sd.pos, sd.length, wc);
  845.                       if (written > 0) {
  846.                           sd.pos += written;

java/org/apache/tomcat/util/net/NioEndpoint.java:847: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState NioEndpoint$Poller.processSendfile(SelectionKey,NioEndpoint$NioSocketWrapper,boolean)` writes to field `sd.length` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  845.                       if (written > 0) {
  846.                           sd.pos += written;
  847. >                         sd.length -= written;
  848.                           socketWrapper.updateLastWrite();
  849.                       } else {

java/org/apache/tomcat/util/net/NioEndpoint.java:882: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `SendfileState NioEndpoint$Poller.processSendfile(SelectionKey,NioEndpoint$NioSocketWrapper,boolean)` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `NioEndpoint$Poller.processKey(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  880.                                   log.debug("Connection is keep alive, processing pipe-lined data");
  881.                               }
  882. >                             if (!processSocket(socketWrapper, SocketEvent.OPEN_READ, true)) {
  883.                                   poller.cancelledKey(sk, socketWrapper);
  884.                               }

java/org/apache/tomcat/util/net/NioEndpoint.java:846: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState NioEndpoint$Poller.processSendfile(SelectionKey,NioEndpoint$NioSocketWrapper,boolean)` writes to field `sd.pos` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  844.                       long written = sd.fchannel.transferTo(sd.pos, sd.length, wc);
  845.                       if (written > 0) {
  846. >                         sd.pos += written;
  847.                           sd.length -= written;
  848.                           socketWrapper.updateLastWrite();

java/org/apache/tomcat/util/net/NioEndpoint.java:1353: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `SendfileState NioEndpoint$NioSocketWrapper.processSendfile(SendfileDataBase)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1351.               SelectionKey key = getSocket().getIOChannel().keyFor(getPoller().getSelector());
  1352.               // Might as well do the first write on this thread
  1353. >             return getPoller().processSendfile(key, this, true);
  1354.           }
  1355.   

java/org/apache/catalina/startup/ContextConfig.java:1680: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processServletContainerInitializers()` mutates container `this.initializerClassMap` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1678.   
  1679.           for (ServletContainerInitializer sci : detectedScis) {
  1680. >             initializerClassMap.put(sci, new HashSet<Class<?>>());
  1681.   
  1682.               HandlesTypes ht;

java/org/apache/catalina/startup/ContextConfig.java:1708: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processServletContainerInitializers()` writes to field `this.handlesTypesNonAnnotations` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1706.                       handlesTypesAnnotations = true;
  1707.                   } else {
  1708. >                     handlesTypesNonAnnotations = true;
  1709.                   }
  1710.                   Set<ServletContainerInitializer> scis =

java/org/apache/catalina/startup/ContextConfig.java:1706: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processServletContainerInitializers()` writes to field `this.handlesTypesAnnotations` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1704.               for (Class<?> type : types) {
  1705.                   if (type.isAnnotation()) {
  1706. >                     handlesTypesAnnotations = true;
  1707.                   } else {
  1708.                       handlesTypesNonAnnotations = true;

java/org/apache/catalina/startup/ContextConfig.java:1711: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.processServletContainerInitializers()` reads without synchronization from container `this.typeInitializerMap` via call to `get`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1709.                   }
  1710.                   Set<ServletContainerInitializer> scis =
  1711. >                         typeInitializerMap.get(type);
  1712.                   if (scis == null) {
  1713.                       scis = new HashSet<>();

java/org/apache/catalina/startup/ContextConfig.java:1714: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.processServletContainerInitializers()` mutates container `this.typeInitializerMap` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1712.                   if (scis == null) {
  1713.                       scis = new HashSet<>();
  1714. >                     typeInitializerMap.put(type, scis);
  1715.                   }
  1716.                   scis.add(sci);

java/org/apache/coyote/AbstractProcessor.java:795: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.processSocketEvent(SocketEvent,boolean)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  793.           SocketWrapperBase<?> socketWrapper = getSocketWrapper();
  794.           if (socketWrapper != null) {
  795. >             socketWrapper.processSocket(event, dispatch);
  796.           }
  797.       }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1294: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.push(Request,Stream)` indirectly reads without synchronization from `this.queuedRunnable`. Potentially races with write in method `Http2UpgradeHandler.upgradeDispatch(...)`.
 Reporting because this access may occur on a background thread.
  1292.           pushStream.sentPushPromise();
  1293.   
  1294. >         processStreamOnContainerThread(pushStream);
  1295.       }
  1296.   

java/org/apache/jasper/compiler/JspRuntimeContext.java:237: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `FastRemovalDequeue$Entry JspRuntimeContext.push(JspServletWrapper)` indirectly mutates container `this.jsps` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  235.                                                  replaced.getJspUri(), context.getContextPath()));
  236.               }
  237. >             unloadJspServletWrapper(replaced);
  238.               entry.clearReplaced();
  239.           }

java/javax/el/BeanELResolver.java:362: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BeanELResolver$ConcurrentCache.put(Object,Object)` reads without synchronization from container `this.eden` via call to `size`. Potentially races with write in method `BeanELResolver$ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  360.   
  361.           public void put(K key, V value) {
  362. >             if (this.eden.size() >= this.size) {
  363.                   synchronized (longterm) {
  364.                       this.longterm.putAll(this.eden);

java/javax/el/BeanELResolver.java:368: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BeanELResolver$ConcurrentCache.put(Object,Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  366.                   this.eden.clear();
  367.               }
  368. >             this.eden.put(key, value);
  369.           }
  370.   

java/org/apache/el/util/ConcurrentCache.java:51: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ConcurrentCache.put(Object,Object)` reads without synchronization from container `this.eden` via call to `size`. Potentially races with write in method `ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  49.   
  50.       public void put(K k, V v) {
  51. >         if (this.eden.size() >= size) {
  52.               synchronized (longterm) {
  53.                   this.longterm.putAll(this.eden);

java/org/apache/el/util/ConcurrentCache.java:57: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ConcurrentCache.put(Object,Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  55.               this.eden.clear();
  56.           }
  57. >         this.eden.put(k, v);
  58.       }
  59.   }

java/org/apache/tomcat/util/collections/ConcurrentCache.java:51: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ConcurrentCache.put(Object,Object)` reads without synchronization from container `this.eden` via call to `size`. Potentially races with write in method `ConcurrentCache.get(...)`.
 Reporting because this access may occur on a background thread.
  49.   
  50.       public void put(K k, V v) {
  51. >         if (this.eden.size() >= size) {
  52.               synchronized (longterm) {
  53.                   this.longterm.putAll(this.eden);

java/org/apache/tomcat/util/collections/ConcurrentCache.java:57: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ConcurrentCache.put(Object,Object)` mutates container `this.eden` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  55.               this.eden.clear();
  56.           }
  57. >         this.eden.put(k, v);
  58.       }
  59.   }

java/org/apache/catalina/session/StandardSession.java:1276: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.putValue(String,Object)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1274.       public void putValue(String name, Object value) {
  1275.   
  1276. >         setAttribute(name, value);
  1277.   
  1278.       }

java/org/apache/catalina/tribes/transport/nio/NioSender.java:171: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.read()` reads without synchronization from `this.dataChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  169.           //if there is no message here, we are done
  170.           if ( current == null ) return true;
  171. >         int read = isUdpBased()?dataChannel.read(readbuf) : socketChannel.read(readbuf);
  172.           //end of stream
  173.           if ( read == -1 ) throw new IOException(sm.getString("nioSender.unable.receive.ack"));

java/org/apache/catalina/tribes/transport/nio/NioSender.java:177: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean NioSender.read()` indirectly writes to field `this.ackbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  175.           else if ( read == 0 ) return false;
  176.           readbuf.flip();
  177. >         ackbuf.append(readbuf,read);
  178.           readbuf.clear();
  179.           if (ackbuf.doesPackageExist() ) {

java/org/apache/tomcat/util/net/Nio2Endpoint.java:828: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int Nio2Endpoint$Nio2SocketWrapper.read(boolean,byte[],int,int)` writes to field `this.readNotify` outside of synchronization.
 Reporting because this access may occur on a background thread.
  826.               if (nRead > 0) {
  827.                   // The code that was notified is now reading its data
  828. >                 readNotify = false;
  829.                   // This may be sufficient to complete the request and we
  830.                   // don't want to trigger another read since if there is no

java/org/apache/tomcat/util/net/Nio2Endpoint.java:808: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int Nio2Endpoint$Nio2SocketWrapper.read(boolean,byte[],int,int)` reads without synchronization from `this.readNotify`. Potentially races with write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  806.               }
  807.   
  808. >             if (!readNotify) {
  809.                   if (block) {
  810.                       try {

java/org/apache/tomcat/util/net/NioEndpoint.java:1126: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int NioEndpoint$NioSocketWrapper.read(boolean,byte[],int,int)` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `NioEndpoint$NioSocketWrapper.doWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1124.   
  1125.               // Fill the read buffer as best we can.
  1126. >             nRead = fillReadBuffer(block);
  1127.               updateLastRead();
  1128.   

java/org/apache/tomcat/util/net/Nio2Endpoint.java:885: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `int Nio2Endpoint$Nio2SocketWrapper.read(boolean,ByteBuffer)` writes to field `this.readNotify` outside of synchronization.
 Reporting because this access may occur on a background thread.
  883.               if (nRead > 0) {
  884.                   // The code that was notified is now reading its data
  885. >                 readNotify = false;
  886.                   // This may be sufficient to complete the request and we
  887.                   // don't want to trigger another read since if there is no

java/org/apache/tomcat/util/net/Nio2Endpoint.java:865: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int Nio2Endpoint$Nio2SocketWrapper.read(boolean,ByteBuffer)` reads without synchronization from `this.readNotify`. Potentially races with write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  863.               }
  864.   
  865. >             if (!readNotify) {
  866.                   if (block) {
  867.                       try {

java/org/apache/tomcat/util/net/NioEndpoint.java:1158: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int NioEndpoint$NioSocketWrapper.read(boolean,ByteBuffer)` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `NioEndpoint$NioSocketWrapper.doWrite(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1156.               if (to.remaining() >= limit) {
  1157.                   to.limit(to.position() + limit);
  1158. >                 nRead = fillReadBuffer(block, to);
  1159.                   if (log.isDebugEnabled()) {
  1160.                       log.debug("Socket: [" + this + "], Read direct from socket: [" + nRead + "]");

java/org/apache/catalina/tribes/membership/MemberImpl.java:676: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MemberImpl.readExternal(ObjectInput)` indirectly writes to field `this.dataPkg` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  674.           byte[] message = new byte[length];
  675.           in.readFully(message);
  676. >         getMember(message,this);
  677.   
  678.       }

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:211: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FileMessage FileMessageFactory.readMessage(FileMessage)` reads without synchronization from `this.data`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  209.               throws IllegalArgumentException, IOException {
  210.           checkState(false);
  211. >         int length = in.read(data);
  212.           if (length == -1) {
  213.               cleanup();

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:210: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `FileMessage FileMessageFactory.readMessage(FileMessage)` indirectly writes to field `this.closed` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  208.       public FileMessage readMessage(FileMessage f)
  209.               throws IllegalArgumentException, IOException {
  210. >         checkState(false);
  211.           int length = in.read(data);
  212.           if (length == -1) {

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:217: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FileMessage FileMessageFactory.readMessage(FileMessage)` reads without synchronization from `this.totalNrOfMessages`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  215.           } else {
  216.               f.setData(data, length);
  217. >             f.setTotalNrOfMsgs(totalNrOfMessages);
  218.               f.setMessageNumber(++nrOfMessagesProcessed);
  219.               return f;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:218: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `FileMessage FileMessageFactory.readMessage(FileMessage)` reads without synchronization from `this.nrOfMessagesProcessed`. Potentially races with write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  216.               f.setData(data, length);
  217.               f.setTotalNrOfMsgs(totalNrOfMessages);
  218. >             f.setMessageNumber(++nrOfMessagesProcessed);
  219.               return f;
  220.           }//end if

java/org/apache/catalina/ha/session/DeltaSession.java:618: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.readObjectData(ObjectInput)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  616.       }
  617.       public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {
  618. >         doReadObject(stream);
  619.       }
  620.   

java/org/apache/catalina/ha/session/DeltaSession.java:615: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.readObjectData(ObjectInputStream)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  613.       @Override
  614.       public void readObjectData(ObjectInputStream stream) throws ClassNotFoundException, IOException {
  615. >         doReadObject((ObjectInput)stream);
  616.       }
  617.       public void readObjectData(ObjectInput stream) throws ClassNotFoundException, IOException {

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1052: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AuthenticatorBase.reauthenticateFromSSO(String,Request)` reads without synchronization from `this.sso`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1050.       protected boolean reauthenticateFromSSO(String ssoId, Request request) {
  1051.   
  1052. >         if (sso == null || ssoId == null) {
  1053.               return false;
  1054.           }

java/org/apache/coyote/http2/Stream.java:234: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Stream.receiveReset(long)` indirectly reads without synchronization from `this.allocationManager.waitingFor`. Potentially races with write in method `Stream.reserveWindowSize(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  232.               inputBuffer.receiveReset();
  233.           }
  234. >         cancelAllocationRequests();
  235.       }
  236.   

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:39: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2AsyncUpgradeHandler.receivedEndOfStream(int)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  37.   import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
  38.   
  39. > public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
  40.   
  41.       private static final ByteBuffer[] BYTEBUFFER_ARRAY = new ByteBuffer[0];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1414: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.receivedEndOfStream(int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1412.       @Override
  1413.       public void receivedEndOfStream(int streamId) throws ConnectionException {
  1414. >         Stream stream = getStream(streamId, connectionState.get().isNewStreamAllowed());
  1415.           if (stream != null) {
  1416.               stream.receivedEndOfStream();

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1416: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2UpgradeHandler.receivedEndOfStream(int)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1414.           Stream stream = getStream(streamId, connectionState.get().isNewStreamAllowed());
  1415.           if (stream != null) {
  1416. >             stream.receivedEndOfStream();
  1417.               if (!stream.isActive()) {
  1418.                   setConnectionTimeoutForStreamCount(activeRemoteStreamCount.decrementAndGet());

java/org/apache/catalina/core/AsyncContextImpl.java:301: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.recycle()` mutates container `this.listeners` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  299.           event = null;
  300.           hasOriginalRequestAndResponse = true;
  301. >         listeners.clear();
  302.           request = null;
  303.           clearServletRequestResponse();

java/org/apache/catalina/core/AsyncContextImpl.java:295: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.recycle()` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  293.       public void recycle() {
  294.           if (log.isDebugEnabled()) {
  295. >             logDebug("recycle    ");
  296.           }
  297.           context = null;

java/org/apache/catalina/core/AsyncContextImpl.java:300: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.recycle()` writes to field `this.hasOriginalRequestAndResponse` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  298.           dispatch = null;
  299.           event = null;
  300. >         hasOriginalRequestAndResponse = true;
  301.           listeners.clear();
  302.           request = null;

java/org/apache/catalina/core/AsyncContextImpl.java:297: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.recycle()` writes to field `this.context` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  295.               logDebug("recycle    ");
  296.           }
  297. >         context = null;
  298.           dispatch = null;
  299.           event = null;

java/org/apache/catalina/core/AsyncContextImpl.java:299: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.recycle()` writes to field `this.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  297.           context = null;
  298.           dispatch = null;
  299. >         event = null;
  300.           hasOriginalRequestAndResponse = true;
  301.           listeners.clear();

java/org/apache/coyote/Response.java:625: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Response.recycle()` writes to field `this.fireListener` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  623.           // Servlet 3.1 non-blocking write listener
  624.           listener = null;
  625. >         fireListener = false;
  626.           registeredForWrite = false;
  627.   

java/org/apache/coyote/Response.java:626: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Response.recycle()` writes to field `this.registeredForWrite` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  624.           listener = null;
  625.           fireListener = false;
  626. >         registeredForWrite = false;
  627.   
  628.           // update counters

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1100: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.register(Request,HttpServletResponse,Principal,String,String,String)` indirectly reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1098.       public void register(Request request, HttpServletResponse response, Principal principal,
  1099.               String authType, String username, String password) {
  1100. >         register(request, response, principal, authType, username, password, alwaysUseSession, cache);
  1101.       }
  1102.   

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1180: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.register(Request,HttpServletResponse,Principal,String,String,String,boolean,boolean)` reads without synchronization from `this.sessionIdGenerator`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1178.           if (ssoId == null) {
  1179.               // Construct a cookie to be returned to the client
  1180. >             ssoId = sessionIdGenerator.generateSessionId();
  1181.               Cookie cookie = new Cookie(Constants.SINGLE_SIGN_ON_COOKIE, ssoId);
  1182.               cookie.setMaxAge(-1);

java/org/apache/catalina/authenticator/AuthenticatorBase.java:1170: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AuthenticatorBase.register(Request,HttpServletResponse,Principal,String,String,String,boolean,boolean)` reads without synchronization from `this.sso`. Potentially races with write in method `AuthenticatorBase.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1168.   
  1169.           // Construct a cookie to be returned to the client
  1170. >         if (sso == null) {
  1171.               return;
  1172.           }

java/org/apache/tomcat/util/net/Nio2Endpoint.java:1376: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Nio2Endpoint$Nio2SocketWrapper.registerReadInterest()` reads with synchronization from `this.readNotify`. Potentially races with unsynchronized write in method `Nio2Endpoint$Nio2SocketWrapper.read(...)`.
 Reporting because this access may occur on a background thread.
  1374.               synchronized (readCompletionHandler) {
  1375.                   // A notification is already being sent
  1376. >                 if (readNotify) {
  1377.                       return;
  1378.                   }

java/org/apache/tomcat/util/net/NioEndpoint.java:1329: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$NioSocketWrapper.registerReadInterest()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1327.                   log.debug(sm.getString("endpoint.debug.registerRead", this));
  1328.               }
  1329. >             getPoller().add(this, SelectionKey.OP_READ);
  1330.           }
  1331.   

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:600: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsWebSocketContainer.registerSession(Object,WsSession)` mutates container `this.sessions` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  598.               wsSessions.add(wsSession);
  599.           }
  600. >         sessions.put(wsSession, wsSession);
  601.       }
  602.   

java/org/apache/tomcat/util/net/NioEndpoint.java:1338: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$NioSocketWrapper.registerWriteInterest()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1336.                   log.debug(sm.getString("endpoint.debug.registerWrite", this));
  1337.               }
  1338. >             getPoller().add(this, SelectionKey.OP_WRITE);
  1339.           }
  1340.   

java/org/apache/catalina/session/JDBCStore.java:1017: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.release(Connection)` reads without synchronization from `this.dataSource`. Potentially races with write in method `JDBCStore.clear()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1015.        */
  1016.       protected void release(Connection conn) {
  1017. >         if (dataSource != null) {
  1018.               close(conn);
  1019.           }

java/org/apache/catalina/session/JDBCStore.java:1018: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCStore.release(Connection)` indirectly writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1016.       protected void release(Connection conn) {
  1017.           if (dataSource != null) {
  1018. >             close(conn);
  1019.           }
  1020.       }

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java:321: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int FairBlockingQueue.remainingCapacity()` indirectly reads without synchronization from container `this.items` via call to `size`. Potentially races with write in method `FairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  319.       @Override
  320.       public int remainingCapacity() {
  321. >         return Integer.MAX_VALUE - size();
  322.       }
  323.   

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java:318: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int MultiLockFairBlockingQueue.remainingCapacity()` indirectly reads without synchronization from container `this.items.[_]` via call to `size`. Potentially races with write in method `MultiLockFairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.       @Override
  317.       public int remainingCapacity() {
  318. >         return Integer.MAX_VALUE - size();
  319.       }
  320.   

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:1304: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void LinkedBlockingDeque$AbstractItr.remove()` reads without synchronization from `this.lastRet`. Potentially races with write in method `LinkedBlockingDeque$AbstractItr.remove()`.
 Reporting because this access may occur on a background thread.
  1302.           @Override
  1303.           public void remove() {
  1304. >             final Node<E> n = lastRet;
  1305.               if (n == null) {
  1306.                   throw new IllegalStateException();

java/org/apache/tomcat/dbcp/pool2/impl/LinkedBlockingDeque.java:1308: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void LinkedBlockingDeque$AbstractItr.remove()` writes to field `this.lastRet` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1306.                   throw new IllegalStateException();
  1307.               }
  1308. >             lastRet = null;
  1309.               lock.lock();
  1310.               try {

java/org/apache/catalina/session/JDBCStore.java:712: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.remove(String)` reads without synchronization from `this.sessionTable`. Potentially races with write in method `JDBCStore.setSessionTable(...)`.
 Reporting because this access may occur on a background thread.
  710.   
  711.           if (manager.getContext().getLogger().isDebugEnabled()) {
  712. >             manager.getContext().getLogger().debug(sm.getString(getStoreName() + ".removing", id, sessionTable));
  713.           }
  714.       }

java/org/apache/catalina/session/ManagerBase.java:721: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagerBase.remove(Session)` indirectly mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  719.       @Override
  720.       public void remove(Session session) {
  721. >         remove(session, false);
  722.       }
  723.   

java/org/apache/catalina/session/ManagerBase.java:743: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagerBase.remove(Session,boolean)` mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  741.   
  742.           if (session.getIdInternal() != null) {
  743. >             sessions.remove(session.getIdInternal());
  744.           }
  745.       }

java/org/apache/catalina/session/PersistentManagerBase.java:570: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PersistentManagerBase.remove(Session,boolean)` indirectly mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  568.       public void remove(Session session, boolean update) {
  569.   
  570. >         super.remove (session, update);
  571.   
  572.           if (store != null){

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:116: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MultipointBioSender.remove(Member)` mutates container `this.bioSenders` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  114.       public void remove(Member member) {
  115.           //disconnect senders
  116. >         BioSender sender = bioSenders.remove(member);
  117.           if ( sender != null ) sender.disconnect();
  118.       }

java/org/apache/catalina/tribes/transport/nio/ParallelNioSender.java:318: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ParallelNioSender.remove(Member)` mutates container `this.nioSenders` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.       public void remove(Member member) {
  317.           //disconnect senders
  318. >         NioSender sender = nioSenders.remove(member);
  319.           if ( sender != null ) sender.disconnect();
  320.       }

java/org/apache/tomcat/util/net/AprEndpoint.java:1743: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.remove(AprEndpoint$SendfileData)` writes to field `this.sendfileCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1741.               int rv = Poll.remove(sendfilePollset, data.socket);
  1742.               if (rv == Status.APR_SUCCESS) {
  1743. >                 sendfileCount--;
  1744.               }
  1745.               sendfileData.remove(Long.valueOf(data.socket));

java/org/apache/tomcat/util/net/AprEndpoint.java:1745: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.remove(AprEndpoint$SendfileData)` reads without synchronization from `this.sendfileData`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1743.                   sendfileCount--;
  1744.               }
  1745. >             sendfileData.remove(Long.valueOf(data.socket));
  1746.           }
  1747.   

java/org/apache/tomcat/util/net/AprEndpoint.java:1741: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.remove(AprEndpoint$SendfileData)` reads without synchronization from `this.sendfilePollset`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1739.            */
  1740.           protected void remove(SendfileData data) {
  1741. >             int rv = Poll.remove(sendfilePollset, data.socket);
  1742.               if (rv == Status.APR_SUCCESS) {
  1743.                   sendfileCount--;

java/org/apache/catalina/core/ApplicationRequest.java:139: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ApplicationRequest.removeAttribute(String)` indirectly reads with synchronization from `this.request`. Potentially races with unsynchronized write in method `ApplicationRequest.setRequest(...)`.
 Reporting because this access may occur on a background thread.
  137.               attributes.remove(name);
  138.               if (!isSpecial(name))
  139. >                 getRequest().removeAttribute(name);
  140.           }
  141.   

java/org/apache/catalina/session/StandardSession.java:1298: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.removeAttribute(String)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1296.       public void removeAttribute(String name) {
  1297.   
  1298. >         removeAttribute(name, true);
  1299.   
  1300.       }

java/org/apache/catalina/session/StandardSession.java:1326: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.removeAttribute(String,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1324.                   (sm.getString("standardSession.removeAttribute.ise"));
  1325.   
  1326. >         removeAttributeInternal(name, notify);
  1327.   
  1328.       }

java/org/apache/catalina/session/StandardSession.java:1785: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.removeAttributeInternal(String,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1783.           HttpSessionBindingEvent event = null;
  1784.           if (value instanceof HttpSessionBindingListener) {
  1785. >             event = new HttpSessionBindingEvent(getSession(), name, value);
  1786.               ((HttpSessionBindingListener) value).valueUnbound(event);
  1787.           }

java/org/apache/catalina/core/ContainerBase.java:825: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContainerBase.removeChild(Container)` indirectly reads without synchronization from container `this.listeners` via call to `size`. Potentially races with write in method `ContainerBase.removeContainerListener(...)`.
 Reporting because this access may occur on a background thread.
  823.   
  824.           if (!destroy) {
  825. >             fireContainerEvent(REMOVE_CHILD_EVENT, child);
  826.           }
  827.   

java/org/apache/catalina/mapper/Mapper.java:333: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Mapper.removeContextVersion(Context,String,String,String)` mutates container `this.contextObjectToContextVersionMap` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  331.   
  332.           hostName = renameWildcardHost(hostName);
  333. >         contextObjectToContextVersionMap.remove(ctxt);
  334.   
  335.           MappedHost host = exactFind(hosts, hostName);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:761: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeEjb(String)` indirectly writes to field `ejb.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  759.           if (ejb != null) {
  760.               support.firePropertyChange("ejb", ejb, null);
  761. >             ejb.setNamingResources(null);
  762.           }
  763.   

java/org/apache/catalina/deploy/NamingResourcesImpl.java:786: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.removeEnvironment(String)` indirectly reads without synchronization from `environment.resources`. Potentially races with write in method `NamingResourcesImpl.removeEnvironment(...)`.
 Reporting because this access may occur on a background thread.
  784.               if (resourceRequireExplicitRegistration) {
  785.                   try {
  786. >                     MBeanUtils.destroyMBean(environment);
  787.                   } catch (Exception e) {
  788.                       log.warn(sm.getString("namingResources.mbeanDestroyFail",

java/org/apache/catalina/deploy/NamingResourcesImpl.java:792: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeEnvironment(String)` indirectly writes to field `environment.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  790.                   }
  791.               }
  792. >             environment.setNamingResources(null);
  793.           }
  794.       }

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:315: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FarmWarDeployer.removeFactory(FileMessage)` mutates container `this.fileFactories` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  313.        */
  314.       public void removeFactory(FileMessage msg) {
  315. >         fileFactories.remove(msg.getFileName());
  316.       }
  317.   

java/org/apache/catalina/tribes/group/interceptors/FragmentationInterceptor.java:95: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FragmentationInterceptor.removeFragCollection(FragmentationInterceptor$FragKey)` mutates container `this.fragpieces` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.   
  94.       public void removeFragCollection(FragKey key) {
  95. >         fragpieces.remove(key);
  96.       }
  97.   

java/org/apache/tomcat/dbcp/dbcp2/datasources/InstanceKeyDataSourceFactory.java:70: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void InstanceKeyDataSourceFactory.removeInstance(String)` mutates container `datasources.InstanceKeyDataSourceFactory.instanceMap` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  68.       static void removeInstance(final String key) {
  69.           if (key != null) {
  70. >             instanceMap.remove(key);
  71.           }
  72.       }

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:770: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FarmWarDeployer.removeInvalidFileFactories()` mutates container `this.fileFactories` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  768.               FileMessageFactory factory = fileFactories.get(fileName);
  769.               if (!factory.isValid()) {
  770. >                 fileFactories.remove(fileName);
  771.               }
  772.           }

java/org/apache/catalina/ha/deploy/FarmWarDeployer.java:766: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void FarmWarDeployer.removeInvalidFileFactories()` reads without synchronization from container `this.fileFactories` via call to `keySet`. Potentially races with write in method `FarmWarDeployer.getFactory(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  764.   
  765.       protected void removeInvalidFileFactories() {
  766. >         String[] fileNames = fileFactories.keySet().toArray(new String[0]);
  767.           for (String fileName : fileNames) {
  768.               FileMessageFactory factory = fileFactories.get(fileName);

java/org/apache/catalina/deploy/NamingResourcesImpl.java:812: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeLocalEjb(String)` indirectly writes to field `localEjb.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  810.           if (localEjb != null) {
  811.               support.firePropertyChange("localEjb", localEjb, null);
  812. >             localEjb.setNamingResources(null);
  813.           }
  814.   

java/org/apache/catalina/core/StandardWrapper.java:1188: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardWrapper.removeMapping(String)` reads without synchronization from `this.parent`. Potentially races with write in method `StandardWrapper.setParent(...)`.
 Reporting because this access may occur on a background thread.
  1186.               mappingsLock.writeLock().unlock();
  1187.           }
  1188. >         if(parent.getState().equals(LifecycleState.STARTED))
  1189.               fireContainerEvent(REMOVE_MAPPING_EVENT, mapping);
  1190.   

java/org/apache/catalina/core/StandardContext.java:3982: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.removeMessageDestinationRef(String)` indirectly writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  3980.       @Deprecated
  3981.       public void removeMessageDestinationRef(String name) {
  3982. >         getNamingResources().removeMessageDestinationRef(name);
  3983.       }
  3984.   

java/org/apache/catalina/deploy/NamingResourcesImpl.java:834: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeMessageDestinationRef(String)` indirectly writes to field `mdr.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  832.               support.firePropertyChange("messageDestinationRef",
  833.                                          mdr, null);
  834. >             mdr.setNamingResources(null);
  835.           }
  836.   

java/org/apache/catalina/core/StandardContext.java:5968: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.removePostConstructMethod(String)` mutates container `this.postConstructMethods` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5966.       @Override
  5967.       public void removePostConstructMethod(String clazz) {
  5968. >         postConstructMethods.remove(clazz);
  5969.           fireContainerEvent("removePostConstructMethod", clazz);
  5970.       }

java/org/apache/catalina/core/StandardContext.java:5989: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.removePreDestroyMethod(String)` mutates container `this.preDestroyMethods` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5987.       @Override
  5988.       public void removePreDestroyMethod(String clazz) {
  5989. >         preDestroyMethods.remove(clazz);
  5990.           fireContainerEvent("removePreDestroyMethod", clazz);
  5991.       }

java/org/apache/catalina/deploy/NamingResourcesImpl.java:871: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.removeResource(String)` indirectly reads without synchronization from `resource.resources`. Potentially races with write in method `NamingResourcesImpl.removeResource(...)`.
 Reporting because this access may occur on a background thread.
  869.               if (resourceRequireExplicitRegistration) {
  870.                   try {
  871. >                     MBeanUtils.destroyMBean(resource);
  872.                   } catch (Exception e) {
  873.                       log.warn(sm.getString("namingResources.mbeanDestroyFail",

java/org/apache/catalina/deploy/NamingResourcesImpl.java:877: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeResource(String)` indirectly writes to field `resource.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  875.                   }
  876.               }
  877. >             resource.setNamingResources(null);
  878.           }
  879.       }

java/org/apache/catalina/deploy/NamingResourcesImpl.java:898: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeResourceEnvRef(String)` indirectly writes to field `resourceEnvRef.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  896.           if (resourceEnvRef != null) {
  897.               support.firePropertyChange("resourceEnvRef", resourceEnvRef, null);
  898. >             resourceEnvRef.setNamingResources(null);
  899.           }
  900.   

java/org/apache/catalina/deploy/NamingResourcesImpl.java:923: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.removeResourceLink(String)` indirectly reads without synchronization from `resourceLink.resources`. Potentially races with write in method `NamingResourcesImpl.addEnvironment(...)`.
 Reporting because this access may occur on a background thread.
  921.               if (resourceRequireExplicitRegistration) {
  922.                   try {
  923. >                     MBeanUtils.destroyMBean(resourceLink);
  924.                   } catch (Exception e) {
  925.                       log.warn(sm.getString("namingResources.mbeanDestroyFail",

java/org/apache/catalina/deploy/NamingResourcesImpl.java:929: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeResourceLink(String)` indirectly writes to field `resourceLink.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  927.                   }
  928.               }
  929. >             resourceLink.setNamingResources(null);
  930.           }
  931.       }

java/org/apache/catalina/deploy/NamingResourcesImpl.java:949: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NamingResourcesImpl.removeService(String)` indirectly writes to field `service.resources` outside of synchronization.
 Reporting because this access may occur on a background thread.
  947.           if (service != null) {
  948.               support.firePropertyChange("service", service, null);
  949. >             service.setNamingResources(null);
  950.           }
  951.   

java/org/apache/catalina/authenticator/SingleSignOn.java:591: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SingleSignOn.removeSession(String,Session)` indirectly reads without synchronization from `this.engine`. Potentially races with write in method `SingleSignOn.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  589.           // deregister the entry.
  590.           if (entry.findSessions().size() == 0) {
  591. >             deregister(ssoId);
  592.           }
  593.       }

java/org/apache/catalina/session/PersistentManagerBase.java:505: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PersistentManagerBase.removeSuper(Session)` indirectly mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  503.       @Override
  504.       public void removeSuper(Session session) {
  505. >         super.remove(session, false);
  506.       }
  507.   

java/org/apache/catalina/session/StandardSession.java:1352: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.removeValue(String)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1350.       public void removeValue(String name) {
  1351.   
  1352. >         removeAttribute(name);
  1353.   
  1354.       }

java/org/apache/jasper/compiler/JspRuntimeContext.java:215: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JspRuntimeContext.removeWrapper(String)` mutates container `this.jsps` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  213.        */
  214.       public void removeWrapper(String jspUri) {
  215. >         jsps.remove(jspUri);
  216.       }
  217.   

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:604: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Serializable AbstractReplicatedMap.replyRequest(Serializable,Member)` indirectly writes to field `mapmsg.value` outside of synchronization.
 Reporting because this access may occur on a background thread.
  602.           // ping
  603.           if (mapmsg.getMsgType() == MapMessage.MSG_PING) {
  604. >             mapmsg.setValue(state);
  605.               mapmsg.setPrimary(channel.getLocalMember(false));
  606.               return mapmsg;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:576: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Serializable AbstractReplicatedMap.replyRequest(Serializable,Member)` indirectly writes to field `mapmsg.key` outside of synchronization.
 Reporting because this access may occur on a background thread.
  574.           //backup request
  575.           if (mapmsg.getMsgType() == MapMessage.MSG_RETRIEVE_BACKUP) {
  576. >             MapEntry<K,V> entry = innerMap.get(mapmsg.getKey());
  577.               if (entry == null || (!entry.isSerializable()) )return null;
  578.               mapmsg.setValue( (Serializable) entry.getValue());

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:569: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Serializable AbstractReplicatedMap.replyRequest(Serializable,Member)` indirectly writes to field `mapmsg.primary` outside of synchronization.
 Reporting because this access may occur on a background thread.
  567.           //map start request
  568.           if (mapmsg.getMsgType() == MapMessage.MSG_START) {
  569. >             mapmsg.setPrimary(channel.getLocalMember(false));
  570.               mapMemberAdded(sender);
  571.               return mapmsg;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:570: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Serializable AbstractReplicatedMap.replyRequest(Serializable,Member)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `AbstractReplicatedMap.breakdown()`.
 Reporting because this access may occur on a background thread.
  568.           if (mapmsg.getMsgType() == MapMessage.MSG_START) {
  569.               mapmsg.setPrimary(channel.getLocalMember(false));
  570. >             mapMemberAdded(sender);
  571.               return mapmsg;
  572.           }

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:39: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2AsyncUpgradeHandler.reprioritise(int,int,boolean,int)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  37.   import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
  38.   
  39. > public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
  40.   
  41.       private static final ByteBuffer[] BYTEBUFFER_ARRAY = new ByteBuffer[0];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1500: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2UpgradeHandler.reprioritise(int,int,boolean,int)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1498.           Stream stream = getStream(streamId, false);
  1499.           if (stream == null) {
  1500. >             stream = createRemoteStream(streamId);
  1501.           }
  1502.           stream.checkState(FrameType.PRIORITY);

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1498: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.reprioritise(int,int,boolean,int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1496.           increaseOverheadCount();
  1497.   
  1498. >         Stream stream = getStream(streamId, false);
  1499.           if (stream == null) {
  1500.               stream = createRemoteStream(streamId);

java/org/apache/catalina/ha/session/BackupManager.java:95: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ClusterMessage BackupManager.requestCompleted(String)` reads without synchronization from `this.sessions`. Potentially races with write in method `BackupManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.       public ClusterMessage requestCompleted(String sessionId) {
  94.           if (!getState().isAvailable()) return null;
  95. >         LazyReplicatedMap<String,Session> map =
  96.                   (LazyReplicatedMap<String,Session>)sessions;
  97.           map.replicate(sessionId,false);

java/org/apache/catalina/ha/session/DeltaManager.java:970: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ClusterMessage DeltaManager.requestCompleted(String,boolean)` indirectly reads without synchronization from container `this.sessions` via call to `get`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  968.           SessionMessage msg = null;
  969.           try {
  970. >             session = (DeltaSession) findSession(sessionId);
  971.               if (session == null) {
  972.                   // A parallel request has called session.invalidate() which has

java/org/apache/catalina/ha/session/DeltaManager.java:977: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ClusterMessage DeltaManager.requestCompleted(String,boolean)` writes to field `this.counterSend_EVT_SESSION_DELTA` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  975.               }
  976.               if (session.isDirty()) {
  977. >                 counterSend_EVT_SESSION_DELTA++;
  978.                   msg = new SessionMessageImpl(getName(),
  979.                                                SessionMessage.EVT_SESSION_DELTA,

java/org/apache/catalina/ha/session/DeltaManager.java:976: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ClusterMessage DeltaManager.requestCompleted(String,boolean)` indirectly reads without synchronization from `session.deltaRequest`. Potentially races with write in method `DeltaManager.messageDataReceived(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  974.                   return null;
  975.               }
  976. >             if (session.isDirty()) {
  977.                   counterSend_EVT_SESSION_DELTA++;
  978.                   msg = new SessionMessageImpl(getName(),

java/org/apache/catalina/tribes/transport/nio/NioSender.java:323: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.reset()` indirectly writes to field `this.ackbuf.bufSize` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  321.           if ( writebuf != null ) writebuf.clear();
  322.           current = null;
  323. >         ackbuf.clear();
  324.           remaining = 0;
  325.           complete = false;

java/org/apache/catalina/tribes/transport/nio/NioSender.java:321: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioSender.reset()` reads without synchronization from `this.writebuf`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  319.           }
  320.           if ( readbuf != null ) readbuf.clear();
  321. >         if ( writebuf != null ) writebuf.clear();
  322.           current = null;
  323.           ackbuf.clear();

java/org/apache/catalina/tribes/transport/nio/NioSender.java:317: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NioSender.reset()` reads without synchronization from `this.readbuf`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  315.   
  316.       public void reset() {
  317. >         if ( isConnected() && readbuf == null) {
  318.               readbuf = getReadBuffer();
  319.           }

java/org/apache/catalina/tribes/transport/nio/NioSender.java:324: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.reset()` writes to field `this.remaining` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  322.           current = null;
  323.           ackbuf.clear();
  324. >         remaining = 0;
  325.           complete = false;
  326.           setAttempt(0);

java/org/apache/catalina/tribes/transport/nio/NioSender.java:318: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioSender.reset()` writes to field `this.readbuf` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  316.       public void reset() {
  317.           if ( isConnected() && readbuf == null) {
  318. >             readbuf = getReadBuffer();
  319.           }
  320.           if ( readbuf != null ) readbuf.clear();

java/org/apache/coyote/Response.java:340: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Response.reset()` indirectly writes to field `this.fireListener` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  338.           }
  339.   
  340. >         recycle();
  341.       }
  342.   

java/org/apache/tomcat/util/buf/StringCache.java:203: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StringCache.reset()` writes to field `buf.StringCache.hitCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  201.   
  202.       public void reset() {
  203. >         hitCount = 0;
  204.           accessCount = 0;
  205.           synchronized (bcStats) {

java/org/apache/tomcat/util/buf/StringCache.java:204: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StringCache.reset()` writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  202.       public void reset() {
  203.           hitCount = 0;
  204. >         accessCount = 0;
  205.           synchronized (bcStats) {
  206.               bcCache = null;

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1553: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.reset(int,long)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1551.       @Override
  1552.       public void reset(int streamId, long errorCode) throws Http2Exception  {
  1553. >         Stream stream = getStream(streamId, true);
  1554.           stream.checkState(FrameType.RST);
  1555.           stream.receiveReset(errorCode);

java/org/apache/catalina/core/StandardContext.java:4799: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.resourcesStart()` reads without synchronization from `this.resources`. Potentially races with write in method `StandardContext.setResources(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  4797.           // Check current status in case resources were added that had already
  4798.           // been started
  4799. >         if (!resources.getState().isAvailable()) {
  4800.               resources.start();
  4801.           }

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:525: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericObjectPool.returnObject(Object)` reads without synchronization from container `this.allObjects` via call to `get`. Potentially races with write in method `GenericObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  523.       @Override
  524.       public void returnObject(final T obj) {
  525. >         final PooledObject<T> p = allObjects.get(new IdentityWrapper<>(obj));
  526.   
  527.           if (p == null) {

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:453: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.returnObject(Object,Object)` reads without synchronization from container `this.poolMap` via call to `get`. Potentially races with write in method `GenericKeyedObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  451.       public void returnObject(final K key, final T obj) {
  452.   
  453. >         final ObjectDeque<T> objectDeque = poolMap.get(key);
  454.   
  455.           if (objectDeque == null) {

java/org/apache/catalina/tribes/transport/RxTaskPool.java:102: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RxTaskPool.returnWorker(AbstractRxTask)` reads without synchronization from `this.running`. Potentially races with write in method `RxTaskPool.stop()`.
 Reporting because this access may occur on a background thread.
  100.        */
  101.       public void returnWorker (AbstractRxTask worker) {
  102. >         if ( running ) {
  103.               synchronized (mutex) {
  104.                   used.remove(worker);

java/org/apache/catalina/tribes/transport/RxTaskPool.java:113: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RxTaskPool.returnWorker(AbstractRxTask)` indirectly writes to field `worker.doRun` outside of synchronization.
 Reporting because this access may occur on a background thread.
  111.               }
  112.           } else {
  113. >             worker.close();
  114.           }
  115.       }

java/org/apache/jasper/runtime/TagHandlerPool.java:142: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TagHandlerPool.reuse(Tag)` reads without synchronization from `this.instanceManager`. Potentially races with write in method `TagHandlerPool.init(...)`.
 Reporting because this access may occur on a background thread.
  140.           }
  141.           // There is no need for other threads to wait for us to release
  142. >         JspRuntimeLibrary.releaseTag(handler, instanceManager);
  143.       }
  144.   

java/org/apache/catalina/valves/AccessLogValve.java:428: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AccessLogValve.rotate()` reads without synchronization from `this.rotatable`. Potentially races with write in method `AccessLogValve.setRotatable(...)`.
 Reporting because this access may occur on a background thread.
  426.        */
  427.       public void rotate() {
  428. >         if (rotatable) {
  429.               // Only do a logfile switch check once a second, max.
  430.               long systime = System.currentTimeMillis();

java/org/apache/catalina/session/ManagerBase.java:762: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagerBase.rotateSessionId(Session)` indirectly reads without synchronization from container `this.sessions` via call to `containsKey`. Potentially races with write in method `ManagerBase.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  760.       @Override
  761.       public String rotateSessionId(Session session) {
  762. >         String newId = generateSessionId();
  763.           changeSessionId(session, newId, true, true);
  764.           return newId;

java/org/apache/tomcat/util/net/AprEndpoint.java:1406: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Poller.run()` writes to field `wrapper.pollerFlags` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1404.                                   continue;
  1405.                               }
  1406. >                             wrapper.pollerFlags = wrapper.pollerFlags & ~((int) desc[n*2]);
  1407.                               // Check for failed sockets and hand this socket off to a worker
  1408.                               if (((desc[n*2] & Poll.APR_POLLHUP) == Poll.APR_POLLHUP)

java/org/apache/tomcat/util/net/AprEndpoint.java:1533: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` indirectly reads with synchronization from `sc.socketWrapper`. Potentially races with unsynchronized write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1531.                           // This works and uses only one timeout mechanism for everything, but the
  1532.                           // non event poller might be a bit faster by using the old maintain.
  1533. >                         maintain();
  1534.                       }
  1535.                   } catch (Throwable t) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1357: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `wrapper.pollerFlags`. Potentially races with write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1355.                                   if (info.read() || info.write()) {
  1356.                                       wrapper.pollerFlags = wrapper.pollerFlags |
  1357. >                                             (info.read() ? Poll.APR_POLLIN : 0) |
  1358.                                               (info.write() ? Poll.APR_POLLOUT : 0);
  1359.                                       // A socket can only be added to the poller

java/org/apache/tomcat/util/net/AprEndpoint.java:1422: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Poller.run()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1420.                                   if ((desc[n*2] & Poll.APR_POLLIN) == Poll.APR_POLLIN) {
  1421.                                       // Error probably occurred during a non-blocking read
  1422. >                                     if (!processSocket(desc[n*2+1], SocketEvent.OPEN_READ)) {
  1423.                                           // Close socket and clear pool
  1424.                                           wrapper.close();

java/org/apache/tomcat/util/net/AprEndpoint.java:1335: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Poller.run()` indirectly writes to field `this.timeouts.size` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1333.                           while (info != null) {
  1334.                               localAddList.remove(info.socket);
  1335. >                             removeFromPoller(info.socket);
  1336.                               closeSocketInternal(info.socket);
  1337.                               destroySocketInternal(info.socket);

java/org/apache/tomcat/util/net/AprEndpoint.java:1394: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `this.desc.[_]`. Potentially races with write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1392.                                   log.debug(sm.getString(
  1393.                                           "endpoint.debug.pollerProcess",
  1394. >                                         Long.valueOf(desc[n*2+1]),
  1395.                                           Long.valueOf(desc[n*2])));
  1396.                               }

java/org/apache/tomcat/util/net/AprEndpoint.java:1386: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `this.aprPoller`. Potentially races with write in method `AprEndpoint$Poller.run()`.
 Reporting because this access may occur on a background thread.
  1384.                       boolean reset = false;
  1385.   
  1386. >                     int rv = Poll.poll(aprPoller, pollTime, desc, true);
  1387.                       if (rv > 0) {
  1388.                           rv = mergeDescriptors(desc, rv);

java/org/apache/tomcat/util/net/AprEndpoint.java:1518: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `this.pollerSize`. Potentially races with write in method `AprEndpoint$Poller.init()`.
 Reporting because this access may occur on a background thread.
  1516.                           // Reallocate the current poller
  1517.                           int count = Poll.pollset(aprPoller, desc);
  1518. >                         long newPoller = allocatePoller(pollerSize, pool, -1);
  1519.                           // Don't restore connections for now, since I have not tested it
  1520.                           connectionCount.addAndGet(-count);

java/org/apache/tomcat/util/net/AprEndpoint.java:1351: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `this.timeouts`. Potentially races with write in method `AprEndpoint$Poller.init()`.
 Reporting because this access may occur on a background thread.
  1349.                                           Long.valueOf(info.socket)));
  1350.                               }
  1351. >                             timeouts.remove(info.socket);
  1352.                               AprSocketWrapper wrapper =
  1353.                                       (AprSocketWrapper) connections.get(Long.valueOf(info.socket));

java/org/apache/tomcat/util/net/AprEndpoint.java:1388: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Poller.run()` indirectly writes to field `this.desc.[_]` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1386.                       int rv = Poll.poll(aprPoller, pollTime, desc, true);
  1387.                       if (rv > 0) {
  1388. >                         rv = mergeDescriptors(desc, rv);
  1389.                           connectionCount.addAndGet(-rv);
  1390.                           for (int n = 0; n < rv; n++) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1522: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Poller.run()` writes to field `this.aprPoller` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1520.                           connectionCount.addAndGet(-count);
  1521.                           Poll.destroy(aprPoller);
  1522. >                         aprPoller = newPoller;
  1523.                       }
  1524.                   } catch (Throwable t) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1277: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Poller.run()` reads without synchronization from `this.addList`. Potentially races with write in method `AprEndpoint$Poller.init()`.
 Reporting because this access may occur on a background thread.
  1275.                   // Check timeouts if the poller is empty.
  1276.                   while (pollerRunning && connectionCount.get() < 1 &&
  1277. >                         addList.size() < 1 && closeList.size() < 1) {
  1278.                       try {
  1279.                           if (getConnectionTimeout() > 0 && pollerRunning) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1812: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.run()` reads without synchronization from `this.desc`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because this access may occur on a background thread.
  1810.                       maintainTime += pollTime;
  1811.                       // Pool for the specified interval
  1812. >                     int rv = Poll.poll(sendfilePollset, pollTime, desc, false);
  1813.                       if (rv > 0) {
  1814.                           for (int n = 0; n < rv; n++) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1768: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.run()` reads without synchronization from `this.addS`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because this access may occur on a background thread.
  1766.                   }
  1767.                   // Loop if poller is empty
  1768. >                 while (sendfileRunning && sendfileCount < 1 && addS.size() < 1) {
  1769.                       // Reset maintain time.
  1770.                       maintainTime = 0;

java/org/apache/tomcat/util/net/AprEndpoint.java:1796: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.run()` reads with synchronization from `this.sendfileCount`. Potentially races with unsynchronized write in method `AprEndpoint$Sendfile.run()`.
 Reporting because this access may occur on a background thread.
  1794.                                   if (rv == Status.APR_SUCCESS) {
  1795.                                       sendfileData.put(Long.valueOf(data.socket), data);
  1796. >                                     sendfileCount++;
  1797.                                   } else {
  1798.                                       getLog().warn(sm.getString(

java/org/apache/tomcat/util/net/AprEndpoint.java:1842: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.run()` writes to field `state.length` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1840.   
  1841.                               state.pos += nw;
  1842. >                             state.length -= nw;
  1843.                               if (state.length == 0) {
  1844.                                   remove(state);

java/org/apache/tomcat/util/net/AprEndpoint.java:1841: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.run()` writes to field `state.pos` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1839.                               }
  1840.   
  1841. >                             state.pos += nw;
  1842.                               state.length -= nw;
  1843.                               if (state.length == 0) {

java/org/apache/tomcat/util/net/AprEndpoint.java:1857: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.run()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1855.                                       Socket.timeoutSet(state.socket, getConnectionTimeout() * 1000);
  1856.                                       // Process the pipelined request data
  1857. >                                     if (!processSocket(state.socket, SocketEvent.OPEN_READ)) {
  1858.                                           closeSocketInternal(state.socket);
  1859.                                       }

java/org/apache/tomcat/util/net/AprEndpoint.java:1902: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.run()` reads without synchronization from `this.sendfileData`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because this access may occur on a background thread.
  1900.                               for (int n = 0; n < rv; n++) {
  1901.                                   // Get the sendfile state
  1902. >                                 SendfileData state = sendfileData.get(Long.valueOf(desc[n]));
  1903.                                   // Close socket and clear pool
  1904.                                   remove(state);

java/org/apache/tomcat/util/net/AprEndpoint.java:1904: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AprEndpoint$Sendfile.run()` indirectly writes to field `this.sendfileCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1902.                                   SendfileData state = sendfileData.get(Long.valueOf(desc[n]));
  1903.                                   // Close socket and clear pool
  1904. >                                 remove(state);
  1905.                                   // Destroy file descriptor pool, which should close the file
  1906.                                   // Close the socket, as the response would be incomplete

java/org/apache/tomcat/util/net/AprEndpoint.java:1829: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$Sendfile.run()` reads without synchronization from `state.length`. Potentially races with write in method `AprEndpoint$Sendfile.run()`.
 Reporting because this access may occur on a background thread.
  1827.                               }
  1828.                               // Write some data using sendfile
  1829. >                             long nw = Socket.sendfilen(state.socket, state.fd,
  1830.                                                          state.pos,
  1831.                                                          state.length, 0);

java/org/apache/tomcat/util/net/AprEndpoint.java:1947: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprEndpoint$SocketWithOptionsProcessor.run()` reads without synchronization from `this.socket`. Potentially races with write in method `AprEndpoint$SocketWithOptionsProcessor.run()`.
 Reporting because this access may occur on a background thread.
  1945.           public void run() {
  1946.   
  1947. >             synchronized (socket) {
  1948.                   if (!deferAccept) {
  1949.                       if (setSocketOptions(socket)) {

java/org/apache/tomcat/util/net/NioEndpoint.java:1567: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$NioSocketWrapper$NioOperationState.run()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1565.                       inline = false;
  1566.                       if (read) {
  1567. >                         registerReadInterest();
  1568.                       } else {
  1569.                           registerWriteInterest();

java/org/apache/tomcat/util/net/NioEndpoint.java:751: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.run()` indirectly writes to field `sc.socketWrapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  749.   
  750.                   // Process timeouts
  751. >                 timeout(keyCount,hasEvents);
  752.               }
  753.   

java/org/apache/tomcat/util/net/NioEndpoint.java:746: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.run()` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  744.                       } else {
  745.                           iterator.remove();
  746. >                         processKey(sk, socketWrapper);
  747.                       }
  748.                   }

java/org/apache/tomcat/util/net/SocketProcessorBase.java:40: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SocketProcessorBase.run()` reads without synchronization from `this.socketWrapper`. Potentially races with write in method `SocketProcessorBase.reset(...)`.
 Reporting because this access may occur on a background thread.
  38.       @Override
  39.       public final void run() {
  40. >         synchronized (socketWrapper) {
  41.               // It is possible that processing may be triggered for read and
  42.               // write at the same time. The sync above makes sure that processing

java/org/apache/catalina/users/MemoryUserDatabase.java:626: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.save()` reads without synchronization from `this.pathname`. Potentially races with write in method `MemoryUserDatabase.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  624.               throw new IOException(sm.getString("memoryUserDatabase.fileDelete", fileOld));
  625.           }
  626. >         File fileOrig = new File(pathname);
  627.           if (!fileOrig.isAbsolute()) {
  628.               fileOrig = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathname);

java/org/apache/catalina/users/MemoryUserDatabase.java:619: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.save()` reads without synchronization from `this.pathnameOld`. Potentially races with write in method `MemoryUserDatabase.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  617.   
  618.           // Perform the required renames to permanently save this file
  619. >         File fileOld = new File(pathnameOld);
  620.           if (!fileOld.isAbsolute()) {
  621.               fileOld = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathnameOld);

java/org/apache/catalina/users/MemoryUserDatabase.java:550: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.save()` indirectly reads without synchronization from `this.readonly`. Potentially races with write in method `MemoryUserDatabase.setReadonly(...)`.
 Reporting because this access may occur on a background thread.
  548.       public void save() throws Exception {
  549.   
  550. >         if (getReadonly()) {
  551.               log.error(sm.getString("memoryUserDatabase.readOnly"));
  552.               return;

java/org/apache/catalina/users/MemoryUserDatabase.java:561: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryUserDatabase.save()` reads without synchronization from `this.pathnameNew`. Potentially races with write in method `MemoryUserDatabase.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  559.   
  560.           // Write out contents to a temporary file
  561. >         File fileNew = new File(pathnameNew);
  562.           if (!fileNew.isAbsolute()) {
  563.               fileNew = new File(System.getProperty(Globals.CATALINA_BASE_PROP), pathnameNew);

java/org/apache/catalina/session/JDBCStore.java:845: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JDBCStore.save(Session)` reads without synchronization from `this.sessionTable`. Potentially races with write in method `JDBCStore.setSessionTable(...)`.
 Reporting because this access may occur on a background thread.
  843.           if (manager.getContext().getLogger().isDebugEnabled()) {
  844.               manager.getContext().getLogger().debug(sm.getString(getStoreName() + ".saving",
  845. >                     session.getIdInternal(), sessionTable));
  846.           }
  847.       }

java/org/apache/catalina/tribes/group/GroupChannel.java:227: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `UniqueId GroupChannel.send(org.apache.catalina.tribes.Member[],Serializable,int)` indirectly reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  225.       public UniqueId send(Member[] destination, Serializable msg, int options)
  226.               throws ChannelException {
  227. >         return send(destination,msg,options,null);
  228.       }
  229.   

java/org/apache/catalina/tribes/group/GroupChannel.java:274: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `UniqueId GroupChannel.send(org.apache.catalina.tribes.Member[],Serializable,int,ErrorHandler)` indirectly reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  272.                   payload.setErrorHandler(handler);
  273.               }
  274. >             getFirstInterceptor().sendMessage(destination, data, payload);
  275.               if ( Logs.MESSAGES.isTraceEnabled() ) {
  276.                   Logs.MESSAGES.trace("GroupChannel - Sent msg:" + new UniqueId(data.getUniqueId()) +

java/org/apache/catalina/ha/tcp/ReplicationValve.java:531: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.send(ClusterManager,String)` reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  529.       protected void send(ClusterManager manager, String sessionId) {
  530.           ClusterMessage msg = manager.requestCompleted(sessionId);
  531. >         if (msg != null && cluster != null) {
  532.               cluster.send(msg);
  533.               if(doStatistics()) {

java/org/apache/catalina/ha/session/DeltaManager.java:459: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.send(SessionMessage)` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  457.        */
  458.       protected void send(SessionMessage msg) {
  459. >         if(cluster != null) {
  460.               cluster.send(msg);
  461.           }

java/org/apache/catalina/tribes/transport/bio/BioReplicationTask.java:158: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BioReplicationTask.sendAck(byte[])` reads without synchronization from `this.socket`. Potentially races with write in method `BioReplicationTask.serviceSocket(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  156.       protected void sendAck(byte[] command) {
  157.           try {
  158. >             OutputStream out = socket.getOutputStream();
  159.               out.write(command);
  160.               out.flush();

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:130: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendBytes(ByteBuffer)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  128.           }
  129.           stateMachine.binaryStart();
  130. >         sendMessageBlock(Constants.OPCODE_BINARY, data, true);
  131.           stateMachine.complete(true);
  132.       }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:151: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.sendBytesByCompletion(ByteBuffer,SendHandler)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  149.           StateUpdateSendHandler sush = new StateUpdateSendHandler(handler, stateMachine);
  150.           stateMachine.binaryStart();
  151. >         startMessage(Constants.OPCODE_BINARY, data, true, sush);
  152.       }
  153.   

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:137: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Future WsRemoteEndpointImplBase.sendBytesByFuture(ByteBuffer)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  135.       public Future<Void> sendBytesByFuture(ByteBuffer data) {
  136.           FutureToSendHandler f2sh = new FutureToSendHandler(wsSession);
  137. >         sendBytesByCompletion(data, f2sh);
  138.           return f2sh;
  139.       }

java/org/apache/catalina/ha/session/DeltaManager.java:519: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.sendChangeSessionId(String,String)` writes to field `this.counterSend_EVT_CHANGE_SESSION_ID` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  517.                                   + System.currentTimeMillis());
  518.                   msg.setTimestamp(System.currentTimeMillis());
  519. >                 counterSend_EVT_CHANGE_SESSION_ID++;
  520.                   send(msg);
  521.               } catch (IOException e) {

java/org/apache/catalina/ha/session/DeltaManager.java:509: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.sendChangeSessionId(String,String)` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  507.   
  508.       protected void sendChangeSessionId(String newSessionID, String orgSessionID) {
  509. >         if (cluster.getMembers().length > 0) {
  510.               try {
  511.                   // serialize sessionID

java/org/apache/catalina/ha/session/DeltaManager.java:449: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.sendCreateSession(String,DeltaSession)` writes to field `this.counterSend_EVT_SESSION_CREATED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  447.               }
  448.               msg.setTimestamp(session.getCreationTime());
  449. >             counterSend_EVT_SESSION_CREATED++;
  450.               send(msg);
  451.           }

java/org/apache/catalina/ha/session/DeltaManager.java:438: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.sendCreateSession(String,DeltaSession)` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  436.        */
  437.       protected void sendCreateSession(String sessionId, DeltaSession session) {
  438. >         if(cluster.getMembers().length > 0 ) {
  439.               SessionMessage msg =
  440.                   new SessionMessageImpl(getName(),

java/org/apache/catalina/ha/tcp/ReplicationValve.java:438: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.sendCrossContextSession()` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  436.                               session.getManager().getContext().getName() ));
  437.                   }
  438. >                 sendMessage(session,(ClusterManager)session.getManager());
  439.                   if(doStatistics()) {
  440.                       nrOfCrossContextSendRequests++;

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:263: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.sendElectionMsg(Member,Member,NonBlockingCoordinator$CoordinationMessage)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  261.   
  262.       protected void sendElectionMsg(Member local, Member next, CoordinationMessage msg) throws ChannelException {
  263. >         fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_SEND_MSG,this,"Sending election message to("+next.getName()+")"));
  264.           super.sendMessage(new Member[] {next}, createData(msg, local), null);
  265.       }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:274: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.sendElectionMsgToNextInline(Member,NonBlockingCoordinator$CoordinationMessage)` indirectly reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  272.           while ( !sent && current >= 0 ) {
  273.               try {
  274. >                 sendElectionMsg(local, msg.getMembers()[current], msg);
  275.                   sent = true;
  276.               }catch ( ChannelException x  ) {

java/org/apache/catalina/ha/tcp/ReplicationValve.java:548: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.sendInvalidSessions(ClusterManager)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  546.               for ( int i=0;i<invalidIds.length; i++ ) {
  547.                   try {
  548. >                     send(manager,invalidIds[i]);
  549.                   } catch ( Exception x ) {
  550.                       log.error(sm.getString("ReplicationValve.send.invalid.failure",invalidIds[i]),x);

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:87: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MessageDispatchInterceptor.sendMessage(org.apache.catalina.tribes.Member[],ChannelMessage,InterceptorPayload)` indirectly reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  85.                   msg = (ChannelMessage)msg.deepclone();
  86.               }
  87. >             if (!addToQueue(msg, destination, payload)) {
  88.                   throw new ChannelException(
  89.                           sm.getString("messageDispatchInterceptor.unableAdd.queue"));

java/org/apache/catalina/ha/tcp/ReplicationValve.java:518: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.sendMessage(Session,ClusterManager)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  516.           String id = session.getIdInternal();
  517.           if (id != null) {
  518. >             send(manager, id);
  519.           }
  520.       }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:258: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendMessageBlock(byte,ByteBuffer,boolean)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  256.       void sendMessageBlock(byte opCode, ByteBuffer payload, boolean last)
  257.               throws IOException {
  258. >         sendMessageBlock(opCode, payload, last, getTimeoutExpiry());
  259.       }
  260.   

java/org/apache/catalina/tribes/group/GroupChannel.java:374: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GroupChannel.sendNoRpcChannelReply(RpcMessage,Member)` indirectly reads without synchronization from `this.interceptors`. Potentially races with write in method `GroupChannel.setupDefaultStack()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  372.               RpcMessage.NoRpcChannelReply reply =
  373.                       new RpcMessage.NoRpcChannelReply(msg.rpcId, msg.uuid);
  374. >             send(new Member[]{destination},reply,Channel.SEND_OPTIONS_ASYNCHRONOUS);
  375.           } catch ( Exception x ) {
  376.               log.error(sm.getString("groupChannel.sendFail.noRpcChannelReply"),x);

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:598: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendObject(Object)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  596.           } else if (encoder instanceof Encoder.Binary) {
  597.               ByteBuffer msg = ((Encoder.Binary) encoder).encode(obj);
  598. >             sendBytes(msg);
  599.           } else if (encoder instanceof Encoder.BinaryStream) {
  600.               try (OutputStream os = getSendStream()) {

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:585: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.sendObject(Object)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  583.           if (encoder == null && byte[].class.isAssignableFrom(obj.getClass())) {
  584.               ByteBuffer msg = ByteBuffer.wrap((byte[]) obj);
  585. >             sendBytes(msg);
  586.               return;
  587.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:635: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.sendObjectByCompletion(Object,SendHandler)` indirectly reads without synchronization from container `messageParts` via call to `size`. Potentially races with write in method `WsRemoteEndpointImplBase.startMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  633.           if (encoder == null && Util.isPrimitive(obj.getClass())) {
  634.               String msg = obj.toString();
  635. >             sendStringByCompletion(msg, completion);
  636.               return;
  637.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:640: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.sendObjectByCompletion(Object,SendHandler)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  638.           if (encoder == null && byte[].class.isAssignableFrom(obj.getClass())) {
  639.               ByteBuffer msg = ByteBuffer.wrap((byte[]) obj);
  640. >             sendBytesByCompletion(msg, completion);
  641.               return;
  642.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:655: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendObjectByCompletion(Object,SendHandler)` indirectly writes to field `this.nextFragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  653.               } else if (encoder instanceof Encoder.Binary) {
  654.                   ByteBuffer msg = ((Encoder.Binary) encoder).encode(obj);
  655. >                 sendBytesByCompletion(msg, completion);
  656.               } else if (encoder instanceof Encoder.BinaryStream) {
  657.                   try (OutputStream os = getSendStream()) {

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:612: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Future WsRemoteEndpointImplBase.sendObjectByFuture(Object)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  610.       public Future<Void> sendObjectByFuture(Object obj) {
  611.           FutureToSendHandler f2sh = new FutureToSendHandler(wsSession);
  612. >         sendObjectByCompletion(obj, f2sh);
  613.           return f2sh;
  614.       }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:161: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendPartialBytes(ByteBuffer,boolean)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  159.           }
  160.           stateMachine.binaryPartialStart();
  161. >         sendMessageBlock(Constants.OPCODE_BINARY, partialByte, last);
  162.           stateMachine.complete(last);
  163.       }

java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java:140: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpPingInterceptor.sendPing()` reads without synchronization from `this.staticMembers`. Potentially races with write in method `TcpPingInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  138.               tcpFailureDetector.checkMembers(true);
  139.           } else {
  140. >             StaticMembershipInterceptor smi =
  141.                       staticOnly && staticMembers != null ? staticMembers.get() : null;
  142.               if (smi != null) {

java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java:133: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void TcpPingInterceptor.sendPing()` reads without synchronization from `this.failureDetector`. Potentially races with write in method `TcpPingInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  131.   
  132.       protected void sendPing() {
  133. >         TcpFailureDetector tcpFailureDetector =
  134.                   failureDetector != null ? failureDetector.get() : null;
  135.           if (tcpFailureDetector != null) {

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1703: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler$PingManager.sendPing(boolean)` reads without synchronization from `this.lastPingNanoTime`. Potentially races with write in method `Http2UpgradeHandler$PingManager.sendPing(...)`.
 Reporting because this access may occur on a background thread.
  1701.               }
  1702.               long now = System.nanoTime();
  1703. >             if (force || now - lastPingNanoTime > pingIntervalNano) {
  1704.                   lastPingNanoTime = now;
  1705.                   byte[] payload = new byte[8];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1704: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Http2UpgradeHandler$PingManager.sendPing(boolean)` writes to field `this.lastPingNanoTime` outside of synchronization.
 Reporting because this access may occur on a background thread.
  1702.               long now = System.nanoTime();
  1703.               if (force || now - lastPingNanoTime > pingIntervalNano) {
  1704. >                 lastPingNanoTime = now;
  1705.                   byte[] payload = new byte[8];
  1706.                   synchronized (socketWrapper) {

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:172: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendPing(ByteBuffer)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  170.               throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.tooMuchData"));
  171.           }
  172. >         sendMessageBlock(Constants.OPCODE_PING, applicationData, true);
  173.       }
  174.   

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:182: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendPong(ByteBuffer)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  180.               throw new IllegalArgumentException(sm.getString("wsRemoteEndpoint.tooMuchData"));
  181.           }
  182. >         sendMessageBlock(Constants.OPCODE_PONG, applicationData, true);
  183.       }
  184.   

java/org/apache/catalina/ha/tcp/ReplicationValve.java:409: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.sendReplicationMessage(Request,long,boolean,ClusterManager)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  407.               // DeltaManager returns String[0]
  408.               if (!(clusterManager instanceof DeltaManager)) {
  409. >                 sendInvalidSessions(clusterManager);
  410.               }
  411.               // send replication

java/org/apache/catalina/ha/tcp/ReplicationValve.java:500: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationValve.sendSessionReplicationMessage(Request,ClusterManager)` indirectly reads without synchronization from `this.cluster`. Potentially races with write in method `ReplicationValve.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  498.                       log.debug(sm.getString("ReplicationValve.invoke.uri", uri));
  499.                   }
  500. >                 sendMessage(session,manager);
  501.               } else
  502.                   if(doStatistics()) {

java/org/apache/catalina/ha/session/DeltaManager.java:1432: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.sendSessions(Member,org.apache.catalina.Session[],long)` writes to field `this.counterSend_EVT_ALL_SESSION_DATA` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1430.               log.debug(sm.getString("deltaManager.createMessage.allSessionData", getName()));
  1431.           }
  1432. >         counterSend_EVT_ALL_SESSION_DATA++;
  1433.           int sendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
  1434.           cluster.send(newmsg, sender, sendOptions);

java/org/apache/catalina/ha/session/DeltaManager.java:1434: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.sendSessions(Member,org.apache.catalina.Session[],long)` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1432.           counterSend_EVT_ALL_SESSION_DATA++;
  1433.           int sendOptions = Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK;
  1434. >         cluster.send(newmsg, sender, sendOptions);
  1435.       }
  1436.   

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:142: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.sendStreamReset(StreamException)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  140.                   TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, errorCompletion,
  141.                   ByteBuffer.wrap(rstFrame));
  142. >         handleAsyncException();
  143.       }
  144.   

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:212: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.sendStringByCompletion(String,SendHandler)` indirectly mutates container `messageParts` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  210.           TextMessageSendHandler tmsh = new TextMessageSendHandler(handler,
  211.                   CharBuffer.wrap(text), true, encoder, encoderBuffer, this);
  212. >         tmsh.write();
  213.           // TextMessageSendHandler will update stateMachine when it completes
  214.       }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:197: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `Future WsRemoteEndpointImplBase.sendStringByFuture(String)` indirectly mutates container `messageParts` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  195.       public Future<Void> sendStringByFuture(String text) {
  196.           FutureToSendHandler f2sh = new FutureToSendHandler(wsSession);
  197. >         sendStringByCompletion(text, f2sh);
  198.           return f2sh;
  199.       }

java/org/apache/jasper/servlet/JspServletWrapper.java:405: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspServletWrapper.service(HttpServletRequest,HttpServletResponse,boolean)` reads without synchronization from `this.compileException`. Potentially races with write in method `JspServletWrapper.setCompilationException(...)`.
 Reporting because this access may occur on a background thread.
  403.                   }
  404.               } else {
  405. >                 if (compileException != null) {
  406.                       // Throw cached compilation exception
  407.                       throw compileException;

java/org/apache/jasper/servlet/JspServletWrapper.java:380: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void JspServletWrapper.service(HttpServletRequest,HttpServletResponse,boolean)` reads without synchronization from `this.available`. Potentially races with write in method `JspServletWrapper.service(...)`.
 Reporting because this access may occur on a background thread.
  378.               }
  379.   
  380. >             if ((available > 0L) && (available < Long.MAX_VALUE)) {
  381.                   if (available > System.currentTimeMillis()) {
  382.                       response.setDateHeader("Retry-After", available);

java/org/apache/jasper/servlet/JspServletWrapper.java:390: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JspServletWrapper.service(HttpServletRequest,HttpServletResponse,boolean)` writes to field `this.available` outside of synchronization.
 Reporting because this access may occur on a background thread.
  388.   
  389.                   // Wait period has expired. Reset.
  390. >                 available = 0;
  391.               }
  392.   

java/org/apache/catalina/authenticator/SingleSignOn.java:323: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SingleSignOn.sessionDestroyed(String,Session)` indirectly reads without synchronization from `this.engine`. Potentially races with write in method `SingleSignOn.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  321.                           ssoId, session));
  322.               }
  323. >             removeSession(ssoId, session);
  324.           } else {
  325.               // The session was logged out.

java/org/apache/catalina/ha/session/DeltaManager.java:1087: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.sessionExpired(String)` writes to field `this.counterSend_EVT_SESSION_EXPIRED` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1085.       protected void sessionExpired(String id) {
  1086.           if(cluster.getMembers().length > 0 ) {
  1087. >             counterSend_EVT_SESSION_EXPIRED++ ;
  1088.               SessionMessage msg = new SessionMessageImpl(getName(),
  1089.                       SessionMessage.EVT_SESSION_EXPIRED, null, id, id+ "-EXPIRED-MSG");

java/org/apache/catalina/ha/session/DeltaManager.java:1086: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DeltaManager.sessionExpired(String)` reads without synchronization from `this.cluster`. Potentially races with write in method `DeltaManager.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1084.        */
  1085.       protected void sessionExpired(String id) {
  1086. >         if(cluster.getMembers().length > 0 ) {
  1087.               counterSend_EVT_SESSION_EXPIRED++ ;
  1088.               SessionMessage msg = new SessionMessageImpl(getName(),

java/org/apache/catalina/tribes/transport/ReceiverBase.java:396: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReceiverBase.setAddress(String)` writes to field `this.host` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  394.   
  395.       public void setAddress(String host) {
  396. >         this.host = host;
  397.       }
  398.       public void setHost(String host) {

java/org/apache/catalina/core/StandardContext.java:1745: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setAltDDName(String)` indirectly mutates container `this.context.attributes` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1743.           this.altDDName = altDDName;
  1744.           if (context != null) {
  1745. >             context.setAttribute(Globals.ALT_DD_ATTR,altDDName);
  1746.           }
  1747.       }

java/org/apache/catalina/core/StandardContext.java:1744: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setAltDDName(String)` reads without synchronization from `this.context`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1742.       public void setAltDDName(String altDDName) {
  1743.           this.altDDName = altDDName;
  1744. >         if (context != null) {
  1745.               context.setAttribute(Globals.ALT_DD_ATTR,altDDName);
  1746.           }

java/org/apache/catalina/core/StandardContext.java:1326: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setApplicationEventListeners(java.lang.Object[])` mutates container `this.applicationEventListenersList` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1324.       @Override
  1325.       public void setApplicationEventListeners(Object listeners[]) {
  1326. >         applicationEventListenersList.clear();
  1327.           if (listeners != null && listeners.length > 0) {
  1328.               applicationEventListenersList.addAll(Arrays.asList(listeners));

java/org/apache/catalina/core/StandardContext.java:1359: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setApplicationLifecycleListeners(java.lang.Object[])` writes to field `this.applicationLifecycleListenersObjects` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1357.       @Override
  1358.       public void setApplicationLifecycleListeners(Object listeners[]) {
  1359. >         applicationLifecycleListenersObjects = listeners;
  1360.       }
  1361.   

java/org/apache/catalina/core/ApplicationRequest.java:158: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ApplicationRequest.setAttribute(String,Object)` indirectly reads with synchronization from `this.request`. Potentially races with unsynchronized write in method `ApplicationRequest.setRequest(...)`.
 Reporting because this access may occur on a background thread.
  156.               attributes.put(name, value);
  157.               if (!isSpecial(name))
  158. >                 getRequest().setAttribute(name, value);
  159.           }
  160.   

java/org/apache/catalina/session/StandardSession.java:1376: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.setAttribute(String,Object)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1374.       @Override
  1375.       public void setAttribute(String name, Object value) {
  1376. >         setAttribute(name,value,true);
  1377.       }
  1378.   

java/org/apache/catalina/session/StandardSession.java:1431: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardSession.setAttribute(String,Object,boolean)` indirectly reads without synchronization from `this.facade`. Potentially races with write in method `StandardSession.expire(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1429.               Object oldValue = attributes.get(name);
  1430.               if (value != oldValue || manager.getNotifyBindingListenerOnUnchangedValue()) {
  1431. >                 event = new HttpSessionBindingEvent(getSession(), name, value);
  1432.                   try {
  1433.                       ((HttpSessionBindingListener) value).valueBound(event);

java/org/apache/catalina/session/StandardSession.java:1407: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.setAttribute(String,Object,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1405.           // Null value is the same as removeAttribute()
  1406.           if (value == null) {
  1407. >             removeAttribute(name);
  1408.               return;
  1409.           }

java/org/apache/catalina/ha/session/DeltaSession.java:768: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.setAttribute(String,Object,boolean,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  766.           // Null value is the same as removeAttribute()
  767.           if (value == null) {
  768. >             removeAttribute(name);
  769.               return;
  770.           }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:358: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void DigestAuthenticator.setAuthenticateHeader(HttpServletRequest,HttpServletResponse,String,boolean)` indirectly reads without synchronization from `this.opaque`. Potentially races with write in method `DigestAuthenticator.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  356.               authenticateHeader = "Digest realm=\"" + realmName + "\", " +
  357.               "qop=\"" + QOP + "\", nonce=\"" + nonce + "\", " + "opaque=\"" +
  358. >             getOpaque() + "\", stale=true";
  359.           } else {
  360.               authenticateHeader = "Digest realm=\"" + realmName + "\", " +

java/org/apache/catalina/core/StandardWrapper.java:311: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardWrapper.setAvailable(long)` reads without synchronization from `this.available`. Potentially races with write in method `StandardWrapper.load()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  309.       @Override
  310.       public void setAvailable(long available) {
  311. >         long oldAvailable = this.available;
  312.           if (available > System.currentTimeMillis())
  313.               this.available = available;

java/org/apache/catalina/core/StandardWrapper.java:313: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardWrapper.setAvailable(long)` writes to field `this.available` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  311.           long oldAvailable = this.available;
  312.           if (available > System.currentTimeMillis())
  313. >             this.available = available;
  314.           else
  315.               this.available = 0L;

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:108: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.setBatchingAllowed(boolean)` indirectly writes to field `this.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  106.   
  107.           if (oldValue && !batchingAllowed) {
  108. >             flushBatch();
  109.           }
  110.       }

java/org/apache/catalina/tribes/transport/ReceiverBase.java:276: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReceiverBase.setBind(InetAddress)` writes to field `this.bind` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  274.        */
  275.       public void setBind(java.net.InetAddress bind) {
  276. >         this.bind = bind;
  277.       }
  278.   

java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java:135: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicationTransmitter.setChannel(Channel)` writes to field `this.channel` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  133.       @Override
  134.       public void setChannel(Channel channel) {
  135. >         this.channel = channel;
  136.       }
  137.   

java/org/apache/catalina/core/StandardContext.java:1431: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setCharsetMapper(CharsetMapper)` writes to field `this.charsetMapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1429.   
  1430.           CharsetMapper oldCharsetMapper = this.charsetMapper;
  1431. >         this.charsetMapper = mapper;
  1432.           if( mapper != null )
  1433.               this.charsetMapperClass= mapper.getClass().getName();

java/org/apache/catalina/core/StandardContext.java:1433: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setCharsetMapper(CharsetMapper)` writes to field `this.charsetMapperClass` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1431.           this.charsetMapper = mapper;
  1432.           if( mapper != null )
  1433. >             this.charsetMapperClass= mapper.getClass().getName();
  1434.           support.firePropertyChange("charsetMapper", oldCharsetMapper,
  1435.                                      this.charsetMapper);

java/org/apache/catalina/core/StandardContext.java:1430: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setCharsetMapper(CharsetMapper)` reads without synchronization from `this.charsetMapper`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1428.       public void setCharsetMapper(CharsetMapper mapper) {
  1429.   
  1430. >         CharsetMapper oldCharsetMapper = this.charsetMapper;
  1431.           this.charsetMapper = mapper;
  1432.           if( mapper != null )

java/org/apache/catalina/core/StandardContext.java:2559: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setCharsetMapperClass(String)` writes to field `this.charsetMapperClass` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2557.   
  2558.           String oldCharsetMapperClass = this.charsetMapperClass;
  2559. >         this.charsetMapperClass = mapper;
  2560.           support.firePropertyChange("charsetMapperClass",
  2561.                                      oldCharsetMapperClass,

java/org/apache/catalina/core/StandardContext.java:2558: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setCharsetMapperClass(String)` reads without synchronization from `this.charsetMapperClass`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2556.       public void setCharsetMapperClass(String mapper) {
  2557.   
  2558. >         String oldCharsetMapperClass = this.charsetMapperClass;
  2559.           this.charsetMapperClass = mapper;
  2560.           support.firePropertyChange("charsetMapperClass",

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:66: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ClusterSingleSignOn.setCluster(CatalinaCluster)` writes to field `this.cluster` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  64.       @Override
  65.       public void setCluster(CatalinaCluster cluster) {
  66. >         this.cluster = cluster;
  67.       }
  68.   

java/org/apache/catalina/ha/session/JvmRouteBinderValve.java:256: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JvmRouteBinderValve.setCluster(CatalinaCluster)` writes to field `this.cluster` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  254.       @Override
  255.       public void setCluster(CatalinaCluster cluster) {
  256. >         this.cluster = cluster;
  257.       }
  258.   

java/org/apache/catalina/ha/tcp/ReplicationValve.java:141: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReplicationValve.setCluster(CatalinaCluster)` writes to field `this.cluster` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  139.       @Override
  140.       public void setCluster(CatalinaCluster cluster) {
  141. >         this.cluster = cluster;
  142.       }
  143.   

java/org/apache/catalina/valves/rewrite/RewriteValve.java:192: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.setConfiguration(String)` indirectly writes to field `conditions.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  190.           }
  191.           maps.clear();
  192. >         parse(new BufferedReader(new StringReader(configuration)));
  193.       }
  194.   

java/org/apache/catalina/valves/rewrite/RewriteValve.java:191: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RewriteValve.setConfiguration(String)` mutates container `this.maps` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  189.               containerLog = LogFactory.getLog(getContainer().getLogName() + ".rewrite");
  190.           }
  191. >         maps.clear();
  192.           parse(new BufferedReader(new StringReader(configuration)));
  193.       }

java/org/apache/catalina/core/StandardContext.java:1474: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setConfigured(boolean)` reads without synchronization from `this.configured`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1472.       public void setConfigured(boolean configured) {
  1473.   
  1474. >         boolean oldConfigured = this.configured;
  1475.           this.configured = configured;
  1476.           support.firePropertyChange("configured",

java/org/apache/catalina/core/StandardContext.java:1475: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setConfigured(boolean)` writes to field `this.configured` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1473.   
  1474.           boolean oldConfigured = this.configured;
  1475. >         this.configured = configured;
  1476.           support.firePropertyChange("configured",
  1477.                                      oldConfigured,

java/org/apache/catalina/startup/HostConfig.java:189: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.setContextClass(String)` indirectly reads with synchronization from `this.contextClass`. Potentially races with unsynchronized write in method `HostConfig.setContextClass(...)`.
 Reporting because this access may occur on a background thread.
  187.           if (!oldContextClass.equals(contextClass)) {
  188.               synchronized (digesterLock) {
  189. >                 digester = createDigester(getContextClass());
  190.               }
  191.           }

java/org/apache/catalina/startup/HostConfig.java:185: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.setContextClass(String)` writes to field `this.contextClass` outside of synchronization.
 Reporting because this access may occur on a background thread.
  183.   
  184.           String oldContextClass = this.contextClass;
  185. >         this.contextClass = contextClass;
  186.   
  187.           if (!oldContextClass.equals(contextClass)) {

java/org/apache/catalina/core/StandardContext.java:995: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setCookieProcessor(CookieProcessor)` writes to field `this.cookieProcessor` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  993.                       sm.getString("standardContext.cookieProcessor.null"));
  994.           }
  995. >         this.cookieProcessor = cookieProcessor;
  996.       }
  997.   

java/org/apache/catalina/startup/ContextConfig.java:264: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.setDefaultWebXml(String)` writes to field `this.defaultWebXml` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  262.        */
  263.       public void setDefaultWebXml(String path) {
  264. >         this.defaultWebXml = path;
  265.       }
  266.   

java/org/apache/tomcat/util/modeler/NotificationInfo.java:57: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NotificationInfo.setDescription(String)` writes to field `this.info` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  55.       public void setDescription(String description) {
  56.           super.setDescription(description);
  57. >         this.info = null;
  58.       }
  59.   

java/org/apache/catalina/core/StandardContext.java:1781: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setDistributable(boolean)` writes to field `this.distributable` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1779.       public void setDistributable(boolean distributable) {
  1780.           boolean oldDistributable = this.distributable;
  1781. >         this.distributable = distributable;
  1782.           support.firePropertyChange("distributable",
  1783.                                      oldDistributable,

java/org/apache/catalina/core/StandardContext.java:1780: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setDistributable(boolean)` reads without synchronization from `this.distributable`. Potentially races with write in method `StandardContext.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1778.       @Override
  1779.       public void setDistributable(boolean distributable) {
  1780. >         boolean oldDistributable = this.distributable;
  1781.           this.distributable = distributable;
  1782.           support.firePropertyChange("distributable",

java/org/apache/catalina/core/AsyncContextImpl.java:416: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.setErrorState(Throwable,boolean)` reads without synchronization from `this.event`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  414.                   log.debug(sm.getString("asyncContextImpl.fireOnError"));
  415.               }
  416. >             AsyncEvent errorEvent = new AsyncEvent(event.getAsyncContext(),
  417.                       event.getSuppliedRequest(), event.getSuppliedResponse(), t);
  418.               List<AsyncListenerWrapper> listenersCopy = new ArrayList<>();

java/org/apache/catalina/core/AsyncContextImpl.java:449: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.setErrorState(Throwable,boolean)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  447.               Valve stdHostValve = host.getPipeline().getBasic();
  448.               if (stdHostValve instanceof StandardHostValve) {
  449. >                 ((StandardHostValve) stdHostValve).throwable(request,
  450.                           request.getResponse(), t);
  451.               }

java/org/apache/catalina/core/AsyncContextImpl.java:446: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.setErrorState(Throwable,boolean)` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  444.               }
  445.   
  446. >             Host host = (Host) context.getParent();
  447.               Valve stdHostValve = host.getPipeline().getBasic();
  448.               if (stdHostValve instanceof StandardHostValve) {

java/org/apache/catalina/core/AsyncContextImpl.java:409: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.setErrorState(Throwable,boolean)` indirectly writes to field `this.request.applicationRequest` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  407.   
  408.       public void setErrorState(Throwable t, boolean fireOnError) {
  409. >         if (t!=null) request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
  410.           request.getCoyoteRequest().action(ActionCode.ASYNC_ERROR, null);
  411.   

java/org/apache/coyote/AbstractProcessor.java:117: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.setErrorState(ErrorState,Throwable)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  115.           if (blockIo && isAsync() && setError) {
  116.               if (asyncStateMachine.asyncError()) {
  117. >                 processSocketEvent(SocketEvent.ERROR, true);
  118.               }
  119.           }

java/org/apache/catalina/core/AprLifecycleListener.java:391: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprLifecycleListener.setFIPSMode(String)` reads without synchronization from `core.AprLifecycleListener.sslInitialized`. Potentially races with write in method `AprLifecycleListener.lifecycleEvent(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  389.           if (!FIPSMode.equals(AprLifecycleListener.FIPSMode)) {
  390.               // Ensure that the FIPS mode is consistent with that used for SSL init
  391. >             if (sslInitialized) {
  392.                   throw new IllegalStateException(
  393.                           sm.getString("aprListener.tooLateForFIPSMode"));

java/org/apache/catalina/valves/AccessLogValve.java:334: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AccessLogValve.setFileDateFormat(String)` writes to field `this.fileDateFormat` outside of synchronization.
 Reporting because this access may occur on a background thread.
  332.               newFormat = fileDateFormat;
  333.           }
  334. >         this.fileDateFormat = newFormat;
  335.   
  336.           synchronized (this) {

java/org/apache/catalina/tribes/transport/ReceiverBase.java:399: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReceiverBase.setHost(String)` indirectly writes to field `this.host` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  397.       }
  398.       public void setHost(String host) {
  399. >         setAddress(host);
  400.       }
  401.   

java/org/apache/catalina/ha/session/DeltaSession.java:327: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.setId(String)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  325.       @Override
  326.       public void setId(String id) {
  327. >         super.setId(id, true);
  328.           resetDeltaRequest();
  329.       }

java/org/apache/catalina/session/StandardSession.java:341: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.setId(String)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  339.       @Override
  340.       public void setId(String id) {
  341. >         setId(id, true);
  342.       }
  343.   

java/org/apache/catalina/ha/session/DeltaSession.java:314: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaSession.setId(String,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  312.       @Override
  313.       public void setId(String id, boolean notify) {
  314. >         super.setId(id, notify);
  315.           resetDeltaRequest();
  316.       }

java/org/apache/catalina/session/StandardSession.java:360: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.setId(String,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  358.   
  359.           if (notify) {
  360. >             tellNew();
  361.           }
  362.       }

java/org/apache/catalina/core/StandardContext.java:1190: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setInstanceManager(InstanceManager)` writes to field `this.instanceManager` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1188.       @Override
  1189.       public void setInstanceManager(InstanceManager instanceManager) {
  1190. >        this.instanceManager = instanceManager;
  1191.       }
  1192.   

java/org/apache/catalina/core/StandardContext.java:1178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setJarScanner(JarScanner)` writes to field `this.jarScanner` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1176.       @Override
  1177.       public void setJarScanner(JarScanner jarScanner) {
  1178. >         this.jarScanner = jarScanner;
  1179.       }
  1180.   

java/org/apache/catalina/core/StandardContext.java:2506: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setJspConfigDescriptor(JspConfigDescriptor)` writes to field `this.jspConfigDescriptor` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2504.       @Override
  2505.       public void setJspConfigDescriptor(JspConfigDescriptor descriptor) {
  2506. >         this.jspConfigDescriptor = descriptor;
  2507.       }
  2508.   

java/org/apache/catalina/authenticator/DigestAuthenticator.java:149: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DigestAuthenticator.setKey(String)` writes to field `this.key` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  147.   
  148.       public void setKey(String key) {
  149. >         this.key = key;
  150.       }
  151.   

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:2068: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.setLogWriter(PrintWriter)` indirectly reads without synchronization from `this.closed`. Potentially races with write in method `BasicDataSource.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2066.       @Override
  2067.       public void setLogWriter(final PrintWriter logWriter) throws SQLException {
  2068. >         createDataSource().setLogWriter(logWriter);
  2069.           this.logWriter = logWriter;
  2070.       }

java/org/apache/catalina/core/StandardWrapper.java:1476: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardWrapper.setMultipartConfigElement(MultipartConfigElement)` writes to field `this.multipartConfigElement` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1474.       public void setMultipartConfigElement(
  1475.               MultipartConfigElement multipartConfigElement) {
  1476. >         this.multipartConfigElement = multipartConfigElement;
  1477.       }
  1478.   

java/org/apache/tomcat/util/modeler/NotificationInfo.java:69: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NotificationInfo.setName(String)` writes to field `this.info` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  67.       public void setName(String name) {
  68.           super.setName(name);
  69. >         this.info = null;
  70.       }
  71.   

java/org/apache/catalina/core/StandardContext.java:5871: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setNamingContextListener(NamingContextListener)` writes to field `this.namingContextListener` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5869.        */
  5870.       public void setNamingContextListener(NamingContextListener namingContextListener) {
  5871. >         this.namingContextListener = namingContextListener;
  5872.       }
  5873.   

java/org/apache/catalina/core/StandardContext.java:2029: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setNamingResources(NamingResourcesImpl)` writes to field `this.namingResources` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2027.           // Process the property setting change
  2028.           NamingResourcesImpl oldNamingResources = this.namingResources;
  2029. >         this.namingResources = namingResources;
  2030.           if (namingResources != null) {
  2031.               namingResources.setContainer(this);

java/org/apache/catalina/core/StandardContext.java:2028: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setNamingResources(NamingResourcesImpl)` reads without synchronization from `this.namingResources`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2026.   
  2027.           // Process the property setting change
  2028. >         NamingResourcesImpl oldNamingResources = this.namingResources;
  2029.           this.namingResources = namingResources;
  2030.           if (namingResources != null) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:169: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DigestAuthenticator.setOpaque(String)` writes to field `this.opaque` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  167.   
  168.       public void setOpaque(String opaque) {
  169. >         this.opaque = opaque;
  170.       }
  171.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:176: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardJarScanFilter.setPluggabilityScan(String)` writes to field `this.pluggabilityScan` outside of synchronization.
 Reporting because this access may occur on a background thread.
  174.   
  175.       public void setPluggabilityScan(String pluggabilityScan) {
  176. >         this.pluggabilityScan = pluggabilityScan;
  177.           Lock writeLock = configurationLock.writeLock();
  178.           writeLock.lock();

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:159: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardJarScanFilter.setPluggabilitySkip(String)` writes to field `this.pluggabilitySkip` outside of synchronization.
 Reporting because this access may occur on a background thread.
  157.   
  158.       public void setPluggabilitySkip(String pluggabilitySkip) {
  159. >         this.pluggabilitySkip = pluggabilitySkip;
  160.           Lock writeLock = configurationLock.writeLock();
  161.           writeLock.lock();

java/org/apache/catalina/tribes/transport/ReceiverBase.java:411: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ReceiverBase.setPort(int)` writes to field `this.port` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  409.   
  410.       public void setPort(int port) {
  411. >         this.port = port;
  412.       }
  413.   

java/org/apache/catalina/storeconfig/StoreLoader.java:95: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StoreLoader.setRegistry(StoreRegistry)` writes to field `this.registry` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  93.        */
  94.       public void setRegistry(StoreRegistry registry) {
  95. >         this.registry = registry;
  96.       }
  97.   

java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsDigesterSource.java:135: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MbeansDescriptorsDigesterSource.setRegistry(Registry)` writes to field `this.registry` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  133.   
  134.       public void setRegistry(Registry reg) {
  135. >         this.registry=reg;
  136.       }
  137.   

java/org/apache/catalina/core/StandardContext.java:2266: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.setReplaceWelcomeFiles(boolean)` reads without synchronization from `this.replaceWelcomeFiles`. Potentially races with write in method `StandardContext.addWelcomeFile(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2264.       public void setReplaceWelcomeFiles(boolean replaceWelcomeFiles) {
  2265.   
  2266. >         boolean oldReplaceWelcomeFiles = this.replaceWelcomeFiles;
  2267.           this.replaceWelcomeFiles = replaceWelcomeFiles;
  2268.           support.firePropertyChange("replaceWelcomeFiles",

java/org/apache/catalina/core/StandardContext.java:2267: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setReplaceWelcomeFiles(boolean)` writes to field `this.replaceWelcomeFiles` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2265.   
  2266.           boolean oldReplaceWelcomeFiles = this.replaceWelcomeFiles;
  2267. >         this.replaceWelcomeFiles = replaceWelcomeFiles;
  2268.           support.firePropertyChange("replaceWelcomeFiles",
  2269.                                      oldReplaceWelcomeFiles,

java/org/apache/catalina/core/ApplicationRequest.java:175: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ApplicationRequest.setRequest(ServletRequest)` indirectly writes to field `this.request` outside of synchronization.
 Reporting because this access may occur on a background thread.
  173.       public void setRequest(ServletRequest request) {
  174.   
  175. >         super.setRequest(request);
  176.   
  177.           // Initialize the attributes for this request

java/org/apache/catalina/core/AprLifecycleListener.java:359: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprLifecycleListener.setSSLEngine(String)` reads without synchronization from `core.AprLifecycleListener.sslInitialized`. Potentially races with write in method `AprLifecycleListener.lifecycleEvent(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  357.           if (!SSLEngine.equals(AprLifecycleListener.SSLEngine)) {
  358.               // Ensure that the SSLEngine is consistent with that used for SSL init
  359. >             if (sslInitialized) {
  360.                   throw new IllegalStateException(
  361.                           sm.getString("aprListener.tooLateForSSLEngine"));

java/org/apache/catalina/core/AprLifecycleListener.java:375: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AprLifecycleListener.setSSLRandomSeed(String)` reads without synchronization from `core.AprLifecycleListener.sslInitialized`. Potentially races with write in method `AprLifecycleListener.lifecycleEvent(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  373.           if (!SSLRandomSeed.equals(AprLifecycleListener.SSLRandomSeed)) {
  374.               // Ensure that the random seed is consistent with that used for SSL init
  375. >             if (sslInitialized) {
  376.                   throw new IllegalStateException(
  377.                           sm.getString("aprListener.tooLateForSSLRandomSeed"));

java/org/apache/catalina/session/ManagerBase.java:900: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagerBase.setSessionCounter(long)` writes to field `this.sessionCounter` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  898.       @Override
  899.       public void setSessionCounter(long sessionCounter) {
  900. >         this.sessionCounter = sessionCounter;
  901.       }
  902.   

java/org/apache/catalina/core/StandardContext.java:1694: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setStartupTime(long)` writes to field `this.startupTime` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1692.   
  1693.       public void setStartupTime(long startupTime) {
  1694. >         this.startupTime = startupTime;
  1695.       }
  1696.   

java/org/apache/tomcat/dbcp/dbcp2/PoolingConnection.java:578: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PoolingConnection.setStatementPool(KeyedObjectPool)` writes to field `this.pstmtPool` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  576.        */
  577.       public void setStatementPool(final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool) {
  578. >         pstmtPool = pool;
  579.       }
  580.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:126: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardJarScanFilter.setTldScan(String)` writes to field `this.tldScan` outside of synchronization.
 Reporting because this access may occur on a background thread.
  124.   
  125.       public void setTldScan(String tldScan) {
  126. >         this.tldScan = tldScan;
  127.           Lock writeLock = configurationLock.writeLock();
  128.           writeLock.lock();

java/org/apache/catalina/core/StandardContext.java:1702: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setTldScanTime(long)` writes to field `this.tldScanTime` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1700.   
  1701.       public void setTldScanTime(long tldScanTime) {
  1702. >         this.tldScanTime = tldScanTime;
  1703.       }
  1704.   

java/org/apache/tomcat/util/scan/StandardJarScanFilter.java:109: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardJarScanFilter.setTldSkip(String)` writes to field `this.tldSkip` outside of synchronization.
 Reporting because this access may occur on a background thread.
  107.   
  108.       public void setTldSkip(String tldSkip) {
  109. >         this.tldSkip = tldSkip;
  110.           Lock writeLock = configurationLock.writeLock();
  111.           writeLock.lock();

java/org/apache/catalina/core/StandardContext.java:1307: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setUseNaming(boolean)` writes to field `this.useNaming` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1305.        */
  1306.       public void setUseNaming(boolean useNaming) {
  1307. >         this.useNaming = useNaming;
  1308.       }
  1309.   

java/org/apache/catalina/tribes/group/GroupChannel.java:550: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GroupChannel.setUtilityExecutor(ScheduledExecutorService)` writes to field `this.utilityExecutor` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  548.       @Override
  549.       public void setUtilityExecutor(ScheduledExecutorService utilityExecutor) {
  550. >         this.utilityExecutor = utilityExecutor;
  551.       }
  552.   

java/org/apache/catalina/core/StandardContext.java:2607: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.setWorkDir(String)` indirectly writes to field `chars.[_]` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2605.   
  2606.           if (getState().isAvailable()) {
  2607. >             postWorkDirectory();
  2608.           }
  2609.       }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1575: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.setting(Setting,long)` reads without synchronization from container `this.streams` via call to `values`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1573.               remoteSettings.set(setting, value);
  1574.               int diff = (int) (value - oldValue);
  1575. >             for (Stream stream : streams.values()) {
  1576.                   try {
  1577.                       stream.incrementWindowSize(diff);

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:265: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.settingsEnd(boolean)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  263.                       ByteBuffer.wrap(SETTINGS_ACK));
  264.           }
  265. >         handleAsyncException();
  266.       }
  267.   

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:68: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `org.apache.catalina.tribes.transport.bio.BioSender[] MultipointBioSender.setupForSend(org.apache.catalina.tribes.Member[])` mutates container `this.bioSenders` via call to `put` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  66.                       AbstractSender.transferProperties(this,sender);
  67.                       sender.setDestination(destination[i]);
  68. >                     bioSenders.put(destination[i], sender);
  69.                   }
  70.                   result[i] = sender;

java/org/apache/catalina/tribes/transport/bio/MultipointBioSender.java:63: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `org.apache.catalina.tribes.transport.bio.BioSender[] MultipointBioSender.setupForSend(org.apache.catalina.tribes.Member[])` reads without synchronization from container `this.bioSenders` via call to `get`. Potentially races with write in method `MultipointBioSender.sendMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  61.           for ( int i=0; i<destination.length; i++ ) {
  62.               try {
  63. >                 BioSender sender = bioSenders.get(destination[i]);
  64.                   if (sender == null) {
  65.                       sender = new BioSender();

webapps/examples/WEB-INF/classes/websocket/drawboard/Room.java:394: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void Room.shutdown()` indirectly writes to field `this.cachedRunnables` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  392.        */
  393.       public void shutdown() {
  394. >         invokeAndWait(new Runnable() {
  395.               @Override
  396.               public void run() {

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/FairBlockingQueue.java:238: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int FairBlockingQueue.size()` reads without synchronization from container `this.items` via call to `size`. Potentially races with write in method `FairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  236.       @Override
  237.       public int size() {
  238. >         return items.size();
  239.       }
  240.   

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/MultiLockFairBlockingQueue.java:235: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `int MultiLockFairBlockingQueue.size()` reads without synchronization from container `this.items.[_]` via call to `size`. Potentially races with write in method `MultiLockFairBlockingQueue.remove(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  233.           int size = 0;
  234.           for (int idx=0; idx<LOCK_COUNT; idx++) {
  235. >             size += items[idx].size();
  236.           }
  237.           return size;

java/org/apache/catalina/startup/HostConfig.java:1576: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void HostConfig.start()` indirectly reads without synchronization from container `this.deployed` via call to `get`. Potentially races with write in method `HostConfig.deployDescriptor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1574.   
  1575.           if (host.getDeployOnStartup())
  1576. >             deployApps();
  1577.   
  1578.       }

java/org/apache/catalina/tribes/transport/ReplicationTransmitter.java:78: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ReplicationTransmitter.start()` reads without synchronization from `this.channel`. Potentially races with write in method `ReplicationTransmitter.stop()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  76.           getTransport().connect();
  77.           // register jmx
  78. >         JmxRegistry jmxRegistry = JmxRegistry.getRegistry(channel);
  79.           if (jmxRegistry != null) this.oname = jmxRegistry.registerJmx(",component=Sender", transport);
  80.       }

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:224: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MessageDispatchInterceptor.start(int)` indirectly reads with synchronization from `this.channel`. Potentially races with unsynchronized write in method `MessageDispatchInterceptor.stop(...)`.
 Reporting because this access may occur on a background thread.
  222.                   // only start with the sender
  223.                   if ( !run && ((svc & Channel.SND_TX_SEQ)==Channel.SND_TX_SEQ) ) {
  224. >                     startQueue();
  225.                   }
  226.               }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:466: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.start(int)` reads without synchronization from `this.membership`. Potentially races with write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  464.       @Override
  465.       public void start(int svc) throws ChannelException {
  466. >             if (membership == null) setupMembership();
  467.               if (started)return;
  468.               fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:469: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.start(int)` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `NonBlockingCoordinator.stop(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  467.               if (started)return;
  468.               fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "Before start"));
  469. >             super.start(startsvc);
  470.               started = true;
  471.               if (view == null) view = new Membership(super.getLocalMember(true), AbsoluteOrder.comp, true);

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:473: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.start(int)` indirectly reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  471.               if (view == null) view = new Membership(super.getLocalMember(true), AbsoluteOrder.comp, true);
  472.               fireInterceptorEvent(new CoordinationEvent(CoordinationEvent.EVT_START, this, "After start"));
  473. >             startElection(false);
  474.       }
  475.   

java/org/apache/catalina/tribes/group/interceptors/StaticMembershipInterceptor.java:161: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StaticMembershipInterceptor.start(int)` reads without synchronization from container `this.members` via call to `iterator`. Potentially races with write in method `StaticMembershipInterceptor.addStaticMember(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  159.           final ChannelInterceptorBase base = this;
  160.           ScheduledExecutorService executor = getChannel().getUtilityExecutor();
  161. >         for (final Member member : members) {
  162.               Runnable r = new Runnable() {
  163.                   @Override

java/org/apache/catalina/core/AsyncContextImpl.java:250: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AsyncContextImpl.start(Runnable)` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  248.           }
  249.           check();
  250. >         Runnable wrapper = new RunnableWrapper(run, context, this.request.getCoyoteRequest());
  251.           this.request.getCoyoteRequest().action(ActionCode.ASYNC_RUN, wrapper);
  252.       }

java/org/apache/catalina/core/AsyncContextImpl.java:247: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AsyncContextImpl.start(Runnable)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  245.       public void start(final Runnable run) {
  246.           if (log.isDebugEnabled()) {
  247. >             logDebug("start      ");
  248.           }
  249.           check();

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:202: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.startElection(boolean)` indirectly reads with synchronization from `this.viewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because this access may occur on a background thread.
  200.                   this.viewId = new UniqueId(UUIDGenerator.randomUUID(false));
  201.                   this.view = new Membership(local,AbsoluteOrder.comp, true);
  202. >                 this.handleViewConf(createElectionMsg(local,others,local), view);
  203.                   return; //the only member, no need for an election
  204.               }

java/org/apache/catalina/tribes/group/interceptors/NonBlockingCoordinator.java:205: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NonBlockingCoordinator.startElection(boolean)` reads with synchronization from `this.suggestedviewId`. Potentially races with unsynchronized write in method `NonBlockingCoordinator.processCoordMessage(...)`.
 Reporting because this access may occur on a background thread.
  203.                   return; //the only member, no need for an election
  204.               }
  205. >             if ( suggestedviewId != null ) {
  206.   
  207.                   if ( view != null && Arrays.diff(view,suggestedView,local).length == 0 &&  Arrays.diff(suggestedView,view,local).length == 0) {

java/org/apache/catalina/tribes/group/GroupChannel.java:492: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GroupChannel.startHeartbeat()` reads without synchronization from `this.heartbeatFuture`. Potentially races with write in method `GroupChannel.stop(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  490.   
  491.       protected void startHeartbeat() {
  492. >         if (heartbeat && (heartbeatFuture == null || (heartbeatFuture != null && heartbeatFuture.isDone()))) {
  493.               if (heartbeatFuture != null && heartbeatFuture.isDone()) {
  494.                   // There was an error executing the scheduled task, get it and log it

java/org/apache/catalina/tribes/group/GroupChannel.java:501: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void GroupChannel.startHeartbeat()` writes to field `this.heartbeatFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  499.                   }
  500.               }
  501. >             heartbeatFuture = utilityExecutor.scheduleWithFixedDelay(new HeartbeatRunnable(),
  502.                       heartbeatSleeptime, heartbeatSleeptime, TimeUnit.MILLISECONDS);
  503.           }

java/org/apache/catalina/core/StandardContext.java:5172: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.startInternal()` indirectly reads with synchronization from `this.logName`. Potentially races with unsynchronized write in method `StandardContext.filterStop()`.
 Reporting because this access may occur on a background thread.
  5170.               // Configure and call application filters
  5171.               if (ok) {
  5172. >                 if (!filterStart()) {
  5173.                       log.error(sm.getString("standardContext.filterFail"));
  5174.                       ok = false;

java/org/apache/catalina/core/StandardContext.java:5156: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.startInternal()` indirectly reads with synchronization from `patterns.[_]`. Potentially races with unsynchronized write in method `StandardContext.addConstraint(...)`.
 Reporting because this access may occur on a background thread.
  5154.               // change constraints
  5155.               if (ok) {
  5156. >                 checkConstraintsForUncoveredMethods(findConstraints());
  5157.               }
  5158.   

java/org/apache/catalina/core/StandardContext.java:5025: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.startInternal()` indirectly reads with synchronization from `this.logger`. Potentially races with unsynchronized write in method `StandardContext.filterStop()`.
 Reporting because this access may occur on a background thread.
  5023.                   // too early, so it should be reset.
  5024.                   logger = null;
  5025. >                 getLogger();
  5026.   
  5027.                   Realm realm = getRealmInternal();

java/org/apache/catalina/core/StandardServer.java:935: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardServer.startInternal()` writes to field `this.monitorFuture` outside of synchronization.
 Reporting because this access may occur on a background thread.
  933.   
  934.           if (periodicEventDelay > 0) {
  935. >             monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
  936.                       new Runnable() {
  937.                           @Override

java/org/apache/catalina/core/StandardServer.java:934: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.startInternal()` reads without synchronization from `this.periodicEventDelay`. Potentially races with write in method `StandardServer.setPeriodicEventDelay(...)`.
 Reporting because this access may occur on a background thread.
  932.           }
  933.   
  934. >         if (periodicEventDelay > 0) {
  935.               monitorFuture = getUtilityExecutor().scheduleWithFixedDelay(
  936.                       new Runnable() {

java/org/apache/catalina/core/StandardServer.java:925: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.startInternal()` reads without synchronization from `this.globalNamingResources`. Potentially races with write in method `StandardServer.setGlobalNamingResources(...)`.
 Reporting because this access may occur on a background thread.
  923.           setState(LifecycleState.STARTING);
  924.   
  925. >         globalNamingResources.start();
  926.   
  927.           // Start our defined Services

java/org/apache/catalina/core/StandardService.java:415: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.startInternal()` reads without synchronization from `this.name`. Potentially races with write in method `StandardService.setName(...)`.
 Reporting because this access may occur on a background thread.
  413.   
  414.           if(log.isInfoEnabled())
  415. >             log.info(sm.getString("standardService.start.name", this.name));
  416.           setState(LifecycleState.STARTING);
  417.   

java/org/apache/catalina/core/StandardService.java:419: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.startInternal()` reads without synchronization from `this.engine`. Potentially races with write in method `StandardService.setContainer(...)`.
 Reporting because this access may occur on a background thread.
  417.   
  418.           // Start our defined Container first
  419. >         if (engine != null) {
  420.               synchronized (engine) {
  421.                   engine.start();

java/org/apache/catalina/realm/JDBCRealm.java:715: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCRealm.startInternal()` indirectly writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  713.           // startup in case the database is temporarily unavailable
  714.           try {
  715. >             open();
  716.           } catch (SQLException e) {
  717.               containerLog.error(sm.getString("jdbcRealm.open"), e);

java/org/apache/catalina/realm/MemoryRealm.java:252: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryRealm.startInternal()` indirectly reads with synchronization from `digester.configured`. Potentially races with unsynchronized write in method `MemoryRealm.startInternal()`.
 Reporting because this access may occur on a background thread.
  250.                   synchronized (digester) {
  251.                       digester.push(this);
  252. >                     digester.parse(is);
  253.                   }
  254.               } catch (Exception e) {

java/org/apache/catalina/realm/MemoryRealm.java:263: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MemoryRealm.startInternal()` indirectly writes to field `this.credentialHandler` outside of synchronization.
 Reporting because this access may occur on a background thread.
  261.           }
  262.   
  263. >         super.startInternal();
  264.       }
  265.   }

java/org/apache/catalina/realm/MemoryRealm.java:241: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryRealm.startInternal()` indirectly reads without synchronization from `this.pathname`. Potentially races with write in method `MemoryRealm.setPathname(...)`.
 Reporting because this access may occur on a background thread.
  239.       @Override
  240.       protected void startInternal() throws LifecycleException {
  241. >         String pathName = getPathname();
  242.           try (InputStream is = ConfigFileLoader.getSource().getResource(pathName).getInputStream()) {
  243.               // Load the contents of the database file

java/org/apache/catalina/realm/MemoryRealm.java:251: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MemoryRealm.startInternal()` indirectly reads with synchronization from container `digester.stack` via call to `size`. Potentially races with unsynchronized write in method `MemoryRealm.startInternal()`.
 Reporting because this access may occur on a background thread.
  249.               try {
  250.                   synchronized (digester) {
  251. >                     digester.push(this);
  252.                       digester.parse(is);
  253.                   }

java/org/apache/catalina/realm/MemoryRealm.java:257: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MemoryRealm.startInternal()` indirectly writes to field `digester.configured` outside of synchronization.
 Reporting because this access may occur on a background thread.
  255.                   throw new LifecycleException(sm.getString("memoryRealm.readXml"), e);
  256.               } finally {
  257. >                 digester.reset();
  258.               }
  259.           } catch (IOException ioe) {

java/org/apache/catalina/valves/AccessLogValve.java:678: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AccessLogValve.startInternal()` indirectly reads with synchronization from `this.fileDateFormat`. Potentially races with unsynchronized write in method `AccessLogValve.setFileDateFormat(...)`.
 Reporting because this access may occur on a background thread.
  676.   
  677.           // Initialize the Date formatters
  678. >         String format = getFileDateFormat();
  679.           fileDateFormatter = new SimpleDateFormat(format, Locale.US);
  680.           fileDateFormatter.setTimeZone(TimeZone.getDefault());

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:386: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.startMessage(byte,ByteBuffer,boolean,SendHandler)` indirectly reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.setBatchingAllowed(...)`.
 Reporting because this access may occur on a background thread.
  384.               // deadlock between messagePartLock and writeLock in
  385.               // o.a.coyote.http11.upgrade.AbstractServletOutputStream
  386. >             writeMessagePart(mp);
  387.           }
  388.       }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:334: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.startMessage(byte,ByteBuffer,boolean,SendHandler)` reads without synchronization from `this.wsSession`. Potentially races with write in method `WsRemoteEndpointImplBase.setSession(...)`.
 Reporting because this access may occur on a background thread.
  332.               SendHandler handler) {
  333.   
  334. >         wsSession.updateLastActive();
  335.   
  336.           List<MessagePart> messageParts = new ArrayList<>();

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:351: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.startMessage(byte,ByteBuffer,boolean,SendHandler)` reads without synchronization from container `messageParts` via call to `size`. Potentially races with write in method `WsRemoteEndpointImplBase.sendStringByCompletion(...)`.
 Reporting because this access may occur on a background thread.
  349.           // that no message parts will be returned. If this is the case the
  350.           // trigger the supplied SendHandler
  351. >         if (messageParts.size() == 0) {
  352.               handler.onResult(new SendResult());
  353.               return;

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:356: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.startMessage(byte,ByteBuffer,boolean,SendHandler)` mutates container `messageParts` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  354.           }
  355.   
  356. >         MessagePart mp = messageParts.remove(0);
  357.   
  358.           boolean doWrite = false;

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:342: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.startMessage(byte,ByteBuffer,boolean,SendHandler)` reads without synchronization from `this.transformation`. Potentially races with write in method `WsRemoteEndpointImplBase.setTransformation(...)`.
 Reporting because this access may occur on a background thread.
  340.   
  341.           try {
  342. >             messageParts = transformation.sendMessagePart(messageParts);
  343.           } catch (IOException ioe) {
  344.               handler.onResult(new SendResult(ioe));

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:2440: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BasicDataSource.startPoolMaintenance()` reads without synchronization from `this.timeBetweenEvictionRunsMillis`. Potentially races with write in method `BasicDataSource.setTimeBetweenEvictionRunsMillis(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  2438.        */
  2439.       protected void startPoolMaintenance() {
  2440. >         if (connectionPool != null && timeBetweenEvictionRunsMillis > 0) {
  2441.               connectionPool.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
  2442.           }

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:117: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MessageDispatchInterceptor.startQueue()` writes to field `this.executor` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  115.           String channelName = "";
  116.           if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
  117. >         executor = ExecutorFactory.newThreadPool(maxSpareThreads, maxThreads, keepAliveTime,
  118.                   TimeUnit.MILLISECONDS,
  119.                   new TcclThreadFactory("MessageDispatchInterceptor.MessageDispatchThread" + channelName));

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:116: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MessageDispatchInterceptor.startQueue()` indirectly reads without synchronization from `this.channel`. Potentially races with write in method `MessageDispatchInterceptor.stop(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  114.           }
  115.           String channelName = "";
  116. >         if (getChannel().getName() != null) channelName = "[" + getChannel().getName() + "]";
  117.           executor = ExecutorFactory.newThreadPool(maxSpareThreads, maxThreads, keepAliveTime,
  118.                   TimeUnit.MILLISECONDS,

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:39: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ByteBuffer Http2AsyncUpgradeHandler.startRequestBodyFrame(int,int,boolean)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  37.   import org.apache.tomcat.util.net.SocketWrapperBase.BlockingMode;
  38.   
  39. > public class Http2AsyncUpgradeHandler extends Http2UpgradeHandler {
  40.   
  41.       private static final ByteBuffer[] BYTEBUFFER_ARRAY = new ByteBuffer[0];

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1398: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `ByteBuffer Http2UpgradeHandler.startRequestBodyFrame(int,int,boolean)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1396.           }
  1397.   
  1398. >         Stream stream = getStream(streamId, true);
  1399.           stream.checkState(FrameType.DATA);
  1400.           stream.receivedData(payloadSize);

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1400: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `ByteBuffer Http2UpgradeHandler.startRequestBodyFrame(int,int,boolean)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1398.           Stream stream = getStream(streamId, true);
  1399.           stream.checkState(FrameType.DATA);
  1400. >         stream.receivedData(payloadSize);
  1401.           return stream.getInputByteBuffer();
  1402.       }

webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java:96: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void SnakeTimer.startTimer()` writes to field `snake.SnakeTimer.gameTimer` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  94.   
  95.       public static void startTimer() {
  96. >         gameTimer = new Timer(SnakeTimer.class.getSimpleName() + " Timer");
  97.           gameTimer.scheduleAtFixedRate(new TimerTask() {
  98.               @Override

webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java:97: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SnakeTimer.startTimer()` reads without synchronization from `snake.SnakeTimer.gameTimer`. Potentially races with write in method `SnakeTimer.addSnake(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  95.       public static void startTimer() {
  96.           gameTimer = new Timer(SnakeTimer.class.getSimpleName() + " Timer");
  97. >         gameTimer.scheduleAtFixedRate(new TimerTask() {
  98.               @Override
  99.               public void run() {

java/org/apache/catalina/loader/WebappClassLoaderBase.java:1559: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WebappClassLoaderBase.stop()` mutates container `this.resourceEntries` via call to `clear` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1557.           state = LifecycleState.STOPPING;
  1558.   
  1559. >         resourceEntries.clear();
  1560.           jarModificationTimes.clear();
  1561.           resources = null;

java/org/apache/catalina/loader/WebappClassLoaderBase.java:1555: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WebappClassLoaderBase.stop()` indirectly reads without synchronization from container `this.resourceEntries` via call to `containsKey`. Potentially races with write in method `WebappClassLoaderBase.findClassInternal(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1553.           // Clearing references should be done before setting started to
  1554.           // false, due to possible side effects
  1555. >         clearReferences();
  1556.   
  1557.           state = LifecycleState.STOPPING;

java/org/apache/catalina/tribes/transport/RxTaskPool.java:131: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void RxTaskPool.stop()` indirectly reads with synchronization from `this.running`. Potentially races with unsynchronized write in method `RxTaskPool.stop()`.
 Reporting because this access may occur on a background thread.
  129.               while ( i.hasNext() ) {
  130.                   AbstractRxTask worker = i.next();
  131. >                 returnWorker(worker);
  132.                   i.remove();
  133.               }

java/org/apache/catalina/tribes/transport/RxTaskPool.java:126: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void RxTaskPool.stop()` writes to field `this.running` outside of synchronization.
 Reporting because this access may occur on a background thread.
  124.   
  125.       public void stop() {
  126. >         running = false;
  127.           synchronized (mutex) {
  128.               Iterator<AbstractRxTask> i = idle.iterator();

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:243: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void MessageDispatchInterceptor.stop(int)` indirectly writes to field `this.channel` outside of synchronization.
 Reporting because this access may occur on a background thread.
  241.           }
  242.   
  243. >         super.stop(svc);
  244.       }
  245.   

java/org/apache/catalina/core/StandardContext.java:5388: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.stopInternal()` indirectly reads with synchronization from `this.logName`. Potentially races with unsynchronized write in method `StandardContext.filterStop()`.
 Reporting because this access may occur on a background thread.
  5386.   
  5387.               // Stop our filters
  5388. >             filterStop();
  5389.   
  5390.               Manager manager = getManager();

java/org/apache/catalina/core/StandardServer.java:979: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.stopInternal()` reads without synchronization from `this.monitorFuture`. Potentially races with write in method `StandardServer.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  977.           setState(LifecycleState.STOPPING);
  978.   
  979. >         if (monitorFuture != null) {
  980.               monitorFuture.cancel(true);
  981.               monitorFuture = null;

java/org/apache/catalina/core/StandardServer.java:991: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardServer.stopInternal()` reads without synchronization from `this.services`. Potentially races with write in method `StandardServer.addService(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  989.   
  990.           // Stop our defined Services
  991. >         for (int i = 0; i < services.length; i++) {
  992.               services[i].stop();
  993.           }

java/org/apache/catalina/core/StandardServer.java:981: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardServer.stopInternal()` writes to field `this.monitorFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  979.           if (monitorFuture != null) {
  980.               monitorFuture.cancel(true);
  981. >             monitorFuture = null;
  982.           }
  983.           if (periodicLifecycleEventFuture != null) {

java/org/apache/catalina/core/StandardService.java:467: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.stopInternal()` reads without synchronization from `this.name`. Potentially races with write in method `StandardService.setName(...)`.
 Reporting because this access may occur on a background thread.
  465.   
  466.           if(log.isInfoEnabled())
  467. >             log.info(sm.getString("standardService.stop.name", this.name));
  468.           setState(LifecycleState.STOPPING);
  469.   

java/org/apache/catalina/core/StandardService.java:471: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardService.stopInternal()` reads without synchronization from `this.engine`. Potentially races with write in method `StandardService.setContainer(...)`.
 Reporting because this access may occur on a background thread.
  469.   
  470.           // Stop our defined Container second
  471. >         if (engine != null) {
  472.               synchronized (engine) {
  473.                   engine.stop();

java/org/apache/catalina/deploy/NamingResourcesImpl.java:1003: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void NamingResourcesImpl.stopInternal()` indirectly reads without synchronization from container `this.resources` via call to `values`. Potentially races with write in method `NamingResourcesImpl.removeResource(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1001.       @Override
  1002.       protected void stopInternal() throws LifecycleException {
  1003. >         cleanUp();
  1004.           setState(LifecycleState.STOPPING);
  1005.           fireLifecycleEvent(CONFIGURE_STOP_EVENT, null);

java/org/apache/catalina/realm/JDBCRealm.java:738: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void JDBCRealm.stopInternal()` indirectly writes to field `this.dbConnection` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  736.   
  737.           // Close any open DB connection
  738. >         close(this.dbConnection);
  739.   
  740.       }

java/org/apache/catalina/session/StandardManager.java:382: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardManager.stopInternal()` indirectly reads with synchronization from `session.authType`. Potentially races with unsynchronized write in method `StandardManager.doUnload()`.
 Reporting because this access may occur on a background thread.
  380.           // Write out sessions
  381.           try {
  382. >             unload();
  383.           } catch (Throwable t) {
  384.               ExceptionUtils.handleThrowable(t);

java/org/apache/catalina/tribes/group/interceptors/MessageDispatchInterceptor.java:126: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void MessageDispatchInterceptor.stopQueue()` reads without synchronization from `this.executor`. Potentially races with write in method `MessageDispatchInterceptor.start(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  124.       public void stopQueue() {
  125.           run = false;
  126. >         executor.shutdownNow();
  127.           setAndGetCurrentSize(0);
  128.       }

webapps/examples/WEB-INF/classes/websocket/snake/SnakeTimer.java:111: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SnakeTimer.stopTimer()` reads without synchronization from `snake.SnakeTimer.gameTimer`. Potentially races with write in method `SnakeTimer.addSnake(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  109.   
  110.       public static void stopTimer() {
  111. >         if (gameTimer != null) {
  112.               gameTimer.cancel();
  113.           }

java/org/apache/coyote/http2/Http2UpgradeHandler.java:1427: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2UpgradeHandler.swallowedPadding(int,int)` indirectly reads without synchronization from container `this.streams` via call to `get`. Potentially races with write in method `Http2UpgradeHandler.push(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1425.       public void swallowedPadding(int streamId, int paddingLength) throws
  1426.               ConnectionException, IOException {
  1427. >         Stream stream = getStream(streamId, true);
  1428.           // +1 is for the payload byte used to define the padding length
  1429.           writeWindowUpdate(stream, paddingLength + 1, false);

java/org/apache/catalina/session/PersistentManagerBase.java:682: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `Session PersistentManagerBase.swapIn(String)` reads without synchronization from `this.store`. Potentially races with write in method `PersistentManagerBase.setStore(...)`.
 Reporting because this access may occur on a background thread.
  680.       protected Session swapIn(String id) throws IOException {
  681.   
  682. >         if (store == null)
  683.               return null;
  684.   

java/org/apache/catalina/session/PersistentManagerBase.java:811: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PersistentManagerBase.swapOut(Session)` indirectly mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  809.           ((StandardSession)session).passivate();
  810.           writeSession(session);
  811. >         super.remove(session, true);
  812.           session.recycle();
  813.   

java/org/apache/catalina/session/StandardSession.java:431: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.tellChangedSessionId(String,String,boolean,boolean)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  429.               if (listeners != null && listeners.length > 0) {
  430.                   HttpSessionEvent event =
  431. >                     new HttpSessionEvent(getSession());
  432.   
  433.                   for(Object listener : listeners) {

java/org/apache/catalina/session/StandardSession.java:379: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.tellNew()` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  377.           if (listeners != null && listeners.length > 0) {
  378.               HttpSessionEvent event =
  379. >                 new HttpSessionEvent(getSession());
  380.               for (int i = 0; i < listeners.length; i++) {
  381.                   if (!(listeners[i] instanceof HttpSessionListener))

java/org/apache/catalina/core/ContainerBase.java:1271: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContainerBase.threadStart()` reads without synchronization from `this.backgroundProcessorFuture`. Potentially races with write in method `ContainerBase.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1269.       protected void threadStart() {
  1270.           if (backgroundProcessorDelay > 0
  1271. >                 && (getState().isAvailable() || LifecycleState.STARTING_PREP.equals(getState()))
  1272.                   && (backgroundProcessorFuture == null || backgroundProcessorFuture.isDone())) {
  1273.               if (backgroundProcessorFuture != null && backgroundProcessorFuture.isDone()) {

java/org/apache/catalina/core/ContainerBase.java:1282: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContainerBase.threadStart()` writes to field `this.backgroundProcessorFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1280.               }
  1281.               backgroundProcessorFuture = Container.getService(this).getServer().getUtilityExecutor()
  1282. >                     .scheduleWithFixedDelay(new ContainerBackgroundProcessor(),
  1283.                               backgroundProcessorDelay, backgroundProcessorDelay,
  1284.                               TimeUnit.SECONDS);

java/org/apache/catalina/core/ContainerBase.java:1296: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContainerBase.threadStop()` writes to field `this.backgroundProcessorFuture` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1294.           if (backgroundProcessorFuture != null) {
  1295.               backgroundProcessorFuture.cancel(true);
  1296. >             backgroundProcessorFuture = null;
  1297.           }
  1298.       }

java/org/apache/catalina/core/ContainerBase.java:1294: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContainerBase.threadStop()` reads without synchronization from `this.backgroundProcessorFuture`. Potentially races with write in method `ContainerBase.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1292.        */
  1293.       protected void threadStop() {
  1294. >         if (backgroundProcessorFuture != null) {
  1295.               backgroundProcessorFuture.cancel(true);
  1296.               backgroundProcessorFuture = null;

java/org/apache/catalina/core/AsyncContextImpl.java:127: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AsyncContextImpl.timeout()` reads without synchronization from `this.context`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  125.           request.getCoyoteRequest().action(ActionCode.ASYNC_TIMEOUT, result);
  126.           // Avoids NPEs during shutdown. A call to recycle will null this field.
  127. >         Context context = this.context;
  128.   
  129.           if (result.get()) {

java/org/apache/catalina/core/AsyncContextImpl.java:139: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean AsyncContextImpl.timeout()` reads without synchronization from `this.event`. Potentially races with write in method `AsyncContextImpl.setStarted(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  137.                   for (AsyncListenerWrapper listener : listenersCopy) {
  138.                       try {
  139. >                         listener.fireOnTimeout(event);
  140.                       } catch (Throwable t) {
  141.                           ExceptionUtils.handleThrowable(t);

java/org/apache/tomcat/util/net/NioEndpoint.java:994: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void NioEndpoint$Poller.timeout(int,boolean)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  992.                                           cancelledKey(key, socketWrapper);
  993.                                       }
  994. >                                 } else if (!processSocket(socketWrapper, SocketEvent.ERROR, true)) {
  995.                                       cancelledKey(key, socketWrapper);
  996.                                   }

java/org/apache/coyote/AbstractProcessor.java:653: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.timeoutAsync(long)` indirectly writes to field `sc.socketWrapper` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  651.                   long asyncStart = asyncStateMachine.getLastAsyncStart();
  652.                   if ((now - asyncStart) > asyncTimeout) {
  653. >                     doTimeoutAsync();
  654.                   }
  655.               } else if (!asyncStateMachine.isAvailable()) {

java/org/apache/coyote/AbstractProcessor.java:647: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractProcessor.timeoutAsync(long)` indirectly writes to field `sc.event` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  645.       public void timeoutAsync(long now) {
  646.           if (now < 0) {
  647. >             doTimeoutAsync();
  648.           } else {
  649.               long asyncTimeout = getAsyncTimeout();

java/org/apache/catalina/users/MemoryUserDatabase.java:706: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String MemoryUserDatabase.toString()` reads without synchronization from container `this.roles` via call to `size`. Potentially races with write in method `MemoryUserDatabase.open()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  704.           sb.append(this.groups.size());
  705.           sb.append(",roleCount=");
  706. >         sb.append(this.roles.size());
  707.           sb.append(",userCount=");
  708.           sb.append(this.users.size());

java/org/apache/catalina/users/MemoryUserDatabase.java:708: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String MemoryUserDatabase.toString()` reads without synchronization from container `this.users` via call to `size`. Potentially races with write in method `MemoryUserDatabase.createUser(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  706.           sb.append(this.roles.size());
  707.           sb.append(",userCount=");
  708. >         sb.append(this.users.size());
  709.           sb.append("]");
  710.           return sb.toString();

java/org/apache/catalina/users/MemoryUserDatabase.java:704: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String MemoryUserDatabase.toString()` reads without synchronization from container `this.groups` via call to `size`. Potentially races with write in method `MemoryUserDatabase.open()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  702.           sb.append(pathname);
  703.           sb.append(",groupCount=");
  704. >         sb.append(this.groups.size());
  705.           sb.append(",roleCount=");
  706.           sb.append(this.roles.size());

java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java:1233: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String BaseGenericObjectPool$StatsStore.toString()` reads without synchronization from `this.index`. Potentially races with write in method `BaseGenericObjectPool$StatsStore.add(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1231.               builder.append(size);
  1232.               builder.append(", index=");
  1233. >             builder.append(index);
  1234.               builder.append("]");
  1235.               return builder.toString();

java/org/apache/tomcat/util/modeler/ManagedBean.java:411: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.toString()` reads without synchronization from `this.name`. Potentially races with write in method `ManagedBean.setName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  409.           StringBuilder sb = new StringBuilder("ManagedBean[");
  410.           sb.append("name=");
  411. >         sb.append(name);
  412.           sb.append(", className=");
  413.           sb.append(className);

java/org/apache/tomcat/util/modeler/ManagedBean.java:421: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.toString()` reads without synchronization from `this.type`. Potentially races with write in method `ManagedBean.setType(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  419.           }
  420.           sb.append(", type=");
  421. >         sb.append(type);
  422.           sb.append("]");
  423.           return sb.toString();

java/org/apache/tomcat/util/modeler/ManagedBean.java:415: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.toString()` reads without synchronization from `this.description`. Potentially races with write in method `ManagedBean.setDescription(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  413.           sb.append(className);
  414.           sb.append(", description=");
  415. >         sb.append(description);
  416.           if (group != null) {
  417.               sb.append(", group=");

java/org/apache/tomcat/util/modeler/ManagedBean.java:413: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String ManagedBean.toString()` reads without synchronization from `this.className`. Potentially races with write in method `ManagedBean.setClassName(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  411.           sb.append(name);
  412.           sb.append(", className=");
  413. >         sb.append(className);
  414.           sb.append(", description=");
  415.           sb.append(description);

java/org/apache/tomcat/util/modeler/NotificationInfo.java:144: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String NotificationInfo.toString()` reads without synchronization from `this.description`. Potentially races with write in method `NotificationInfo.setDescription(...)`.
 Reporting because this access may occur on a background thread.
  142.           sb.append(name);
  143.           sb.append(", description=");
  144. >         sb.append(description);
  145.           sb.append(", notifTypes=");
  146.           Lock readLock = notifTypesLock.readLock();

java/org/apache/tomcat/util/modeler/NotificationInfo.java:142: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String NotificationInfo.toString()` reads without synchronization from `this.name`. Potentially races with write in method `NotificationInfo.setName(...)`.
 Reporting because this access may occur on a background thread.
  140.           StringBuilder sb = new StringBuilder("NotificationInfo[");
  141.           sb.append("name=");
  142. >         sb.append(name);
  143.           sb.append(", description=");
  144.           sb.append(description);

java/org/apache/tomcat/util/net/AprEndpoint.java:1255: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String AprEndpoint$Poller.toString()` reads without synchronization from `this.desc`. Potentially races with write in method `AprEndpoint$Poller.init()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1253.               buf.append(" [ ");
  1254.               for (int j = 0; j < count; j++) {
  1255. >                 buf.append(desc[2*j+1]).append(" ");
  1256.               }
  1257.               buf.append("]");

java/org/apache/tomcat/util/net/AprEndpoint.java:1251: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String AprEndpoint$Poller.toString()` reads without synchronization from `this.pollerSize`. Potentially races with write in method `AprEndpoint$Poller.init()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1249.               StringBuffer buf = new StringBuffer();
  1250.               buf.append("Poller");
  1251. >             long[] res = new long[pollerSize * 2];
  1252.               int count = Poll.pollset(aprPoller, res);
  1253.               buf.append(" [ ");

java/org/apache/tomcat/util/net/AprEndpoint.java:1252: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String AprEndpoint$Poller.toString()` reads without synchronization from `this.aprPoller`. Potentially races with write in method `AprEndpoint$Poller.run()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1250.               buf.append("Poller");
  1251.               long[] res = new long[pollerSize * 2];
  1252. >             int count = Poll.pollset(aprPoller, res);
  1253.               buf.append(" [ ");
  1254.               for (int j = 0; j < count; j++) {

java/org/apache/tomcat/util/buf/StringCache.java:326: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StringCache.toString(ByteChunk)` writes to field `buf.StringCache.hitCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  324.               }
  325.               // Note: We don't care about safety for the stats
  326. >             hitCount++;
  327.               return result;
  328.           }

java/org/apache/tomcat/util/buf/StringCache.java:305: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StringCache.toString(ByteChunk)` indirectly reads with synchronization from `bc.charset`. Potentially races with unsynchronized write in method `StringCache.toString(...)`.
 Reporting because this access may occur on a background thread.
  303.                                       0, end - start);
  304.                               // Set encoding
  305. >                             entry.charset = bc.getCharset();
  306.                               // Initialize occurrence count to one
  307.                               count = new int[1];

java/org/apache/tomcat/util/buf/StringCache.java:222: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StringCache.toString(ByteChunk)` reads without synchronization from `buf.StringCache.byteEnabled`. Potentially races with write in method `StringCache.setByteEnabled(...)`.
 Reporting because this access may occur on a background thread.
  220.           if (bcCache == null) {
  221.               String value = bc.toStringInternal();
  222. >             if (byteEnabled && (value.length() < maxStringSize)) {
  223.                   // If training, everything is synced
  224.                   synchronized (bcStats) {

java/org/apache/tomcat/util/buf/StringCache.java:319: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StringCache.toString(ByteChunk)` writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  317.               return value;
  318.           } else {
  319. >             accessCount++;
  320.               // Find the corresponding String
  321.               String result = find(bc);

java/org/apache/tomcat/util/buf/StringCache.java:221: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StringCache.toString(ByteChunk)` indirectly writes to field `bc.charset` outside of synchronization.
 Reporting because this access may occur on a background thread.
  219.           // still training
  220.           if (bcCache == null) {
  221. >             String value = bc.toStringInternal();
  222.               if (byteEnabled && (value.length() < maxStringSize)) {
  223.                   // If training, everything is synced

java/org/apache/tomcat/util/buf/StringCache.java:441: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StringCache.toString(CharChunk)` writes to field `buf.StringCache.hitCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  439.               }
  440.               // Note: We don't care about safety for the stats
  441. >             hitCount++;
  442.               return result;
  443.           }

java/org/apache/tomcat/util/buf/StringCache.java:339: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `String StringCache.toString(CharChunk)` reads without synchronization from `buf.StringCache.charEnabled`. Potentially races with write in method `StringCache.setCharEnabled(...)`.
 Reporting because this access may occur on a background thread.
  337.           if (ccCache == null) {
  338.               String value = cc.toStringInternal();
  339. >             if (charEnabled && (value.length() < maxStringSize)) {
  340.                   // If training, everything is synced
  341.                   synchronized (ccStats) {

java/org/apache/tomcat/util/buf/StringCache.java:434: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `String StringCache.toString(CharChunk)` writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  432.               return value;
  433.           } else {
  434. >             accessCount++;
  435.               // Find the corresponding String
  436.               String result = find(cc);

java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java:1379: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BaseGenericObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.evictionIterator`. Potentially races with write in method `BaseGenericObjectPool.startEvictor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1377.           builder.append(evictor);
  1378.           builder.append(", evictionIterator=");
  1379. >         builder.append(evictionIterator);
  1380.           builder.append(", factoryClassLoader=");
  1381.           builder.append(factoryClassLoader);

java/org/apache/tomcat/dbcp/pool2/impl/BaseGenericObjectPool.java:1377: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void BaseGenericObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.evictor`. Potentially races with write in method `BaseGenericObjectPool.startEvictor(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1375.           builder.append(evictionLock);
  1376.           builder.append(", evictor=");
  1377. >         builder.append(evictor);
  1378.           builder.append(", evictionIterator=");
  1379.           builder.append(evictionIterator);

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1623: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.evictionKeyIterator`. Potentially races with write in method `GenericKeyedObjectPool.evict()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1621.           builder.append(numTotal);
  1622.           builder.append(", evictionKeyIterator=");
  1623. >         builder.append(evictionKeyIterator);
  1624.           builder.append(", evictionKey=");
  1625.           builder.append(evictionKey);

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1603: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.toStringAppendFields(StringBuilder)` indirectly reads without synchronization from `this.evictionIterator`. Potentially races with write in method `GenericKeyedObjectPool.close()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1601.       @Override
  1602.       protected void toStringAppendFields(final StringBuilder builder) {
  1603. >         super.toStringAppendFields(builder);
  1604.           builder.append(", maxIdlePerKey=");
  1605.           builder.append(maxIdlePerKey);

java/org/apache/tomcat/dbcp/pool2/impl/GenericKeyedObjectPool.java:1625: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericKeyedObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.evictionKey`. Potentially races with write in method `GenericKeyedObjectPool.evict()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1623.           builder.append(evictionKeyIterator);
  1624.           builder.append(", evictionKey=");
  1625. >         builder.append(evictionKey);
  1626.       }
  1627.   }

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:1198: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericObjectPool.toStringAppendFields(StringBuilder)` indirectly reads without synchronization from `this.evictionIterator`. Potentially races with write in method `GenericObjectPool.evict()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1196.       @Override
  1197.       protected void toStringAppendFields(final StringBuilder builder) {
  1198. >         super.toStringAppendFields(builder);
  1199.           builder.append(", factoryType=");
  1200.           builder.append(factoryType);

java/org/apache/tomcat/dbcp/pool2/impl/SoftReferenceObjectPool.java:448: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SoftReferenceObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.destroyCount`. Potentially races with write in method `SoftReferenceObjectPool.returnObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  446.           builder.append(numActive);
  447.           builder.append(", destroyCount=");
  448. >         builder.append(destroyCount);
  449.           builder.append(", createCount=");
  450.           builder.append(createCount);

java/org/apache/tomcat/dbcp/pool2/impl/SoftReferenceObjectPool.java:446: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SoftReferenceObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.numActive`. Potentially races with write in method `SoftReferenceObjectPool.returnObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  444.           builder.append(refQueue);
  445.           builder.append(", numActive=");
  446. >         builder.append(numActive);
  447.           builder.append(", destroyCount=");
  448.           builder.append(destroyCount);

java/org/apache/tomcat/dbcp/pool2/impl/SoftReferenceObjectPool.java:450: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void SoftReferenceObjectPool.toStringAppendFields(StringBuilder)` reads without synchronization from `this.createCount`. Potentially races with write in method `SoftReferenceObjectPool.borrowObject()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  448.           builder.append(destroyCount);
  449.           builder.append(", createCount=");
  450. >         builder.append(createCount);
  451.           builder.append(", idleReferences=");
  452.           builder.append(idleReferences);

java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java:216: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ManagedConnection.transactionComplete()` writes to field `this.isSharedConnection` outside of synchronization.
 Reporting because this access may occur on a background thread.
  214.           if (isSharedConnection) {
  215.               setDelegate(null);
  216. >             isSharedConnection = false;
  217.           }
  218.   

java/org/apache/tomcat/dbcp/dbcp2/managed/ManagedConnection.java:214: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ManagedConnection.transactionComplete()` reads without synchronization from `this.isSharedConnection`. Potentially races with write in method `ManagedConnection.transactionComplete()`.
 Reporting because this access may occur on a background thread.
  212.           // If we were using a shared connection, clear the reference now that
  213.           // the transaction has completed
  214. >         if (isSharedConnection) {
  215.               setDelegate(null);
  216.               isSharedConnection = false;

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:537: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void AbstractReplicatedMap.transferState()` writes to field `this.stateTransferred` outside of synchronization.
 Reporting because this access may occur on a background thread.
  535.                           } //for
  536.                       }
  537. >                     stateTransferred = true;
  538.                   } else {
  539.                       log.warn(sm.getString("abstractReplicatedMap.transferState.noReplies"));

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:527: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.transferState()` reads without synchronization from `this.channelSendOptions`. Potentially races with write in method `AbstractReplicatedMap.setChannelSendOptions(...)`.
 Reporting because this access may occur on a background thread.
  525.                   MapMessage msg = new MapMessage(mapContextName, getStateMessageType(), false,
  526.                                                   null, null, null, null, null);
  527. >                 Response[] resp = rpcChannel.send(new Member[] {backup}, msg, RpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);
  528.                   if (resp.length > 0) {
  529.                       synchronized (stateMutex) {

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:525: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.transferState()` reads without synchronization from `this.mapContextName`. Potentially races with write in method `AbstractReplicatedMap.init(...)`.
 Reporting because this access may occur on a background thread.
  523.               Member backup = members.length > 0 ? members[0] : null;
  524.               if (backup != null) {
  525. >                 MapMessage msg = new MapMessage(mapContextName, getStateMessageType(), false,
  526.                                                   null, null, null, null, null);
  527.                   Response[] resp = rpcChannel.send(new Member[] {backup}, msg, RpcChannel.FIRST_REPLY, channelSendOptions, rpcTimeout);

java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java:534: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void AbstractReplicatedMap.transferState()` indirectly reads with synchronization from `entry.backup`. Potentially races with unsynchronized write in method `AbstractReplicatedMap.memberDisappeared(...)`.
 Reporting because this access may occur on a background thread.
  532.                           ArrayList<?> list = (ArrayList<?>) msg.getValue();
  533.                           for (int i = 0; i < list.size(); i++) {
  534. >                             messageReceived( (Serializable) list.get(i), resp[0].getSource());
  535.                           } //for
  536.                       }

java/org/apache/catalina/core/StandardWrapper.java:1224: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardWrapper.unavailable(UnavailableException)` indirectly writes to field `this.available` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1222.           getServletContext().log(sm.getString("standardWrapper.unavailable", getName()));
  1223.           if (unavailable == null)
  1224. >             setAvailable(Long.MAX_VALUE);
  1225.           else if (unavailable.isPermanent())
  1226.               setAvailable(Long.MAX_VALUE);

java/org/apache/catalina/core/StandardContext.java:5749: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardContext.unbindThread(ClassLoader)` indirectly mutates container `naming.ContextBindings.threadBindings` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5747.   
  5748.           if (isUseNaming()) {
  5749. >             ContextBindings.unbindThread(this, getNamingToken());
  5750.           }
  5751.   

java/org/apache/catalina/core/StandardContext.java:5748: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void StandardContext.unbindThread(ClassLoader)` indirectly reads without synchronization from `this.useNaming`. Potentially races with write in method `StandardContext.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  5746.       protected void unbindThread(ClassLoader oldContextClassLoader) {
  5747.   
  5748. >         if (isUseNaming()) {
  5749.               ContextBindings.unbindThread(this, getNamingToken());
  5750.           }

java/org/apache/catalina/session/PersistentManagerBase.java:626: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void PersistentManagerBase.unload()` indirectly writes to field `sessions.[_].facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  624.           for (int i = 0; i < n; i++)
  625.               try {
  626. >                 swapOut(sessions[i]);
  627.               } catch (IOException e) {
  628.                   // This is logged in writeSession()

java/org/apache/catalina/session/PersistentManagerBase.java:615: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PersistentManagerBase.unload()` indirectly reads without synchronization from container `this.sessions` via call to `values`. Potentially races with write in method `PersistentManagerBase.processMaxActiveSwaps()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  613.               return;
  614.   
  615. >         Session sessions[] = findSessions();
  616.           int n = sessions.length;
  617.           if (n == 0)

java/org/apache/catalina/session/StandardManager.java:267: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardManager.unload()` indirectly writes to field `session.authType` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  265.               }
  266.           } else {
  267. >             doUnload();
  268.           }
  269.       }

modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/PooledConnection.java:753: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void PooledConnection.unlock()` reads without synchronization from `this.poolProperties`. Potentially races with write in method `PooledConnection.setPoolProperties(...)`.
 Reporting because this access may occur on a background thread.
  751.        */
  752.       public void unlock() {
  753. >         if (poolProperties.getUseLock() || this.poolProperties.isPoolSweeperEnabled()) {
  754.             //optimized, only use a lock when there is concurrency
  755.               lock.writeLock().unlock();

java/org/apache/catalina/startup/HostConfig.java:1753: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void HostConfig.unmanageApp(String)` mutates container `this.deployed` via call to `remove` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1751.       public void unmanageApp(String contextName) {
  1752.           if(isServiced(contextName)) {
  1753. >             deployed.remove(contextName);
  1754.               host.removeChild(host.findChild(contextName));
  1755.           }

java/org/apache/tomcat/websocket/WsWebSocketContainer.java:618: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsWebSocketContainer.unregisterSession(Object,WsSession)` mutates container `this.sessions` via call to `remove` outside of synchronization.
 Reporting because this access may occur on a background thread.
  616.               }
  617.           }
  618. >         sessions.remove(wsSession);
  619.       }
  620.   

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:123: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusterSingleSignOn.update(String,Principal,String,String,String)` indirectly reads without synchronization from `this.cache.channel`. Potentially races with write in method `ClusterSingleSignOn.stopInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  121.           boolean result = super.update(ssoId, principal, authType, username, password);
  122.           if (result) {
  123. >             ((ReplicatedMap<String,SingleSignOnEntry>) cache).replicate(ssoId, true);
  124.           }
  125.           return result;

java/org/apache/catalina/ha/authenticator/ClusterSingleSignOn.java:121: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean ClusterSingleSignOn.update(String,Principal,String,String,String)` indirectly reads without synchronization from `this.cache`. Potentially races with write in method `ClusterSingleSignOn.startInternal()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  119.       protected boolean update(String ssoId, Principal principal, String authType,
  120.               String username, String password) {
  121. >         boolean result = super.update(ssoId, principal, authType, username, password);
  122.           if (result) {
  123.               ((ReplicatedMap<String,SingleSignOnEntry>) cache).replicate(ssoId, true);

java/org/apache/tomcat/dbcp/pool2/impl/GenericObjectPool.java:1089: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void GenericObjectPool.use(Object)` reads without synchronization from container `this.allObjects` via call to `get`. Potentially races with write in method `GenericObjectPool.invalidateObject(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1087.           final AbandonedConfig ac = this.abandonedConfig;
  1088.           if (ac != null && ac.getUseUsageTracking()) {
  1089. >             final PooledObject<T> wrapper = allObjects.get(new IdentityWrapper<>(pooledObject));
  1090.               wrapper.use();
  1091.           }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:526: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` reads without synchronization from `this.opaqueReceived`. Potentially races with write in method `DigestAuthenticator$DigestInfo.parse(...)`.
 Reporting because this access may occur on a background thread.
  524.   
  525.               // Validate the opaque string
  526. >             if (!opaque.equals(opaqueReceived)) {
  527.                   return false;
  528.               }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:484: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` reads without synchronization from `this.nonce`. Potentially races with write in method `DigestAuthenticator$DigestInfo.parse(...)`.
 Reporting because this access may occur on a background thread.
  482.   
  483.           public boolean validate(Request request) {
  484. >             if ( (userName == null) || (realmName == null) || (nonce == null)
  485.                    || (uri == null) || (response == null) ) {
  486.                   return false;

java/org/apache/catalina/authenticator/DigestAuthenticator.java:566: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` reads without synchronization from `this.cnonce`. Potentially races with write in method `DigestAuthenticator$DigestInfo.parse(...)`.
 Reporting because this access may occur on a background thread.
  564.               // Check if presence of nc and Cnonce is consistent with presence of qop
  565.               if (qop == null) {
  566. >                 if (cnonce != null || nc != null) {
  567.                       return false;
  568.                   }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:502: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` indirectly writes to field `mh.byteC.charset` outside of synchronization.
 Reporting because this access may occur on a background thread.
  500.                       // DIGEST but a relative URI in the request line.
  501.                       // request. 2.3.5 < fixed Android version <= 4.0.3
  502. >                     String host = request.getHeader("host");
  503.                       String scheme = request.getScheme();
  504.                       if (host != null && !uriQuery.startsWith(scheme)) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:559: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` reads without synchronization from `this.qop`. Potentially races with write in method `DigestAuthenticator$DigestInfo.parse(...)`.
 Reporting because this access may occur on a background thread.
  557.   
  558.               // Validate qop
  559. >             if (qop != null && !QOP.equals(qop)) {
  560.                   return false;
  561.               }

java/org/apache/catalina/authenticator/DigestAuthenticator.java:550: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` indirectly writes to field `request.remoteAddr` outside of synchronization.
 Reporting because this access may occur on a background thread.
  548.               }
  549.               String serverIpTimeKey =
  550. >                 request.getRemoteAddr() + ":" + nonceTime + ":" + key;
  551.               byte[] buffer = ConcurrentMessageDigest.digestMD5(
  552.                       serverIpTimeKey.getBytes(StandardCharsets.ISO_8859_1));

java/org/apache/catalina/authenticator/DigestAuthenticator.java:591: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` writes to field `this.nonceStale` outside of synchronization.
 Reporting because this access may occur on a background thread.
  589.                       // Nonce is valid but not in cache. It must have dropped out
  590.                       // of the cache - force a re-authentication
  591. >                     nonceStale = true;
  592.                   } else {
  593.                       if (!info.nonceCountValid(count)) {

java/org/apache/catalina/authenticator/DigestAuthenticator.java:492: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean DigestAuthenticator$DigestInfo.validate(Request)` indirectly writes to field `buf.StringCache.accessCount` outside of synchronization.
 Reporting because this access may occur on a background thread.
  490.               if (validateUri) {
  491.                   String uriQuery;
  492. >                 String query = request.getQueryString();
  493.                   if (query == null) {
  494.                       uriQuery = request.getRequestURI();

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:118: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BasicDataSource.validateConnectionFactory(PoolableConnectionFactory)` indirectly writes to field `conn.lastValidationSql` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  116.               conn = p.getObject();
  117.               connectionFactory.activateObject(p);
  118. >             connectionFactory.validateConnection(conn);
  119.               connectionFactory.passivateObject(p);
  120.           } finally {

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:117: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BasicDataSource.validateConnectionFactory(PoolableConnectionFactory)` indirectly writes to field `conn.autoCommitCached` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  115.               p = connectionFactory.makeObject();
  116.               conn = p.getObject();
  117. >             connectionFactory.activateObject(p);
  118.               connectionFactory.validateConnection(conn);
  119.               connectionFactory.passivateObject(p);

java/org/apache/tomcat/dbcp/dbcp2/BasicDataSource.java:119: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void BasicDataSource.validateConnectionFactory(PoolableConnectionFactory)` indirectly writes to field `conn.autoCommitCached` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  117.               connectionFactory.activateObject(p);
  118.               connectionFactory.validateConnection(conn);
  119. >             connectionFactory.passivateObject(p);
  120.           } finally {
  121.               if (p != null) {

java/org/apache/catalina/ha/session/DeltaManager.java:851: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void DeltaManager.waitForSendAllSessions(long)` writes to field `this.counterNoStateTransfered` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  849.           }
  850.           if (isTimeout) {
  851. >             counterNoStateTransfered++ ;
  852.               log.error(sm.getString("deltaManager.noSessionState", getName(),
  853.                       new Date(beforeSendTime), Long.valueOf(reqNow - beforeSendTime)));

java/org/apache/catalina/startup/ContextConfig.java:1137: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `this.handlesTypesAnnotations` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1135.           // Step 3. Look for ServletContainerInitializer implementations
  1136.           if (ok) {
  1137. >             processServletContainerInitializers();
  1138.           }
  1139.   

java/org/apache/catalina/startup/ContextConfig.java:1168: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `constraint.authConstraint` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1166.               // Step 9. Apply merged web.xml to Context
  1167.               if (ok) {
  1168. >                 configureContext(webXml);
  1169.               }
  1170.           } else {

java/org/apache/catalina/startup/ContextConfig.java:1140: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.webConfig()` reads without synchronization from container `this.typeInitializerMap` via call to `size`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1138.           }
  1139.   
  1140. >         if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {
  1141.               // Steps 4 & 5.
  1142.               processClasses(webXml, orderedFragments);

java/org/apache/catalina/startup/ContextConfig.java:1110: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `this.ok` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1108.   
  1109.           Set<WebXml> tomcatWebXml = new HashSet<>();
  1110. >         tomcatWebXml.add(getTomcatWebXmlFragment(webXmlParser));
  1111.   
  1112.           WebXml webXml = createWebXml();

java/org/apache/catalina/startup/ContextConfig.java:1107: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `this.defaultWebXml` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1105.   
  1106.           Set<WebXml> defaults = new HashSet<>();
  1107. >         defaults.add(getDefaultWebXmlFragment(webXmlParser));
  1108.   
  1109.           Set<WebXml> tomcatWebXml = new HashSet<>();

java/org/apache/catalina/startup/ContextConfig.java:1104: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `digester.Digester.propertySourceSet` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1102.            */
  1103.           WebXmlParser webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),
  1104. >                 context.getXmlValidation(), context.getXmlBlockExternal());
  1105.   
  1106.           Set<WebXml> defaults = new HashSet<>();

java/org/apache/catalina/startup/ContextConfig.java:1142: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `descMap.dispatcherMapping` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1140.           if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {
  1141.               // Steps 4 & 5.
  1142. >             processClasses(webXml, orderedFragments);
  1143.           }
  1144.   

java/org/apache/catalina/startup/ContextConfig.java:1205: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.webConfig()` reads without synchronization from container `this.initializerClassMap` via call to `entrySet`. Potentially races with write in method `ContextConfig.configureStart()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1203.               for (Map.Entry<ServletContainerInitializer,
  1204.                       Set<Class<?>>> entry :
  1205. >                         initializerClassMap.entrySet()) {
  1206.                   if (entry.getValue().isEmpty()) {
  1207.                       context.addServletContainerInitializer(

java/org/apache/catalina/startup/ContextConfig.java:1136: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void ContextConfig.webConfig()` reads without synchronization from `this.ok`. Potentially races with write in method `ContextConfig.init()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1134.   
  1135.           // Step 3. Look for ServletContainerInitializer implementations
  1136. >         if (ok) {
  1137.               processServletContainerInitializers();
  1138.           }

java/org/apache/catalina/startup/ContextConfig.java:1163: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ContextConfig.webConfig()` indirectly writes to field `servletDef.jspFile` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1161.               // Step 8. Convert explicitly mentioned jsps to servlets
  1162.               if (ok) {
  1163. >                 convertJsps(webXml);
  1164.               }
  1165.   

java/org/apache/catalina/tribes/transport/nio/NioSender.java:201: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean NioSender.write()` writes to field `this.remaining` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  199.                   int byteswritten = isUdpBased()?dataChannel.write(writebuf) : socketChannel.write(writebuf);
  200.                   if (byteswritten == -1 ) throw new EOFException();
  201. >                 remaining -= byteswritten;
  202.                   //if the entire message was written from the buffer
  203.                   //reset the position counter

java/org/apache/catalina/tribes/transport/nio/NioSender.java:196: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.write()` reads without synchronization from `this.remaining`. Potentially races with write in method `NioSender.setMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  194.           }
  195.           if ( current != null ) {
  196. >             if ( remaining > 0 ) {
  197.                   //we have written everything, or we are starting a new package
  198.                   //protect against buffer overwrite

java/org/apache/catalina/tribes/transport/nio/NioSender.java:199: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.write()` reads without synchronization from `this.writebuf`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  197.                   //we have written everything, or we are starting a new package
  198.                   //protect against buffer overwrite
  199. >                 int byteswritten = isUdpBased()?dataChannel.write(writebuf) : socketChannel.write(writebuf);
  200.                   if (byteswritten == -1 ) throw new EOFException();
  201.                   remaining -= byteswritten;

java/org/apache/catalina/tribes/transport/nio/NioSender.java:192: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean NioSender.write()` reads without synchronization from `this.dataChannel`. Potentially races with write in method `NioSender.connect()`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  190.   
  191.       protected boolean write() throws IOException {
  192. >         if ( (!isConnected()) || (this.socketChannel==null && this.dataChannel==null)) {
  193.               throw new IOException(sm.getString("nioSender.not.connected"));
  194.           }

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:1003: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase$WsOutputStream.write(byte[],int,int)` indirectly writes to field `this.endpoint.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1001.   
  1002.               if (buffer.remaining() == 0) {
  1003. >                 flush();
  1004.               }
  1005.               int remaining = buffer.remaining();

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:980: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase$WsOutputStream.write(int)` indirectly writes to field `this.endpoint.fragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  978.               used = true;
  979.               if (buffer.remaining() == 0) {
  980. >                 flush();
  981.               }
  982.               buffer.put((byte) b);

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:224: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.writeBody(Stream,ByteBuffer,int,boolean)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  222.                       applicationErrorCompletion, ByteBuffer.wrap(header), data);
  223.               data.limit(orgLimit);
  224. >             handleAsyncException();
  225.           }
  226.       }

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:169: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.writeGoAwayFrame(int,long,byte[])` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  167.                       ByteBuffer.wrap(fixedPayload));
  168.           }
  169. >         handleAsyncException();
  170.       }
  171.   

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:281: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean FileMessageFactory.writeMessage(FileMessage)` indirectly writes to field `this.closed` outside of synchronization.
 Reporting because this access may occur on a background thread.
  279.               if (next.getMessageNumber() == next.getTotalNrOfMsgs()) {
  280.                   out.close();
  281. >                 cleanup();
  282.                   return true;
  283.               }

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:253: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `boolean FileMessageFactory.writeMessage(FileMessage)` mutates container `this.msgBuffer` via call to `put` outside of synchronization.
 Reporting because this access may occur on a background thread.
  251.   
  252.           FileMessage previous =
  253. >             msgBuffer.put(Long.valueOf(msg.getMessageNumber()), msg);
  254.           if (previous != null) {
  255.               // Duplicate of message not yet processed

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:264: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean FileMessageFactory.writeMessage(FileMessage)` reads with synchronization from `this.lastMessageProcessed`. Potentially races with unsynchronized write in method `FileMessageFactory.writeMessage(...)`.
 Reporting because this access may occur on a background thread.
  262.           synchronized (this) {
  263.               if (!isWriting) {
  264. >                 next = msgBuffer.get(Long.valueOf(lastMessageProcessed.get() + 1));
  265.                   if (next != null) {
  266.                       isWriting = true;

java/org/apache/catalina/ha/deploy/FileMessageFactory.java:276: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean FileMessageFactory.writeMessage(FileMessage)` reads without synchronization from `this.out`. Potentially races with write in method `FileMessageFactory.isValid()`.
 Reporting because this access may occur on a background thread.
  274.   
  275.           while (next != null) {
  276. >             out.write(next.getData(), 0, next.getDataLength());
  277.               lastMessageProcessed.incrementAndGet();
  278.               out.flush();

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:458: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.writeMessagePart(MessagePart)` reads without synchronization from `this.text`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  456.               if (fragmented) {
  457.                   // Currently fragmented
  458. >                 if (text != isText) {
  459.                       throw new IllegalStateException(
  460.                               sm.getString("wsRemoteEndpoint.changeType"));

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:447: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.writeMessagePart(MessagePart)` writes to field `this.nextFragmented` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  445.           boolean first;
  446.           if (Util.isControl(mp.getOpCode())) {
  447. >             nextFragmented = fragmented;
  448.               nextText = text;
  449.               if (mp.getOpCode() == Constants.OPCODE_CLOSE) {

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:448: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void WsRemoteEndpointImplBase.writeMessagePart(MessagePart)` writes to field `this.nextText` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  446.           if (Util.isControl(mp.getOpCode())) {
  447.               nextFragmented = fragmented;
  448. >             nextText = text;
  449.               if (mp.getOpCode() == Constants.OPCODE_CLOSE) {
  450.                   closed = true;

java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java:456: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void WsRemoteEndpointImplBase.writeMessagePart(MessagePart)` reads without synchronization from `this.fragmented`. Potentially races with write in method `WsRemoteEndpointImplBase.endMessage(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  454.               boolean isText = Util.isText(mp.getOpCode());
  455.   
  456. >             if (fragmented) {
  457.                   // Currently fragmented
  458.                   if (text != isText) {

java/org/apache/catalina/session/StandardSession.java:1065: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void StandardSession.writeObjectData(ObjectOutputStream)` indirectly writes to field `this.facade` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  1063.           throws IOException {
  1064.   
  1065. >         doWriteObject(stream);
  1066.   
  1067.       }

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:112: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.writeSettings()` reads without synchronization from `this.error`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  110.                   ByteBuffer.wrap(localSettings.getSettingsFrameForPending()),
  111.                   ByteBuffer.wrap(createWindowUpdateForSettings()));
  112. >         if (error != null) {
  113.               String msg = sm.getString("upgradeHandler.sendPrefaceFail", connectionId);
  114.               if (log.isDebugEnabled()) {

java/org/apache/coyote/http2/Http2AsyncUpgradeHandler.java:249: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `void Http2AsyncUpgradeHandler.writeWindowUpdate(Stream,int,boolean)` indirectly reads without synchronization from `stream.allocationManager.waitingFor`. Potentially races with write in method `Http2AsyncUpgradeHandler.writeHeaders(...)`.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  247.                   TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, errorCompletion,
  248.                   ByteBuffer.wrap(frame), ByteBuffer.wrap(frame2));
  249. >         handleAsyncException();
  250.       }
  251.   

Summary of the reports

      THREAD_SAFETY_VIOLATION: 1461
             NULL_DEREFERENCE: 220
                RESOURCE_LEAK: 74
                   STARVATION: 2
                     DEADLOCK: 2
  INEFFICIENT_KEYSET_ITERATOR: 1